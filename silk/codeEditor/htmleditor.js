(() => { var m = class gf { lineAt(t) { if (t < 0 || t > this.length) throw new RangeError(`Invalid position ${t} in document of length ` + this.length); return this.lineInner(t, !1, 1, 0) } line(t) { if (t < 1 || t > this.lines) throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`); return this.lineInner(t, !0, 1, 0) } replace(t, e, i) { [t, e] = D(this, t, e); var r = []; return this.decompose(0, t, r, 2), i.length && i.decompose(0, i.length, r, 3), this.decompose(e, this.length, r, 1), Y.from(r, this.length - (e - t) + i.length) } append(t) { return this.replace(this.length, this.length, t) } slice(t, e = this.length) { [t, e] = D(this, t, e); var i = []; return this.decompose(t, e, i, 0), Y.from(i, e - t) } eq(t) { if (t == this) return !0; if (t.length != this.length || t.lines != this.lines) return !1; var i = this.scanIdentical(t, 1), r = this.length - this.scanIdentical(t, -1), n = new q(this), s = new q(t); for (let t = i, e = i; ;) { if (n.next(t), s.next(t), t = 0, n.lineBreak != s.lineBreak || n.done != s.done || n.value != s.value) return !1; if (e += n.value.length, n.done || e >= r) return !0 } } iter(t = 1) { return new q(this, t) } iterRange(t, e = this.length) { return new _(this, t, e) } iterLines(t, e) { let i; return i = null == t ? this.iter() : (null == e && (e = this.lines + 1), t = this.line(t).from, this.iterRange(t, Math.max(t, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to))), new j(i) } toString() { return this.sliceString(0) } toJSON() { var t = []; return this.flatten(t), t } constructor() { } static of(t) { if (0 == t.length) throw new RangeError("A document must have at least one line"); return 1 != t.length || t[0] ? t.length <= 32 ? new R(t) : Y.from(R.split(t, [])) : gf.empty } }, R = class vf extends m { constructor(t, e = (t => { let e = -1; for (var i of t) e += i.length + 1; return e })(t)) { super(), this.text = t, this.length = e } get lines() { return this.text.length } get children() { return null } lineInner(e, i, r, n) { for (let t = 0; ; t++) { var s = this.text[t], o = n + s.length; if (e <= (i ? r : o)) return new E(n, o, r, s); n = o + 1, r++ } } decompose(t, e, i, r) { e = t <= 0 && e >= this.length ? this : new vf(M(this.text, t, e), Math.min(e, this.length) - Math.max(0, t)); 1 & r ? (t = i.pop(), (r = V(e.text, t.text.slice(), 0, e.length)).length <= 32 ? i.push(new vf(r, t.length + e.length)) : (t = r.length >> 1, i.push(new vf(r.slice(0, t)), new vf(r.slice(t))))) : i.push(e) } replace(t, e, i) { if (!(i instanceof vf)) return super.replace(t, e, i);[t, e] = D(this, t, e); var r = V(this.text, V(i.text, M(this.text, 0, t)), e), i = this.length + i.length - (e - t); return r.length <= 32 ? new vf(r, i) : Y.from(vf.split(r, []), i) } sliceString(i, r = this.length, n = "\n") { [i, r] = D(this, i, r); let s = ""; for (let t = 0, e = 0; t <= r && e < this.text.length; e++) { var o = this.text[e], a = t + o.length; t > i && e && (s += n), i < a && r > t && (s += o.slice(Math.max(0, i - t), r - t)), t = a + 1 } return s } flatten(t) { for (var e of this.text) t.push(e) } scanIdentical() { return 0 } static split(t, e) { let i = [], r = -1; for (var n of t) i.push(n), r += n.length + 1, 32 == i.length && (e.push(new vf(i, r)), i = [], r = -1); return -1 < r && e.push(new vf(i, r)), e } }, Y = class wf extends m { constructor(t, e) { super(), this.children = t, this.length = e, this.lines = 0; for (var i of t) this.lines += i.lines } lineInner(e, i, r, n) { for (let t = 0; ; t++) { var s = this.children[t], o = n + s.length, a = r + s.lines - 1; if (e <= (i ? a : o)) return s.lineInner(e, i, r, n); n = o + 1, r = 1 + a } } decompose(i, r, n, s) { for (let t = 0, e = 0; e <= r && t < this.children.length; t++) { var o, a = this.children[t], l = e + a.length; i <= l && r >= e && (o = s & ((e <= i ? 1 : 0) | (r <= l ? 2 : 0)), e >= i && l <= r && !o ? n.push(a) : a.decompose(i - e, r - e, n, o)), e = l + 1 } } replace(i, r, n) { if ([i, r] = D(this, i, r), n.lines < this.lines) for (let t = 0, e = 0; t < this.children.length; t++) { var s, o = this.children[t], a = e + o.length; if (i >= e && r <= a) return s = o.replace(i - e, r - e, n), o = this.lines - o.lines + s.lines, s.lines < o >> 4 && s.lines > o >> 6 ? ((o = this.children.slice())[t] = s, new wf(o, this.length - (r - i) + n.length)) : super.replace(e, a, s); e = a + 1 } return super.replace(i, r, n) } sliceString(i, r = this.length, n = "\n") { [i, r] = D(this, i, r); let s = ""; for (let t = 0, e = 0; t < this.children.length && e <= r; t++) { var o = this.children[t], a = e + o.length; e > i && t && (s += n), i < a && r > e && (s += o.sliceString(i - e, r - e, n)), e = a + 1 } return s } flatten(t) { for (var e of this.children) e.flatten(t) } scanIdentical(t, e) { if (!(t instanceof wf)) return 0; let i = 0, [r, n, s, o] = 0 < e ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1]; for (; ; r += e, n += e) { if (r == s || n == o) return i; var a = this.children[r], l = t.children[n]; if (a != l) return i + a.scanIdentical(l, e); i += a.length + 1 } } static from(t, e = t.reduce((t, e) => t + e.length + 1, -1)) { let i = 0; for (var r of t) i += r.lines; if (i < 32) { var n, s = []; for (n of t) n.flatten(s); return new R(s, e) } let o = Math.max(32, i >> 5), a = o << 1, l = o >> 1, h = [], c = 0, d = -1, O = []; function u() { 0 != c && (h.push(1 == O.length ? O[0] : wf.from(O, d)), d = -1, c = O.length = 0) } for (var f of t) !function t(e) { let i; if (e.lines > a && e instanceof wf) for (var r of e.children) t(r); else e.lines > l && (c > l || !c) ? (u(), h.push(e)) : e instanceof R && c && (i = O[O.length - 1]) instanceof R && e.lines + i.lines <= 32 ? (c += e.lines, d += e.length + 1, O[O.length - 1] = new R(i.text.concat(e.text), i.length + 1 + e.length)) : (c + e.lines > o && u(), c += e.lines, d += e.length + 1, O.push(e)) }(f); return u(), 1 == h.length ? h[0] : new wf(h, e) } }; function V(s, o, a = 0, l = 1e9) { for (let i = 0, r = 0, n = !0; r < s.length && i <= l; r++) { let t = s[r], e = i + t.length; a <= e && (l < e && (t = t.slice(0, l - i)), i < a && (t = t.slice(a - i)), n ? (o[o.length - 1] += t, n = !1) : o.push(t)), i = e + 1 } return o } function M(t, e, i) { return V(t, [""], e, i) } m.empty = new R([""], 0); var q = class { constructor(t, e = 1) { this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [0 < e ? 1 : (t instanceof R ? t.text : t.children).length << 1] } nextInner(t, e) { for (this.done = this.lineBreak = !1; ;) { var i = this.nodes.length - 1, r = this.nodes[i], n = this.offsets[i], s = n >> 1, o = (r instanceof R ? r.text : r.children).length; if (s == (0 < e ? o : 0)) { if (0 == i) return this.done = !0, this.value = "", this; 0 < e && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop() } else if ((1 & n) == (0 < e ? 0 : 1)) { if (this.offsets[i] += e, 0 == t) return this.lineBreak = !0, this.value = "\n", this; t-- } else if (r instanceof R) { o = r.text[s + (e < 0 ? -1 : 0)]; if (this.offsets[i] += e, o.length > Math.max(0, t)) return this.value = 0 == t ? o : 0 < e ? o.slice(t) : o.slice(0, o.length - t), this; t -= o.length } else { n = r.children[s + (e < 0 ? -1 : 0)]; t > n.length ? (t -= n.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(n), this.offsets.push(0 < e ? 1 : (n instanceof R ? n.text : n.children).length << 1)) } } } next(t = 0) { return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir) } }, _ = class { constructor(t, e, i) { this.value = "", this.done = !1, this.cursor = new q(t, i < e ? -1 : 1), this.pos = i < e ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i) } nextInner(t, e) { var i, r; return (e < 0 ? this.pos <= this.from : this.pos >= this.to) ? (this.value = "", this.done = !0) : (t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos), i = e < 0 ? this.pos - this.from : this.to - this.pos, r = (i -= t = i < t ? i : t, this.cursor.next(t)).value, this.pos += (r.length + t) * e, this.value = r.length <= i ? r : e < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value), this } next(t = 0) { return t < 0 ? t = Math.max(t, this.from - this.pos) : 0 < t && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir) } get lineBreak() { return this.cursor.lineBreak && "" != this.value } }, j = class { constructor(t) { this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1 } next(t = 0) { var { done: t, lineBreak: e, value: i } = this.inner.next(t); return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : e ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this } get lineBreak() { return !1 } }, E = ("undefined" != typeof Symbol && (m.prototype[Symbol.iterator] = function() { return this.iter() }, q.prototype[Symbol.iterator] = _.prototype[Symbol.iterator] = j.prototype[Symbol.iterator] = function() { return this }), class { constructor(t, e, i, r) { this.from = t, this.to = e, this.number = i, this.text = r } get length() { return this.to - this.from } }); function D(t, e, i) { return [e = Math.max(0, Math.min(t.length, e)), Math.max(e, Math.min(t.length, i))] } var G = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(t => t ? parseInt(t, 36) : 1); for (let t = 1; t < G.length; t++)G[t] += G[t - 1]; function I(t) { return 127462 <= t && t <= 127487 } var N = 8205; function O(t, e, i = !0, r = !0) { return (i ? U : L)(t, e, r) } function U(i, r, e) { if (r != i.length) { r && F(i.charCodeAt(r)) && H(i.charCodeAt(r - 1)) && r--; let t = Q(i, r); for (r += K(t); r < i.length;) { var n = Q(i, r); if (t == N || n == N || e && (e => { for (let t = 1; t < G.length; t += 2)if (G[t] > e) return G[t - 1] <= e })(n)) r += K(n), t = n; else { if (!I(n)) break; { let t = 0, e = r - 2; for (; 0 <= e && I(Q(i, e));)t++, e -= 2; if (t % 2 == 0) break; r += 2 } } } } return r } function L(t, e, i) { for (; 0 < e;) { var r = U(t, e - 2, i); if (r < e) return r; e-- } return 0 } function F(t) { return 56320 <= t && t < 57344 } function H(t) { return 55296 <= t && t < 56320 } function Q(t, e) { var i = t.charCodeAt(e); return H(i) && e + 1 != t.length && F(t = t.charCodeAt(e + 1)) ? t - 56320 + (i - 55296 << 10) + 65536 : i } function J(t) { return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) } function K(t) { return t < 65536 ? 1 : 2 } var tt = /\r\n?|\n/, h = (t => (t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t))(h = h || {}), et = class bf { constructor(t) { this.sections = t } get length() { let e = 0; for (let t = 0; t < this.sections.length; t += 2)e += this.sections[t]; return e } get newLength() { let e = 0; for (let t = 0; t < this.sections.length; t += 2) { var i = this.sections[t + 1]; e += i < 0 ? this.sections[t] : i } return e } get empty() { return 0 == this.sections.length || 2 == this.sections.length && this.sections[1] < 0 } iterGaps(r) { for (let t = 0, e = 0, i = 0; t < this.sections.length;) { var n = this.sections[t++], s = this.sections[t++]; s < 0 ? (r(e, i, n), i += n) : i += s, e += n } } iterChangedRanges(t, e = !1) { nt(this, t, e) } get invertedDesc() { var e = []; for (let t = 0; t < this.sections.length;) { var i = this.sections[t++], r = this.sections[t++]; r < 0 ? e.push(i, r) : e.push(r, i) } return new bf(e) } composeDesc(t) { return this.empty ? t : t.empty ? this : ot(this, t) } mapDesc(t, e = !1) { return t.empty ? this : st(this, t, e) } mapPos(e, i = -1, r = h.Simple) { let n = 0, s = 0; for (let t = 0; t < this.sections.length;) { var o = this.sections[t++], a = this.sections[t++], l = n + o; if (a < 0) { if (e < l) return s + (e - n); s += o } else { if (r != h.Simple && e <= l && (r == h.TrackDel && n < e && e < l || r == h.TrackBefore && n < e || r == h.TrackAfter && e < l)) return null; if (e < l || l == e && i < 0 && !o) return e == n || i < 0 ? s : s + a; s += a } n = l } if (e > n) throw new RangeError(`Position ${e} is out of range for changeset of length ` + n); return s } touchesRange(i, r = i) { for (let t = 0, e = 0; t < this.sections.length && e <= r;) { var n = this.sections[t++], s = this.sections[t++], n = e + n; if (0 <= s && e <= r && i <= n) return !(e < i && r < n) || "cover"; e = n } return !1 } toString() { let e = ""; for (let t = 0; t < this.sections.length;) { var i = this.sections[t++], r = this.sections[t++]; e += (e ? " " : "") + i + (0 <= r ? ":" + r : "") } return e } toJSON() { return this.sections } static fromJSON(t) { if (!Array.isArray(t) || t.length % 2 || t.some(t => "number" != typeof t)) throw new RangeError("Invalid JSON representation of ChangeDesc"); return new bf(t) } static create(t) { return new bf(t) } }, it = class yf extends et { constructor(t, e) { super(t), this.inserted = e } apply(s) { if (this.length != s.length) throw new RangeError("Applying change set to a document with the wrong length"); return nt(this, (t, e, i, r, n) => s = s.replace(i, i + (e - t), n), !1), s } mapDesc(t, e = !1) { return st(this, t, e, !0) } invert(i) { var r = this.sections.slice(), n = []; for (let t = 0, e = 0; t < r.length; t += 2) { var s = r[t], o = r[t + 1]; if (0 <= o) { r[t] = o, r[t + 1] = s; for (var a = t >> 1; n.length < a;)n.push(m.empty); n.push(s ? i.slice(e, e + s) : m.empty) } e += s } return new yf(r, n) } compose(t) { return this.empty ? t : t.empty ? this : ot(this, t, !0) } map(t, e = !1) { return t.empty ? this : st(this, t, e, !0) } iterChanges(t, e = !1) { nt(this, t, e) } get desc() { return et.create(this.sections) } filter(i) { var r = [], n = [], s = [], o = new at(this); t: for (let t = 0, e = 0; ;) { for (var a = t == i.length ? 1e9 : i[t++]; e < a || e == a && 0 == o.len;) { if (o.done) break t; var l = Math.min(o.len, a - e), h = (u(s, l, -1), -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0); u(r, l, h), 0 < h && rt(n, r, o.text), o.forward(l), e += l } for (var c = i[t++]; e < c;) { if (o.done) break t; var d = Math.min(o.len, c - e); u(r, d, -1), u(s, d, -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0), o.forward(d), e += d } } return { changes: new yf(r, n), filtered: et.create(s) } } toJSON() { var e = []; for (let t = 0; t < this.sections.length; t += 2) { var i = this.sections[t], r = this.sections[t + 1]; e.push(r < 0 ? i : 0 == r ? [i] : [i].concat(this.inserted[t >> 1].toJSON())) } return e } static of(t, o, a) { let l = [], h = [], c = 0, d = null; function O(t = !1) { (t || l.length) && (c < o && u(l, o - c, -1), t = new yf(l, h), d = d ? d.compose(t.map(d)) : t, l = [], h = [], c = 0) } return function t(e) { if (Array.isArray(e)) for (var i of e) t(i); else if (e instanceof yf) { if (e.length != o) throw new RangeError(`Mismatched change set length (got ${e.length}, expected ${o})`); O(), d = d ? d.compose(e.map(d)) : e } else { var { from: e, to: r = e, insert: n } = e; if (r < e || e < 0 || o < r) throw new RangeError(`Invalid change range ${e} to ${r} (in doc of length ${o})`); var s = (n = n ? "string" == typeof n ? m.of(n.split(a || tt)) : n : m.empty).length; e == r && 0 == s || (e < c && O(), e > c && u(l, e - c, -1), u(l, r - e, s), rt(h, l, n), c = r) } }(t), O(!d), d } static empty(t) { return new yf(t ? [t, -1] : [], []) } static fromJSON(e) { if (!Array.isArray(e)) throw new RangeError("Invalid JSON representation of ChangeSet"); var i = [], r = []; for (let t = 0; t < e.length; t++) { var n = e[t]; if ("number" == typeof n) i.push(n, -1); else { if (!Array.isArray(n) || "number" != typeof n[0] || n.some((t, e) => e && "string" != typeof t)) throw new RangeError("Invalid JSON representation of ChangeSet"); if (1 == n.length) i.push(n[0], 0); else { for (; r.length < t;)r.push(m.empty); r[t] = m.of(n.slice(1)), i.push(n[0], r[t].length) } } } return new yf(i, r) } static createSet(t, e) { return new yf(t, e) } }; function u(t, e, i, r = !1) { var n; 0 == e && i <= 0 || (0 <= (n = t.length - 2) && i <= 0 && i == t[1 + n] ? t[n] += e : 0 == e && 0 == t[n] ? t[1 + n] += i : r ? (t[n] += e, t[1 + n] += i) : t.push(e, i)) } function rt(t, e, i) { if (0 != i.length) { var r = e.length - 2 >> 1; if (r < t.length) t[t.length - 1] = t[t.length - 1].append(i); else { for (; t.length < r;)t.push(m.empty); t.push(i) } } } function nt(l, h, c) { var d = l.inserted; for (let s = 0, o = 0, a = 0; a < l.sections.length;) { let r = l.sections[a++], n = l.sections[a++]; if (n < 0) s += r, o += r; else { let t = s, e = o, i = m.empty; for (; t += r, e += n, n && d && (i = i.append(d[a - 2 >> 1])), !(c || a == l.sections.length || l.sections[a + 1] < 0);)r = l.sections[a++], n = l.sections[a++]; h(s, t, o, e, i), s = t, o = e } } } function st(t, e, r, i = !1) { var n = [], s = i ? [] : null, o = new at(t), a = new at(e); for (let i = -1; ;)if (-1 == o.ins && -1 == a.ins) { var l = Math.min(o.len, a.len); u(n, l, -1), o.forward(l), a.forward(l) } else if (0 <= a.ins && (o.ins < 0 || i == o.i || 0 == o.off && (a.len < o.len || a.len == o.len && !r))) { let t = a.len; for (u(n, a.ins, -1); t;) { var h = Math.min(o.len, t); 0 <= o.ins && i < o.i && o.len <= h && (u(n, 0, o.ins), s && rt(s, n, o.text), i = o.i), o.forward(h), t -= h } a.next() } else { if (!(0 <= o.ins)) { if (o.done && a.done) return s ? it.createSet(n, s) : et.create(n); throw new Error("Mismatched change set lengths") } { let t = 0, e = o.len; for (; e;)if (-1 == a.ins) { var c = Math.min(e, a.len); t += c, e -= c, a.forward(c) } else { if (!(0 == a.ins && a.len < e)) break; e -= a.len, a.next() } u(n, t, i < o.i ? o.ins : 0), s && i < o.i && rt(s, n, o.text), i = o.i, o.forward(o.len - e) } } } function ot(t, e, i = !1) { var r = [], n = i ? [] : null, s = new at(t), o = new at(e); for (let t = !1; ;) { if (s.done && o.done) return n ? it.createSet(r, n) : et.create(r); if (0 == s.ins) u(r, s.len, 0, t), s.next(); else if (0 != o.len || o.done) { if (s.done || o.done) throw new Error("Mismatched change set lengths"); var a, l = Math.min(s.len2, o.len), h = r.length; -1 == s.ins ? (u(r, l, a = -1 == o.ins ? -1 : o.off ? 0 : o.ins, t), n && a && rt(n, r, o.text)) : -1 == o.ins ? (u(r, s.off ? 0 : s.len, l, t), n && rt(n, r, s.textBit(l))) : (u(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, t), n && !o.off && rt(n, r, o.text)), t = (s.ins > l || 0 <= o.ins && o.len > l) && (t || h < r.length), s.forward2(l), o.forward(l) } else u(r, 0, o.ins, t), n && rt(n, r, o.text), o.next() } } var at = class { constructor(t) { this.set = t, this.i = 0, this.next() } next() { var t = this.set.sections; this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0 } get done() { return -2 == this.ins } get len2() { return this.ins < 0 ? this.len : this.ins } get text() { var t = this.set.inserted, e = this.i - 2 >> 1; return e >= t.length ? m.empty : t[e] } textBit(t) { var e = this.set.inserted, i = this.i - 2 >> 1; return i >= e.length && !t ? m.empty : e[i].slice(this.off, null == t ? void 0 : this.off + t) } forward(t) { t == this.len ? this.next() : (this.len -= t, this.off += t) } forward2(t) { -1 == this.ins ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t) } }, lt = class Sf { constructor(t, e, i) { this.from = t, this.to = e, this.flags = i } get anchor() { return 32 & this.flags ? this.to : this.from } get head() { return 32 & this.flags ? this.from : this.to } get empty() { return this.from == this.to } get assoc() { return 8 & this.flags ? -1 : 16 & this.flags ? 1 : 0 } get bidiLevel() { var t = 7 & this.flags; return 7 == t ? null : t } get goalColumn() { var t = this.flags >> 6; return 16777215 == t ? void 0 : t } map(t, e = -1) { let i, r; return this.empty ? i = r = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), r = t.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new Sf(i, r, this.flags) } extend(t, e = t) { return t <= this.anchor && e >= this.anchor ? g.range(t, e) : (e = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e, g.range(this.anchor, e)) } eq(t, e = !1) { return !(this.anchor != t.anchor || this.head != t.head || e && this.empty && this.assoc != t.assoc) } toJSON() { return { anchor: this.anchor, head: this.head } } static fromJSON(t) { if (t && "number" == typeof t.anchor && "number" == typeof t.head) return g.range(t.anchor, t.head); throw new RangeError("Invalid JSON representation for SelectionRange") } static create(t, e, i) { return new Sf(t, e, i) } }, g = class Qf { constructor(t, e) { this.ranges = t, this.mainIndex = e } map(e, i = -1) { return e.empty ? this : Qf.create(this.ranges.map(t => t.map(e, i)), this.mainIndex) } eq(e, i = !1) { if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1; for (let t = 0; t < this.ranges.length; t++)if (!this.ranges[t].eq(e.ranges[t], i)) return !1; return !0 } get main() { return this.ranges[this.mainIndex] } asSingle() { return 1 == this.ranges.length ? this : new Qf([this.main], 0) } addRange(t, e = !0) { return Qf.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1) } replaceRange(t, e = this.mainIndex) { var i = this.ranges.slice(); return i[e] = t, Qf.create(i, this.mainIndex) } toJSON() { return { ranges: this.ranges.map(t => t.toJSON()), main: this.mainIndex } } static fromJSON(t) { if (!t || !Array.isArray(t.ranges) || "number" != typeof t.main || t.main >= t.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection"); return new Qf(t.ranges.map(t => lt.fromJSON(t)), t.main) } static single(t, e = t) { return new Qf([Qf.range(t, e)], 0) } static create(i, r = 0) { if (0 == i.length) throw new RangeError("A selection needs at least one range"); for (let t = 0, e = 0; e < i.length; e++) { var n = i[e]; if (n.empty ? n.from <= t : n.from < t) return Qf.normalized(i.slice(), r); t = n.to } return new Qf(i, r) } static cursor(t, e = 0, i, r) { return lt.create(t, t, (0 == e ? 0 : e < 0 ? 8 : 16) | (null == i ? 7 : Math.min(6, i)) | (null != r ? r : 16777215) << 6) } static range(t, e, i, r) { i = (null != i ? i : 16777215) << 6 | (null == r ? 7 : Math.min(6, r)); return e < t ? lt.create(e, t, 48 | i) : lt.create(t, e, (t < e ? 8 : 0) | i) } static normalized(e, i = 0) { var t = e[i]; e.sort((t, e) => t.from - e.from), i = e.indexOf(t); for (let t = 1; t < e.length; t++) { var r, n = e[t], s = e[t - 1]; (n.empty ? n.from <= s.to : n.from < s.to) && (r = s.from, s = Math.max(n.to, s.to), t <= i && i--, e.splice(--t, 2, n.anchor > n.head ? Qf.range(s, r) : Qf.range(r, s))) } return new Qf(e, i) } }; function ht(t, e) { for (var i of t.ranges) if (i.to > e) throw new RangeError("Selection points outside of document") } var ct = 0, d = class xf { constructor(t, e, i, r, n) { this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = r, this.id = ct++, this.default = t([]), this.extensions = "function" == typeof n ? n(this) : n } get reader() { return this } static define(t = {}) { return new xf(t.combine || (t => t), t.compareInput || ((t, e) => t === e), t.compare || (t.combine ? (t, e) => t === e : dt), !!t.static, t.enables) } of(t) { return new Ot([], this, 0, t) } compute(t, e) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new Ot(t, this, 1, e) } computeN(t, e) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new Ot(t, this, 2, e) } from(e, i) { return i = i || (t => t), this.compute([e], t => i(t.field(e))) } }; function dt(t, i) { return t == i || t.length == i.length && t.every((t, e) => t === i[e]) } var Ot = class { constructor(t, e, i, r) { this.dependencies = t, this.facet = e, this.type = i, this.value = r, this.id = ct++ } dynamicSlot(t) { let e, s = this.value, o = this.facet.compareInput, a = this.id, l = t[a] >> 1, h = 2 == this.type, i = !1, r = !1, n = []; for (var c of this.dependencies) "doc" == c ? i = !0 : "selection" == c ? r = !0 : 0 == (1 & (null != (e = t[c.id]) ? e : 1)) && n.push(t[c.id]); return { create(t) { return t.values[l] = s(t), 1 }, update(t, e) { if (i && e.docChanged || r && (e.docChanged || e.selection) || ft(t, n)) { e = s(t); if (h ? !ut(e, t.values[l], o) : !o(e, t.values[l])) return t.values[l] = e, 1 } return 0 }, reconfigure: (e, i) => { let t, r = i.config.address[a]; if (null != r) { var n = xt(i, r); if (this.dependencies.every(t => t instanceof d ? i.facet(t) === e.facet(t) : !(t instanceof f) || i.field(t, !1) == e.field(t, !1)) || (h ? ut(t = s(e), n, o) : o(t = s(e), n))) return e.values[l] = n, 0 } else t = s(e); return e.values[l] = t, 1 } } } }; function ut(e, i, r) { if (e.length == i.length) { for (let t = 0; t < e.length; t++)if (!r(e[t], i[t])) return; return 1 } } function ft(t, e) { let i = !1; for (var r of e) 1 & Qt(t, r) && (i = !0); return i } var pt = d.define({ static: !0 }), f = class kf { constructor(t, e, i, r, n) { this.id = t, this.createF = e, this.updateF = i, this.compareF = r, this.spec = n, this.provides = void 0 } static define(t) { var e = new kf(ct++, t.create, t.update, t.compare || ((t, e) => t === e), t); return t.provide && (e.provides = t.provide(e)), e } create(t) { var e = t.facet(pt).find(t => t.field == this); return ((null == e ? void 0 : e.create) || this.createF)(t) } slot(t) { let r = t[this.id] >> 1; return { create: t => (t.values[r] = this.create(t), 1), update: (t, e) => { var i = t.values[r], e = this.updateF(i, e); return this.compareF(i, e) ? 0 : (t.values[r] = e, 1) }, reconfigure: (t, e) => null != e.config.address[this.id] ? (t.values[r] = e.field(this), 0) : (t.values[r] = this.create(t), 1) } } init(t) { return [this, pt.of({ field: this, create: t })] } get extension() { return this } }, mt = 2; function gt(e) { return t => new wt(t, e) } var vt = { highest: gt(0), high: gt(1), default: gt(mt), low: gt(3), lowest: gt(4) }, wt = class { constructor(t, e) { this.inner = t, this.prec = e } }, bt = class $f { of(t) { return new yt(this, t) } reconfigure(t) { return $f.reconfigure.of({ compartment: this, extension: t }) } get(t) { return t.config.compartments.get(this) } }, yt = class { constructor(t, e) { this.compartment = t, this.inner = e } }, St = class Pf { constructor(t, e, i, r, n, s) { for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = r, this.staticValues = n, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < i.length;)this.statusTemplate.push(0) } staticFacet(t) { var e = this.address[t.id]; return null == e ? t.default : this.staticValues[e >> 1] } static resolve(t, e, r) { var i, n = [], s = Object.create(null), o = new Map; for (i of ((t, o, a) => { let l = [[], [], [], [], []], h = new Map; return function t(e, i) { var r = h.get(e); if (null != r) { if (r <= i) return; var n = l[r].indexOf(e); -1 < n && l[r].splice(n, 1), e instanceof yt && a.delete(e.compartment) } if (h.set(e, i), Array.isArray(e)) for (var s of e) t(s, i); else if (e instanceof yt) { if (a.has(e.compartment)) throw new RangeError("Duplicate use of compartment in extensions"); r = o.get(e.compartment) || e.inner, a.set(e.compartment, r), t(r, i) } else if (e instanceof wt) t(e.inner, e.prec); else if (e instanceof f) l[i].push(e), e.provides && t(e.provides, i); else if (e instanceof Ot) l[i].push(e), e.facet.extensions && t(e.facet.extensions, mt); else { if (!(n = e.extension)) throw new Error(`Unrecognized extension value in extension set (${e}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`); t(n, i) } }(t, mt), l.reduce((t, e) => t.concat(e)) })(t, e, o)) (i instanceof f ? n : s[i.facet.id] || (s[i.facet.id] = [])).push(i); let a = Object.create(null); var l = [], h = []; for (let e of n) a[e.id] = h.length << 1, h.push(t => e.slot(t)); var d, O = null == r ? void 0 : r.config.facets; for (d in s) { let i = s[d], c = i[0].facet; var u = O && O[d] || []; if (i.every(t => 0 == t.type)) a[c.id] = l.length << 1 | 1, dt(u, i) ? l.push(r.facet(c)) : (u = c.combine(i.map(t => t.value)), l.push(r && c.compare(u, r.facet(c)) ? r.facet(c) : u)); else { for (let e of i) 0 == e.type ? (a[e.id] = l.length << 1 | 1, l.push(e.value)) : (a[e.id] = h.length << 1, h.push(t => e.dynamicSlot(t))); a[c.id] = h.length << 1, h.push(t => { { var e = t, a = c, l = i; let s = l.map(t => e[t.id]), o = l.map(t => t.type), r = s.filter(t => !(1 & t)), n = e[a.id] >> 1; function h(e) { var i = []; for (let t = 0; t < s.length; t++) { var r = xt(e, s[t]); if (2 == o[t]) for (var n of r) i.push(n); else i.push(r) } return a.combine(i) } return { create(t) { for (var e of s) Qt(t, e); return t.values[n] = h(t), 1 }, update(t, e) { var i; return !ft(t, r) || (i = h(t), a.compare(i, t.values[n])) ? 0 : (t.values[n] = i, 1) }, reconfigure(t, e) { var i = ft(t, s), r = e.config.facets[a.id], e = e.facet(a); return r && !i && dt(l, r) || (i = h(t), a.compare(i, e)) ? (t.values[n] = e, 0) : (t.values[n] = i, 1) } } } }) } } e = h.map(t => t(a)); return new Pf(t, o, e, a, l, s) } }; function Qt(t, e) { if (1 & e) return 2; var e = e >> 1, i = t.status[e]; if (4 == i) throw new Error("Cyclic dependency between fields and/or facets"); if (2 & i) return i; t.status[e] = 4; i = t.computeSlot(t, t.config.dynamicSlots[e]); return t.status[e] = 2 | i } function xt(t, e) { return (1 & e ? t.config.staticValues : t.values)[e >> 1] } var kt = d.define(), $t = d.define({ combine: t => t.some(t => t), static: !0 }), Pt = d.define({ combine: t => t.length ? t[0] : void 0, static: !0 }), Zt = d.define(), Tt = d.define(), Ct = d.define(), Xt = d.define({ combine: t => !!t.length && t[0] }), At = class { constructor(t, e) { this.type = t, this.value = e } static define() { return new Rt } }, Rt = class { of(t) { return new At(this, t) } }, Yt = class { constructor(t) { this.map = t } of(t) { return new c(this, t) } }, c = class Zf { constructor(t, e) { this.type = t, this.value = e } map(t) { t = this.type.map(this.value, t); return void 0 === t ? void 0 : t == this.value ? this : new Zf(this.type, t) } is(t) { return this.type == t } static define(t = {}) { return new Yt(t.map || (t => t)) } static mapEffects(t, e) { if (!t.length) return t; var i, r = []; for (i of t) { var n = i.map(e); n && r.push(n) } return r } }, Wt = (c.reconfigure = c.define(), c.appendConfig = c.define(), class Tf { constructor(t, e, i, r, n, s) { this.startState = t, this.changes = e, this.selection = i, this.effects = r, this.annotations = n, this.scrollIntoView = s, this._doc = null, this._state = null, i && ht(i, e.newLength), n.some(t => t.type == Tf.time) || (this.annotations = n.concat(Tf.time.of(Date.now()))) } static create(t, e, i, r, n, s) { return new Tf(t, e, i, r, n, s) } get newDoc() { return this._doc || (this._doc = this.changes.apply(this.startState.doc)) } get newSelection() { return this.selection || this.startState.selection.map(this.changes) } get state() { return this._state || this.startState.applyTransaction(this), this._state } annotation(t) { for (var e of this.annotations) if (e.type == t) return e.value } get docChanged() { return !this.changes.empty } get reconfigured() { return this.startState.config != this.state.config } isUserEvent(t) { var e = this.annotation(Tf.userEvent); return !(!e || !(e == t || e.length > t.length && e.slice(0, t.length) == t && "." == e[t.length])) } }); function Vt(t, e, i) { let r, n, s, o; return { changes: o = i ? (n = e.changes, s = it.empty(e.changes.length), t.changes.compose(e.changes)) : (n = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), t.changes.compose(n)), selection: e.selection ? e.selection.map(s) : null == (r = t.selection) ? void 0 : r.map(n), effects: c.mapEffects(t.effects, n).concat(c.mapEffects(e.effects, s)), annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations, scrollIntoView: t.scrollIntoView || e.scrollIntoView } } function Mt(t, e, i) { let r = e.selection, n = jt(e.annotations); return e.userEvent && (n = n.concat(Wt.userEvent.of(e.userEvent))), { changes: e.changes instanceof it ? e.changes : it.of(e.changes || [], i, t.facet(Pt)), selection: r && (r instanceof g ? r : g.single(r.anchor, r.head)), effects: jt(e.effects), annotations: n, scrollIntoView: !!e.scrollIntoView } } function qt(e, i, n) { let r = Mt(e, i.length ? i[0] : {}, e.doc.length); i.length && !1 === i[0].filter && (n = !1); for (let t = 1; t < i.length; t++) { !1 === i[t].filter && (n = !1); var s = !!i[t].sequential; r = Vt(r, Mt(e, i[t], s ? r.changes.newLength : e.doc.length), s) } var t = Wt.create(e, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView); { var o = n ? (i => { let r = i.startState, n = !0; for (var t of r.facet(Zt)) { t = t(i); if (!1 === t) { n = !1; break } Array.isArray(t) && (n = !0 === n ? t : ((n, s) => { var o = []; for (let i = 0, r = 0; ;) { let t, e; if (i < n.length && (r == s.length || s[r] >= n[i])) t = n[i++], e = n[i++]; else { if (!(r < s.length)) return o; t = s[r++], e = s[r++] } !o.length || o[o.length - 1] < t ? o.push(t, e) : o[o.length - 1] < e && (o[o.length - 1] = e) } })(n, t)) } if (!0 !== n) { let t, e; var s; !1 === n ? (e = i.changes.invertedDesc, t = it.empty(r.doc.length)) : (s = i.changes.filter(n), t = s.changes, e = s.filtered.mapDesc(s.changes).invertedDesc), i = Wt.create(r, t, i.selection && i.selection.map(e), c.mapEffects(i.effects, e), i.annotations, i.scrollIntoView) } var e = r.facet(Tt); for (let t = e.length - 1; 0 <= t; t--) { var o = e[t](i); i = o instanceof Wt ? o : Array.isArray(o) && 1 == o.length && o[0] instanceof Wt ? o[0] : qt(r, jt(o), !1) } return i })(t) : t; let e = o.startState, i = e.facet(Ct), r = o; for (let t = i.length - 1; 0 <= t; t--) { var a = i[t](o); a && Object.keys(a).length && (r = Vt(r, Mt(e, a, o.changes.newLength), !0)) } return r == o ? o : Wt.create(e, o.changes, o.selection, r.effects, r.annotations, r.scrollIntoView) } } Wt.time = At.define(), Wt.userEvent = At.define(), Wt.addToHistory = At.define(), Wt.remote = At.define(); var _t = []; function jt(t) { return null == t ? _t : Array.isArray(t) ? t : [t] } var Et, p = (t => (t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t))(p = p || {}), Dt = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; try { Et = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u") } catch (t) { } function zt(i) { return e => { if (!/\S/.test(e)) return p.Space; if ((e => { if (Et) return Et.test(e); for (let t = 0; t < e.length; t++) { var i = e[t]; if (/\w/.test(i) || "Â€" < i && (i.toUpperCase() != i.toLowerCase() || Dt.test(i))) return 1 } })(e)) return p.Word; for (let t = 0; t < i.length; t++)if (-1 < e.indexOf(i[t])) return p.Word; return p.Other } } var v = class Cf { constructor(t, e, i, r, n, s) { this.config = t, this.doc = e, this.selection = i, this.values = r, this.status = t.statusTemplate.slice(), this.computeSlot = n, s && (s._state = this); for (let t = 0; t < this.config.dynamicSlots.length; t++)Qt(this, t << 1); this.computeSlot = null } field(t, e = !0) { t = this.config.address[t.id]; if (null != t) return Qt(this, t), xt(this, t); if (e) throw new RangeError("Field is not present in this state") } update(...t) { return qt(this, t, !0) } applyTransaction(i) { let t = this.config, { base: e, compartments: r } = t; for (var n of i.effects) n.is(bt.reconfigure) ? (t && (r = new Map, t.compartments.forEach((t, e) => r.set(e, t)), t = null), r.set(n.value.compartment, n.value.extension)) : n.is(c.reconfigure) ? (t = null, e = n.value) : n.is(c.appendConfig) && (t = null, e = jt(e).concat(n.value)); let s; s = t ? i.startState.values.slice() : (t = St.resolve(e, r, this), new Cf(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (t, e) => e.reconfigure(t, this), null).values); var o = i.startState.facet($t) ? i.newSelection : i.newSelection.asSingle(); new Cf(t, i.newDoc, o, s, (t, e) => e.update(t, i), i) } replaceSelection(e) { return "string" == typeof e && (e = this.toText(e)), this.changeByRange(t => ({ changes: { from: t.from, to: t.to, insert: e }, range: g.cursor(t.from + e.length) })) } changeByRange(t) { var i = this.selection, e = t(i.ranges[0]); let r = this.changes(e.changes), n = [e.range], s = jt(e.effects); for (let e = 1; e < i.ranges.length; e++) { var o = t(i.ranges[e]), a = this.changes(o.changes), l = a.map(r); for (let t = 0; t < e; t++)n[t] = n[t].map(l); a = r.mapDesc(a, !0); n.push(o.range.map(a)), r = r.compose(l), s = c.mapEffects(s, l).concat(c.mapEffects(jt(o.effects), a)) } return { changes: r, selection: g.create(n, i.mainIndex), effects: s } } changes(t = []) { return t instanceof it ? t : it.of(t, this.doc.length, this.facet(Cf.lineSeparator)) } toText(t) { return m.of(t.split(this.facet(Cf.lineSeparator) || tt)) } sliceDoc(t = 0, e = this.doc.length) { return this.doc.sliceString(t, e, this.lineBreak) } facet(t) { var e = this.config.address[t.id]; return null == e ? t.default : (Qt(this, e), xt(this, e)) } toJSON(t) { var e = { doc: this.sliceDoc(), selection: this.selection.toJSON() }; if (t) for (var i in t) { var r = t[i]; r instanceof f && null != this.config.address[r.id] && (e[i] = r.spec.toJSON(this.field(t[i]), this)) } return e } static fromJSON(t, e = {}, r) { if (!t || "string" != typeof t.doc) throw new RangeError("Invalid JSON representation for EditorState"); var n = []; if (r) for (var s in r) if (Object.prototype.hasOwnProperty.call(t, s)) { let e = r[s], i = t[s]; n.push(e.init(t => e.spec.fromJSON(i, t))) } return Cf.create({ doc: t.doc, selection: g.fromJSON(t.selection), extensions: e.extensions ? n.concat([e.extensions]) : n }) } static create(t = {}) { var e = St.resolve(t.extensions || [], new Map), i = t.doc instanceof m ? t.doc : m.of((t.doc || "").split(e.staticFacet(Cf.lineSeparator) || tt)); let r = t.selection ? t.selection instanceof g ? t.selection : g.single(t.selection.anchor, t.selection.head) : g.single(0); return ht(r, i.length), e.staticFacet($t) || (r = r.asSingle()), new Cf(e, i, r, e.dynamicSlots.map(() => null), (t, e) => e.create(t), null) } get tabSize() { return this.facet(Cf.tabSize) } get lineBreak() { return this.facet(Cf.lineSeparator) || "\n" } get readOnly() { return this.facet(Xt) } phrase(t, ...i) { for (var e of this.facet(Cf.phrases)) if (Object.prototype.hasOwnProperty.call(e, t)) { t = e[t]; break } return t = i.length ? t.replace(/\$(\$|\d*)/g, (t, e) => "$" == e ? "$" : !(e = +(e || 1)) || e > i.length ? t : i[e - 1]) : t } languageDataAt(t, e, i = -1) { var r, n = []; for (r of this.facet(kt)) for (var s of r(this, e, i)) Object.prototype.hasOwnProperty.call(s, t) && n.push(s[t]); return n } charCategorizer(t) { return zt(this.languageDataAt("wordChars", t).join("")) } wordAt(t) { var { text: e, from: i, length: r } = this.doc.lineAt(t), n = this.charCategorizer(t); let s = t - i, o = t - i; for (; 0 < s;) { var a = O(e, s, !1); if (n(e.slice(a, s)) != p.Word) break; s = a } for (; o < r;) { var l = O(e, o); if (n(e.slice(o, l)) != p.Word) break; o = l } return s == o ? null : g.range(s + i, o + i) } }; function Bt(t, e, i = {}) { var r, n, s = {}; for (r of t) for (var o of Object.keys(r)) { var a = r[o], l = s[o]; if (void 0 === l) s[o] = a; else if (l !== a && void 0 !== a) { if (!Object.hasOwnProperty.call(i, o)) throw new Error("Config merge conflict for field " + o); s[o] = i[o](l, a) } } for (n in e) void 0 === s[n] && (s[n] = e[n]); return s } v.allowMultipleSelections = $t, v.tabSize = d.define({ combine: t => t.length ? t[0] : 4 }), v.lineSeparator = Pt, v.readOnly = Xt, v.phrases = d.define({ compare(e, i) { var t = Object.keys(e), r = Object.keys(i); return t.length == r.length && t.every(t => e[t] == i[t]) } }), v.languageData = kt, v.changeFilter = Zt, v.transactionFilter = Tt, v.transactionExtender = Ct, bt.reconfigure = c.define(); var Gt = class { eq(t) { return this == t } range(t, e = t) { return It.create(t, e, this) } }, It = (Gt.prototype.startSide = Gt.prototype.endSide = 0, Gt.prototype.point = !1, Gt.prototype.mapMode = h.TrackDel, class Xf { constructor(t, e, i) { this.from = t, this.to = e, this.value = i } static create(t, e, i) { return new Xf(t, e, i) } }); function Nt(t, e) { return t.from - e.from || t.value.startSide - e.value.startSide } var Ut = class Af { constructor(t, e, i, r) { this.from = t, this.to = e, this.value = i, this.maxPoint = r } get length() { return this.to[this.to.length - 1] } findIndex(i, r, n, s = 0) { var o = n ? this.to : this.from; for (let t = s, e = o.length; ;) { if (t == e) return t; var a = t + e >> 1, l = o[a] - i || (n ? this.value[a].endSide : this.value[a].startSide) - r; if (a == t) return 0 <= l ? t : e; 0 <= l ? e = a : t = 1 + a } } between(i, r, n, s) { for (let t = this.findIndex(r, -1e9, !0), e = this.findIndex(n, 1e9, !1, t); t < e; t++)if (!1 === s(this.from[t] + i, this.to[t] + i, this.value[t])) return !1 } map(o, a) { let l = [], h = [], c = [], d = -1, O = -1; for (let s = 0; s < this.value.length; s++) { let t = this.value[s], e = this.from[s] + o, i = this.to[s] + o, r, n; if (e == i) { var u = a.mapPos(e, t.startSide, t.mapMode); if (null == u) continue; if (r = n = u, t.startSide != t.endSide && (n = a.mapPos(e, t.endSide)) < r) continue } else if (r = a.mapPos(e, t.startSide), n = a.mapPos(i, t.endSide), r > n || r == n && 0 < t.startSide && t.endSide <= 0) continue; (n - r || t.endSide - t.startSide) < 0 || (d < 0 && (d = r), t.point && (O = Math.max(O, n - r)), l.push(t), h.push(r - d), c.push(n - d)) } return { mapped: l.length ? new Af(h, c, l, O) : null, pos: d } } }, w = class Rf { constructor(t, e, i, r) { this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = r } static create(t, e, i, r) { return new Rf(t, e, i, r) } get length() { var t = this.chunk.length - 1; return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length) } get size() { if (this.isEmpty) return 0; let t = this.nextLayer.size; for (var e of this.chunk) t += e.value.length; return t } chunkEnd(t) { return this.chunkPos[t] + this.chunk[t].length } update(t) { let { add: e = [], sort: i = !1, filterFrom: r = 0, filterTo: n = this.length } = t; var s = t.filter; if (0 == e.length && !s) return this; if (i && (e = e.slice().sort(Nt)), this.isEmpty) return e.length ? Rf.of(e) : this; let o = new Ht(this, null, -1).goto(0), a = 0, l = []; for (var h, c = new Lt; o.value || a < e.length;)a < e.length && 0 <= (o.from - e[a].from || o.startSide - e[a].value.startSide) ? (h = e[a++], c.addInner(h.from, h.to, h.value) || l.push(h)) : 1 == o.rangeIndex && o.chunkIndex < this.chunk.length && (a == e.length || this.chunkEnd(o.chunkIndex) < e[a].from) && (!s || r > this.chunkEnd(o.chunkIndex) || n < this.chunkPos[o.chunkIndex]) && c.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!s || r > o.to || n < o.from || s(o.from, o.to, o.value)) && !c.addInner(o.from, o.to, o.value) && l.push(It.create(o.from, o.to, o.value)), o.next()); return c.finishInner(this.nextLayer.isEmpty && !l.length ? Rf.empty : this.nextLayer.update({ add: l, filter: s, filterFrom: r, filterTo: n })) } map(e) { if (e.empty || this.isEmpty) return this; let i = [], r = [], n = -1; for (let t = 0; t < this.chunk.length; t++) { var s = this.chunkPos[t], o = this.chunk[t], a = e.touchesRange(s, s + o.length); !1 === a ? (n = Math.max(n, o.maxPoint), i.push(o), r.push(e.mapPos(s))) : !0 === a && ({ mapped: a, pos: o } = o.map(s, e), a) && (n = Math.max(n, a.maxPoint), i.push(a), r.push(o)) } var t = this.nextLayer.map(e); return 0 == i.length ? t : new Rf(r, i, t || Rf.empty, n) } between(e, i, r) { if (!this.isEmpty) { for (let t = 0; t < this.chunk.length; t++) { var n = this.chunkPos[t], s = this.chunk[t]; if (n <= i && e <= n + s.length && !1 === s.between(n, e - n, i - n, r)) return } this.nextLayer.between(e, i, r) } } iter(t = 0) { return Jt.from([this]).goto(t) } get isEmpty() { return this.nextLayer == this } static iter(t, e = 0) { return Jt.from(t).goto(e) } static compare(t, e, i, r, n = -1) { var t = t.filter(t => 0 < t.maxPoint || !t.isEmpty && t.maxPoint >= n), e = e.filter(t => 0 < t.maxPoint || !t.isEmpty && t.maxPoint >= n), s = Ft(t, e, i); let o = new te(t, s, n), a = new te(e, s, n); i.iterGaps((t, e, i) => ee(o, t, a, e, i, r)), i.empty && 0 == i.length && ee(o, 0, a, 0, 0, r) } static eq(e, i, t = 0, r) { null == r && (r = 1e9 - 1); var n = e.filter(t => !t.isEmpty && i.indexOf(t) < 0), s = i.filter(t => !t.isEmpty && e.indexOf(t) < 0); if (n.length != s.length) return !1; if (!n.length) return !0; for (var o = Ft(n, s), a = new te(n, o, 0).goto(t), l = new te(s, o, 0).goto(t); ;) { if (a.to != l.to || !ie(a.active, l.active) || a.point && (!l.point || !a.point.eq(l.point))) return !1; if (a.to > r) return !0; a.next(), l.next() } } static spans(t, e, i, r, n = -1) { let s = new te(t, null, n).goto(e), o = e, a = s.openStart; for (; ;) { var l, h, c = Math.min(s.to, i); if (s.point ? (l = s.activeForPoint(s.to), h = s.pointFrom < e ? l.length + 1 : Math.min(l.length, a), r.point(o, c, s.point, l, h, s.pointRank), a = Math.min(s.openEnd(c), l.length)) : c > o && (r.span(o, c, s.active, a), a = s.openEnd(c)), s.to > i) return a + (s.point && s.to > i ? 1 : 0); o = s.to, s.next() } } static of(t, e = !1) { var i, r = new Lt; for (i of t instanceof It ? [t] : e ? (i => { if (1 < i.length) for (let t = i[0], e = 1; e < i.length; e++) { var r = i[e]; if (0 < Nt(t, r)) return i.slice().sort(Nt); t = r } return i })(t) : t) r.add(i.from, i.to, i.value); return r.finish() } static join(i) { if (!i.length) return Rf.empty; let r = i[i.length - 1]; for (let e = i.length - 2; 0 <= e; e--)for (let t = i[e]; t != Rf.empty; t = t.nextLayer)r = new Rf(t.chunkPos, t.chunk, r, Math.max(t.maxPoint, r.maxPoint)); return r } }; (w.empty = new w([], [], null, -1)).nextLayer = w.empty; var Lt = class Yf { finishChunk(t) { this.chunks.push(new Ut(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []) } constructor() { this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null } add(t, e, i) { this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new Yf)).add(t, e, i) } addInner(t, e, i) { var r = t - this.lastTo || i.startSide - this.last.endSide; if (r <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`"); return !(r < 0 || (250 == this.from.length && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), 0)) } addChunk(t, e) { if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0) return !1; this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t); var i = e.value.length - 1; return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0 } finish() { return this.finishInner(w.empty) } finishInner(t) { return this.from.length && this.finishChunk(!1), 0 == this.chunks.length || (t = w.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint), this.from = null), t } }; function Ft(t, e, i) { var r, n = new Map; for (r of t) for (let t = 0; t < r.chunk.length; t++)r.chunk[t].maxPoint <= 0 && n.set(r.chunk[t], r.chunkPos[t]); var s, o = new Set; for (s of e) for (let t = 0; t < s.chunk.length; t++) { var a = n.get(s.chunk[t]); null == a || (i ? i.mapPos(a) : a) != s.chunkPos[t] || null != i && i.touchesRange(a, a + s.chunk[t].length) || o.add(s.chunk[t]) } return o } var Ht = class { constructor(t, e, i, r = 0) { this.layer = t, this.skip = e, this.minPoint = i, this.rank = r } get startSide() { return this.value ? this.value.startSide : 0 } get endSide() { return this.value ? this.value.endSide : 0 } goto(t, e = -1e9) { return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this } gotoInner(t, e, i) { for (; this.chunkIndex < this.layer.chunk.length;) { var r = this.layer.chunk[this.chunkIndex]; if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < t || r.maxPoint < this.minPoint)) break; this.chunkIndex++, i = !1 } this.chunkIndex < this.layer.chunk.length && (e = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0), !i || this.rangeIndex < e) && this.setRangeIndex(e), this.next() } forward(t, e) { (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0) } next() { for (; ;) { if (this.chunkIndex == this.layer.chunk.length) { this.from = this.to = 1e9, this.value = null; break } var t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex]; if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break } } setRangeIndex(t) { if (t == this.layer.chunk[this.chunkIndex].value.length) { if (this.chunkIndex++, this.skip) for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++; this.rangeIndex = 0 } else this.rangeIndex = t } nextChunk() { this.chunkIndex++, this.rangeIndex = 0, this.next() } compare(t) { return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide } }, Jt = class Wf { constructor(t) { this.heap = t } static from(i, r = null, n = -1) { var s = []; for (let e = 0; e < i.length; e++)for (let t = i[e]; !t.isEmpty; t = t.nextLayer)t.maxPoint >= n && s.push(new Ht(t, r, n, e)); return 1 == s.length ? s[0] : new Wf(s) } get startSide() { return this.value ? this.value.startSide : 0 } goto(t, e = -1e9) { for (var i of this.heap) i.goto(t, e); for (let t = this.heap.length >> 1; 0 <= t; t--)Kt(this.heap, t); return this.next(), this } forward(t, e) { for (var i of this.heap) i.forward(t, e); for (let t = this.heap.length >> 1; 0 <= t; t--)Kt(this.heap, t); (this.to - t || this.value.endSide - e) < 0 && this.next() } next() { var t; 0 == this.heap.length ? (this.from = this.to = 1e9, this.value = null, this.rank = -1) : (t = this.heap[0], this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), Kt(this.heap, 0)) } }; function Kt(i, r) { for (var n = i[r]; ;) { let t = 1 + (r << 1); if (t >= i.length) break; let e = i[t]; if (t + 1 < i.length && 0 <= e.compare(i[t + 1]) && (e = i[t + 1], t++), n.compare(e) < 0) break; i[t] = n, i[r] = e, r = t } } var te = class { constructor(t, e, i) { this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Jt.from(t, e, i) } goto(t, e = -1e9) { return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this } forward(t, e) { for (; -1 < this.minActive && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0;)this.removeActive(this.minActive); this.cursor.forward(t, e) } removeActive(t) { re(this.active, t), re(this.activeTo, t), re(this.activeRank, t), this.minActive = se(this.active, this.activeTo) } addActive(t) { let e = 0, { value: i, to: r, rank: n } = this.cursor; for (; e < this.activeRank.length && 0 < (n - this.activeRank[e] || r - this.activeTo[e]);)e++; ne(this.active, e, i), ne(this.activeTo, e, r), ne(this.activeRank, e, n), t && ne(t, e, this.cursor.from), this.minActive = se(this.active, this.activeTo) } next() { for (var e = this.to, t = this.point, i = (this.point = null, this.openStart < 0 ? [] : null); ;) { var r = this.minActive; if (-1 < r && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) { if (this.activeTo[r] > e) { this.to = this.activeTo[r], this.endSide = this.active[r].endSide; break } this.removeActive(r), i && re(i, r) } else { if (!this.cursor.value) { this.to = this.endSide = 1e9; break } if (this.cursor.from > e) { this.to = this.cursor.from, this.endSide = this.cursor.startSide; break } r = this.cursor.value; if (r.point) { if (!(t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)) { this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide); break } } else this.addActive(i); this.cursor.next() } } if (i) { this.openStart = 0; for (let t = i.length - 1; 0 <= t && i[t] < e; t--)this.openStart++ } } activeForPoint(e) { if (!this.active.length) return this.active; var i = []; for (let t = this.active.length - 1; 0 <= t && !(this.activeRank[t] < this.pointRank); t--)(this.activeTo[t] > e || this.activeTo[t] == e && this.active[t].endSide >= this.point.endSide) && i.push(this.active[t]); return i.reverse() } openEnd(e) { let i = 0; for (let t = this.activeTo.length - 1; 0 <= t && this.activeTo[t] > e; t--)i++; return i } }; function ee(t, e, i, r, n, s) { t.goto(e), i.goto(r); var o = r + n; let a = r, l = r - e; for (; ;) { var h = t.to + l - i.to || t.endSide - i.endSide, c = h < 0 ? t.to + l : i.to, d = Math.min(c, o); if (t.point || i.point ? t.point && i.point && (t.point == i.point || t.point.eq(i.point)) && ie(t.activeForPoint(t.to), i.activeForPoint(i.to)) || s.comparePoint(a, d, t.point, i.point) : d > a && !ie(t.active, i.active) && s.compareRange(a, d, t.active, i.active), o < c) break; a = c, h <= 0 && t.next(), 0 <= h && i.next() } } function ie(e, i) { if (e.length == i.length) { for (let t = 0; t < e.length; t++)if (e[t] != i[t] && !e[t].eq(i[t])) return; return 1 } } function re(i, r) { for (let t = r, e = i.length - 1; t < e; t++)i[t] = i[t + 1]; i.pop() } function ne(e, i, t) { for (let t = e.length - 1; t >= i; t--)e[t + 1] = e[t]; e[i] = t } function se(e, i) { let r = -1, n = 1e9; for (let t = 0; t < i.length; t++)(i[t] - n || e[t].endSide - e[r].endSide) < 0 && (r = t, n = i[t]); return r } function oe(e, i, r = e.length) { let n = 0; for (let t = 0; t < r;)9 == e.charCodeAt(t) ? (n += i - n % i, t++) : (n++, t = O(e, t)); return n } function ae(i, r, n, t) { for (let t = 0, e = 0; ;) { if (e >= r) return t; if (t == i.length) break; e += 9 == i.charCodeAt(t) ? n - e % n : 1, t = O(i, t) } return !0 === t ? -1 : i.length } var t, le, he = "undefined" == typeof Symbol ? "__Í¼" : Symbol.for("Í¼"), ce = "undefined" == typeof Symbol ? "__styleSet" + Math.floor(1e8 * Math.random()) : Symbol("styleSet"), de = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : {}, Oe = class { constructor(t, e) { this.rules = []; let c = (e || {}).finish; function d(t) { return /^@/.test(t) ? [t] : t.split(/,\s*/) } for (var i in t) !function t(i, e, r, n) { var s, o = [], a = /^@(\w+)\b/.exec(i[0]), l = a && "keyframes" == a[1]; if (a && null == e) return r.push(i[0] + ";"); for (s in e) { var h = e[s]; if (/&/.test(s)) t(s.split(/,\s*/).map(e => i.map(t => e.replace(/&/, t))).reduce((t, e) => t.concat(e)), h, r); else if (h && "object" == typeof h) { if (!a) throw new RangeError("The value of a property (" + s + ") should be a primitive value."); t(d(s), h, o, l) } else null != h && o.push(s.replace(/_.*/, "").replace(/[A-Z]/g, t => "-" + t.toLowerCase()) + ": " + h + ";") } (o.length || l) && r.push((!c || a || n ? i : i.map(c)).join(", ") + " {" + o.join(" ") + "}") }(d(i), t[i], this.rules) } getRules() { return this.rules.join("\n") } static newName() { var t = de[he] || 1; return de[he] = t + 1, "Í¼" + t.toString(36) } static mount(t, e, i) { let r = t[ce], n = i && i.nonce; r ? n && r.setNonce(n) : r = new fe(t, n), r.mount(Array.isArray(e) ? e : [e]) } }, ue = new Map, fe = class { constructor(t, e) { var i = t.ownerDocument || t, r = i.defaultView; if (!t.head && t.adoptedStyleSheets && r.CSSStyleSheet) { var n = ue.get(i); if (n) return t.adoptedStyleSheets = [n.sheet, ...t.adoptedStyleSheets], t[ce] = n; this.sheet = new r.CSSStyleSheet, t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets], ue.set(i, this) } else { this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e); n = t.head || t; n.insertBefore(this.styleTag, n.firstChild) } this.modules = [], t[ce] = this } mount(r) { var n = this.sheet; let s = 0, o = 0; for (let i = 0; i < r.length; i++) { let e = r[i], t = this.modules.indexOf(e); if (t < o && -1 < t && (this.modules.splice(t, 1), o--, t = -1), -1 == t) { if (this.modules.splice(o++, 0, e), n) for (let t = 0; t < e.rules.length; t++)n.insertRule(e.rules[t], s++) } else { for (; o < t;)s += this.modules[o++].rules.length; s += e.rules.length, o++ } } if (!n) { let e = ""; for (let t = 0; t < this.modules.length; t++)e += this.modules[t].getRules() + "\n"; this.styleTag.textContent = e } } setNonce(t) { this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t) } }, pe = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, me = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, ge = "undefined" != typeof navigator && /Mac/.test(navigator.platform), ve = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent); for (t = 0; t < 10; t++)pe[48 + t] = pe[96 + t] = String(t); for (t = 1; t <= 24; t++)pe[t + 111] = "F" + t; for (t = 65; t <= 90; t++)pe[t] = String.fromCharCode(t + 32), me[t] = String.fromCharCode(t); for (le in pe) me.hasOwnProperty(le) || (me[le] = pe[le]); function we(t) { let e; return (e = 11 != t.nodeType || t.getSelection ? t : t.ownerDocument).getSelection() } function be(t, e) { return !!e && (t == e || t.contains(1 != e.nodeType ? e.parentNode : e)) } function ye(t, e) { if (!e.anchorNode) return !1; try { return be(t, e.anchorNode) } catch (t) { return !1 } } function Se(t) { return 3 == t.nodeType ? Re(t, 0, t.nodeValue.length).getClientRects() : 1 == t.nodeType ? t.getClientRects() : [] } function Qe(t, e, i, r) { return !!i && (ke(t, e, i, r, -1) || ke(t, e, i, r, 1)) } function xe(t) { for (var e = 0; ; e++)if (!(t = t.previousSibling)) return e } function ke(t, e, i, r, n) { for (; ;) { if (t == i && e == r) return !0; if (e == (n < 0 ? 0 : $e(t))) { if ("DIV" == t.nodeName) return !1; var s = t.parentNode; if (!s || 1 != s.nodeType) return !1; e = xe(t) + (n < 0 ? 0 : 1), t = s } else { if (1 != t.nodeType) return !1; if (1 == (t = t.childNodes[e + (n < 0 ? -1 : 0)]).nodeType && "false" == t.contentEditable) return !1; e = n < 0 ? $e(t) : 0 } } } function $e(t) { return (3 == t.nodeType ? t.nodeValue : t.childNodes).length } function Pe(t, e) { e = e ? t.left : t.right; return { left: e, right: e, top: t.top, bottom: t.bottom } } function Ze(t, e) { let i = e.width / t.offsetWidth, r = e.height / t.offsetHeight; return (.995 < i && i < 1.005 || !isFinite(i) || Math.abs(e.width - t.offsetWidth) < 1) && (i = 1), (.995 < r && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), { scaleX: i, scaleY: r } } var Te, Ce = class { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } eq(t) { return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset } setRange(t) { var { anchorNode: e, focusNode: i } = t; this.set(e, Math.min(t.anchorOffset, e ? $e(e) : 0), i, Math.min(t.focusOffset, i ? $e(i) : 0)) } set(t, e, i, r) { this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = r } }, Xe = null; function Ae(e) { if (e.setActive) return e.setActive(); if (Xe) return e.focus(Xe); var i = []; for (let t = e; t && (i.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode); if (e.focus(null == Xe ? { get preventScroll() { return Xe = { preventScroll: !0 }, !0 } } : void 0), !Xe) { Xe = !1; for (let t = 0; t < i.length;) { var r = i[t++], n = i[t++], s = i[t++]; r.scrollTop != n && (r.scrollTop = n), r.scrollLeft != s && (r.scrollLeft = s) } } } function Re(t, e, i = e) { var r = Te = Te || document.createRange(); return r.setEnd(t, i), r.setStart(t, e), r } function Ye(t, e, i) { e = { key: e, code: e, keyCode: i, which: i, cancelable: !0 }, i = new KeyboardEvent("keydown", e), i.synthetic = !0, t.dispatchEvent(i), e = new KeyboardEvent("keyup", e); return e.synthetic = !0, t.dispatchEvent(e), i.defaultPrevented || e.defaultPrevented } function We(t) { for (; t.attributes.length;)t.removeAttributeNode(t.attributes[0]) } function Ve(t) { return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4) } var Me = class Vf { constructor(t, e, i = !0) { this.node = t, this.offset = e, this.precise = i } static before(t, e) { return new Vf(t.parentNode, xe(t), e) } static after(t, e) { return new Vf(t.parentNode, xe(t) + 1, e) } }, qe = [], b = class Mf { constructor() { this.parent = null, this.dom = null, this.flags = 2 } get overrideDOMText() { return null } get posAtStart() { return this.parent ? this.parent.posBefore(this) : 0 } get posAtEnd() { return this.posAtStart + this.length } posBefore(t) { let e = this.posAtStart; for (var i of this.children) { if (i == t) return e; e += i.length + i.breakAfter } throw new RangeError("Invalid child in posBefore") } posAfter(t) { return this.posBefore(t) + t.length } sync(i, r) { if (2 & this.flags) { var n, s, o = this.dom; let t = null, e; for (n of this.children) { if (7 & n.flags && (n.dom || !(e = t ? t.nextSibling : o.firstChild) || (s = Mf.get(e)) && (s.parent || !s.canReuseDOM(n)) || n.reuseDOM(e), n.sync(i, r), n.flags &= -8), e = t ? t.nextSibling : o.firstChild, r && !r.written && r.node == o && e != n.dom && (r.written = !0), n.dom.parentNode == o) for (; e && e != n.dom;)e = _e(e); else o.insertBefore(n.dom, e); t = n.dom } for ((e = t ? t.nextSibling : o.firstChild) && r && r.node == o && (r.written = !0); e;)e = _e(e) } else if (1 & this.flags) for (var t of this.children) 7 & t.flags && (t.sync(i, r), t.flags &= -8) } reuseDOM(t) { } localPosFromDOM(e, i) { let r; if (e == this.dom) r = this.dom.childNodes[i]; else { let t = 0 == $e(e) ? 0 : 0 == i ? -1 : 1; for (; ;) { var n = e.parentNode; if (n == this.dom) break; 0 == t && n.firstChild != n.lastChild && (t = e == n.firstChild ? -1 : 1), e = n } r = t < 0 ? e : e.nextSibling } if (r == this.dom.firstChild) return 0; for (; r && !Mf.get(r);)r = r.nextSibling; if (!r) return this.length; for (let t = 0, e = 0; ; t++) { var s = this.children[t]; if (s.dom == r) return e; e += s.length + s.breakAfter } } domBoundsAround(r, n, s = 0) { let o = -1, a = -1, l = -1, h = -1; for (let t = 0, e = s, i = s; t < this.children.length; t++) { var c = this.children[t], d = e + c.length; if (e < r && n < d) return c.domBoundsAround(r, n, e); if (r <= d && -1 == o && (o = t, a = e), e > n && c.dom.parentNode == this.dom) { l = t, h = i; break } i = d, e = d + c.breakAfter } return { from: a, to: h < 0 ? s + this.length : h, startDOM: (o ? this.children[o - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: l < this.children.length && 0 <= l ? this.children[l].dom : null } } markDirty(t = !1) { this.flags |= 2, this.markParentsDirty(t) } markParentsDirty(e) { for (let t = this.parent; t; t = t.parent) { if (e && (t.flags |= 2), 1 & t.flags) return; t.flags |= 1, e = !1 } } setParent(t) { this.parent != t && (this.parent = t, 7 & this.flags) && this.markParentsDirty(!0) } setDOM(t) { this.dom != t && (this.dom && (this.dom.cmView = null), (this.dom = t).cmView = this) } get rootView() { for (let t = this; ;) { var e = t.parent; if (!e) return t; t = e } } replaceChildren(e, i, r = qe) { this.markDirty(); for (let t = e; t < i; t++) { var n = this.children[t]; n.parent == this && r.indexOf(n) < 0 && n.destroy() } this.children.splice(e, i - e, ...r); for (let t = 0; t < r.length; t++)r[t].setParent(this) } ignoreMutation(t) { return !1 } ignoreEvent(t) { return !1 } childCursor(t = this.length) { return new je(this.children, t, this.children.length) } childPos(t, e = 1) { return this.childCursor().findPos(t, e) } toString() { var t = this.constructor.name.replace("View", ""); return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "") } static get(t) { return t.cmView } get isEditable() { return !0 } get isWidget() { return !1 } get isHidden() { return !1 } merge(t, e, i, r, n, s) { return !1 } become(t) { return !1 } canReuseDOM(t) { return t.constructor == this.constructor && !(8 & (this.flags | t.flags)) } getSide() { return 0 } destroy() { for (var t of this.children) t.parent == this && t.destroy(); this.parent = null } }; function _e(t) { var e = t.nextSibling; return t.parentNode.removeChild(t), e } b.prototype.breakAfter = 0; var je = class { constructor(t, e, i) { this.children = t, this.pos = e, this.i = i, this.off = 0 } findPos(t, e = 1) { for (; ;) { if (t > this.pos || t == this.pos && (0 < e || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t - this.pos, this; var i = this.children[--this.i]; this.pos -= i.length + i.breakAfter } } }; function Ee(t, e, i, r, n, s, o, a, l) { var h = t.children, c = h.length ? h[e] : null, d = s.length ? s[s.length - 1] : null, O = d ? d.breakAfter : o; if (!(e == r && c && !o && !O && s.length < 2 && c.merge(i, n, s.length ? d : null, 0 == i, a, l))) { if (r < h.length) { let t = h[r]; t && (n < t.length || t.breakAfter && null != d && d.breakAfter) ? (e == r && (t = t.split(n), n = 0), !O && d && t.merge(0, n, d, !0, 0, l) ? s[s.length - 1] = t : ((n || t.children.length && !t.children[0].length) && t.merge(0, n, null, !1, 0, l), s.push(t))) : null != t && t.breakAfter && (d ? d.breakAfter = 1 : o = 1), r++ } for (c && (c.breakAfter = o, 0 < i) && (!o && s.length && c.merge(i, c.length, s[0], !1, a, 0) ? c.breakAfter = s.shift().breakAfter : (i < c.length || c.children.length && 0 == c.children[c.children.length - 1].length) && c.merge(i, c.length, null, !1, a, 0), e++); e < r && s.length;)if (h[r - 1].become(s[s.length - 1])) r--, s.pop(), l = s.length ? 0 : a; else { if (!h[e].become(s[0])) break; e++, s.shift(), a = s.length ? 0 : l } !s.length && e && r < h.length && !h[e - 1].breakAfter && h[r].merge(0, 0, h[e - 1], !1, a, l) && e--, (e < r || s.length) && t.replaceChildren(e, r, s) } } function De(t, e, i, r, n, s) { var o, a = t.childCursor(), { i: l, off: h } = a.findPos(i, 1), { i: a, off: c } = a.findPos(e, -1); let d = e - i; for (o of r) d += o.length; t.length += d, Ee(t, a, c, l, h, r, 0, n, s) } var ze = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" }, Be = "undefined" != typeof document ? document : { documentElement: { style: {} } }, e = /Edge\/(\d+)/.exec(ze.userAgent), Ge = /MSIE \d/.test(ze.userAgent), Ie = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ze.userAgent), Ne = !!(Ge || Ie || e), Ue = !Ne && /gecko\/(\d+)/i.test(ze.userAgent), i = !Ne && /Chrome\/(\d+)/.exec(ze.userAgent), Le = "webkitFontSmoothing" in Be.documentElement.style, r = !Ne && /Apple Computer/.test(ze.vendor), n = r && (/Mobile\/\w+/.test(ze.userAgent) || 2 < ze.maxTouchPoints), y = { mac: n || /Mac/.test(ze.platform), windows: /Win/.test(ze.platform), linux: /Linux|X11/.test(ze.platform), ie: Ne, ie_version: Ge ? Be.documentMode || 6 : Ie ? +Ie[1] : e ? +e[1] : 0, gecko: Ue, gecko_version: Ue ? +(/Firefox\/(\d+)/.exec(ze.userAgent) || [0, 0])[1] : 0, chrome: !!i, chrome_version: i ? +i[1] : 0, ios: n, android: /Android\b/.test(ze.userAgent), webkit: Le, safari: r, webkit_version: Le ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0, tabSize: null != Be.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" }, Fe = class qf extends b { constructor(t) { super(), this.text = t } get length() { return this.text.length } createDOM(t) { this.setDOM(t || document.createTextNode(this.text)) } sync(t, e) { this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text) } reuseDOM(t) { 3 == t.nodeType && this.createDOM(t) } merge(t, e, i) { return !(8 & this.flags || i && (!(i instanceof qf) || 256 < this.length - (e - t) + i.length || 8 & i.flags) || (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), 0)) } split(t) { var e = new qf(this.text.slice(t)); return this.text = this.text.slice(0, t), this.markDirty(), e.flags |= 8 & this.flags, e } localPosFromDOM(t, e) { return t == this.dom ? e : e ? this.text.length : 0 } domAtPos(t) { return new Me(this.dom, t) } domBoundsAround(t, e, i) { return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling } } coordsAt(n, s) { { var o = this.dom, a = o.nodeValue.length; let t = n = a < n ? a : n, e = n, i = 0; if (0 == n && s < 0 || n == a && 0 <= s ? y.chrome || y.gecko || (n ? (t--, i = 1) : e < a && (e++, i = -1)) : s < 0 ? t-- : e < a && e++, !(n = Re(o, t, e).getClientRects()).length) return null; let r = n[(i ? i < 0 : 0 <= s) ? 0 : n.length - 1]; return y.safari && !i && 0 == r.width && (r = Array.prototype.find.call(n, t => t.width) || r), i ? Pe(r, i < 0) : r || null } } }, He = class _f extends b { constructor(t, e = [], i = 0) { super(), this.mark = t, this.children = e, this.length = i; for (var r of e) r.setParent(this) } setAttrs(t) { if (We(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs) for (var e in this.mark.attrs) t.setAttribute(e, this.mark.attrs[e]); return t } canReuseDOM(t) { return super.canReuseDOM(t) && !(8 & (this.flags | t.flags)) } reuseDOM(t) { t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6) } sync(t, e) { this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, e) } merge(t, e, i, r, n, s) { return !(i && (!(i instanceof _f && i.mark.eq(this.mark)) || t && n <= 0 || e < this.length && s <= 0) || (De(this, t, e, i ? i.children.slice() : [], n - 1, s - 1), this.markDirty(), 0)) } split(t) { let e = [], i = 0, r = -1, n = 0; for (var s of this.children) { var o = i + s.length; t < o && e.push(i < t ? s.split(t - i) : s), r < 0 && i >= t && (r = n), i = o, n++ } var a = this.length - t; return this.length = t, -1 < r && (this.children.length = r, this.markDirty()), new _f(this.mark, e, a) } domAtPos(t) { return ti(this, t) } coordsAt(t, e) { return ei(this, t, e) } }; var Je = class jf extends b { static create(t, e, i) { return new jf(t, e, i) } constructor(t, e, i) { super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null } split(t) { var e = jf.create(this.widget, this.length - t, this.side); return this.length -= t, e } sync(t) { this.dom && this.widget.updateDOM(this.dom, t) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable) || (this.dom.contentEditable = "false") } getSide() { return this.side } merge(t, e, i, r, n, s) { return !(i && (!(i instanceof jf && this.widget.compare(i.widget)) || 0 < t && n <= 0 || e < this.length && s <= 0) || (this.length = t + (i ? i.length : 0) + (this.length - e), 0)) } become(t) { return t instanceof jf && t.side == this.side && this.widget.constructor == t.widget.constructor && (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) } ignoreMutation() { return !0 } ignoreEvent(t) { return this.widget.ignoreEvent(t) } get overrideDOMText() { if (0 == this.length) return m.empty; let t = this; for (; t.parent;)t = t.parent; var e = t.view, e = e && e.state.doc, i = this.posAtStart; return e ? e.slice(i, i + this.length) : m.empty } domAtPos(t) { return (this.length ? 0 == t : 0 < this.side) ? Me.before(this.dom) : Me.after(this.dom, t == this.length) } domBoundsAround() { return null } coordsAt(e, t) { t = this.widget.coordsAt(this.dom, e, t); if (t) return t; let i = this.dom.getClientRects(), r = null; if (!i.length) return null; var n = this.side ? this.side < 0 : 0 < e; for (let t = n ? i.length - 1 : 0; r = i[t], !(0 < e ? 0 == t : t == i.length - 1 || r.top < r.bottom); t += n ? -1 : 1); return Pe(r, !n) } get isEditable() { return !1 } get isWidget() { return !0 } get isHidden() { return this.widget.isHidden } destroy() { super.destroy(), this.dom && this.widget.destroy(this.dom) } }, Ke = class Ef extends b { constructor(t) { super(), this.side = t } get length() { return 0 } merge() { return !1 } become(t) { return t instanceof Ef && t.side == this.side } split() { return new Ef(this.side) } sync() { var t; this.dom || ((t = document.createElement("img")).className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t)) } getSide() { return this.side } domAtPos(t) { return 0 < this.side ? Me.before(this.dom) : Me.after(this.dom) } localPosFromDOM() { return 0 } domBoundsAround() { return null } coordsAt(t) { return this.dom.getBoundingClientRect() } get overrideDOMText() { return m.empty } get isHidden() { return !0 } }; function ti(t, e) { let i = t.dom, r = t.children, n = 0; for (let t = 0; n < r.length; n++) { var s = r[n], o = t + s.length; if (!(o == t && s.getSide() <= 0)) { if (e > t && e < o && s.dom.parentNode == i) return s.domAtPos(e - t); if (e <= t) break; t = o } } for (let t = n; 0 < t; t--) { var a = r[t - 1]; if (a.dom.parentNode == i) return a.domAtPos(a.length) } for (let t = n; t < r.length; t++) { var l = r[t]; if (l.dom.parentNode == i) return l.domAtPos(0) } return new Me(i, 0) } function ei(t, e, a) { let l = null, h = -1, c = null, d = -1; !function i(r, n) { for (let t = 0, e = 0; t < r.children.length && e <= n; t++) { var s = r.children[t], o = e + s.length; n <= o && (s.children.length ? i(s, n - e) : (!c || c.isHidden && 0 < a) && (n < o || e == o && 0 < s.getSide()) ? (c = s, d = n - e) : (e < n || e == o && s.getSide() < 0 && !s.isHidden) && (l = s, h = n - e)), e = o } }(t, e); var e = (a < 0 ? l : c) || l || c; return e ? e.coordsAt(Math.max(0, e == l ? h : d), a) : (t = (e = t).dom.lastChild) ? (e = Se(t))[e.length - 1] || null : e.dom.getBoundingClientRect() } function ii(t, e) { for (var i in t) "class" == i && e.class ? e.class += " " + t.class : "style" == i && e.style ? e.style += ";" + t.style : e[i] = t[i]; return e } Fe.prototype.children = Je.prototype.children = Ke.prototype.children = qe; var ri = Object.create(null); function ni(t, e, i) { if (t != e) { t = t || ri, e = e || ri; var r, n = Object.keys(t), s = Object.keys(e); if (n.length - (i && -1 < n.indexOf(i) ? 1 : 0) != s.length - (i && -1 < s.indexOf(i) ? 1 : 0)) return !1; for (r of n) if (r != i && (-1 == s.indexOf(r) || t[r] !== e[r])) return !1 } return !0 } function si(t, e, i) { let r = !1; if (e) for (var n in e) i && n in i || (r = !0, "style" == n ? t.style.cssText = "" : t.removeAttribute(n)); if (i) for (var s in i) e && e[s] == i[s] || (r = !0, "style" == s ? t.style.cssText = i[s] : t.setAttribute(s, i[s])); return r } var oi = class Df extends b { constructor() { super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0 } merge(t, e, i, r, n, s) { if (i) { if (!(i instanceof Df)) return !1; this.dom || i.transferDOM(this) } return r && this.setDeco(i ? i.attrs : null), De(this, t, e, i ? i.children.slice() : [], n, s), !0 } split(i) { var r = new Df; if (r.breakAfter = this.breakAfter, 0 != this.length) { let { i: e, off: t } = this.childPos(i); t && (r.append(this.children[e].split(t), 0), this.children[e].merge(t, this.children[e].length, null, !1, 0, 0), e++); for (let t = e; t < this.children.length; t++)r.append(this.children[t], 0); for (; 0 < e && 0 == this.children[e - 1].length;)this.children[--e].destroy(); this.children.length = e, this.markDirty(), this.length = i } return r } transferDOM(t) { this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null) } setDeco(t) { ni(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t) } append(t, e) { !function t(e, i, r) { let n, s = e.children; 0 < r && i instanceof He && s.length && (n = s[s.length - 1]) instanceof He && n.mark.eq(i.mark) ? t(n, i.children[0], r - 1) : (s.push(i), i.setParent(e)), e.length += i.length }(this, t, e) } addLineDeco(t) { var e = t.spec.attributes, t = t.spec.class; e && (this.attrs = ii(e, this.attrs || {})), t && (this.attrs = ii({ class: t }, this.attrs || {})) } domAtPos(t) { return ti(this, t) } reuseDOM(t) { "DIV" == t.nodeName && (this.setDOM(t), this.flags |= 6) } sync(t, e) { this.dom ? 4 & this.flags && (We(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (si(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, e); let i = this.dom.lastChild; for (; i && b.get(i) instanceof He;)i = i.lastChild; i && this.length && ("BR" == i.nodeName || 0 != (null == (t = b.get(i)) ? void 0 : t.isEditable) || y.ios && this.children.some(t => t instanceof Fe)) || ((e = document.createElement("BR")).cmIgnore = !0, this.dom.appendChild(e)) } measureTextSize() { if (0 == this.children.length || 20 < this.length) return null; let t = 0, e; for (var i of this.children) { if (!(i instanceof Fe) || /[^ -~]/.test(i.text)) return null; i = Se(i.dom); if (1 != i.length) return null; t += i[0].width, e = i[0].height } return t ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t / this.length, textHeight: e } : null } coordsAt(t, e) { t = ei(this, t, e); if (!this.children.length && t && this.parent) { var e = this.parent.view.viewState.heightOracle, i = t.bottom - t.top; if (Math.abs(i - e.lineHeight) < 2 && e.textHeight < i) return i = (i - e.textHeight) / 2, { top: t.top + i, bottom: t.bottom - i, left: t.left, right: t.left } } return t } become(t) { return !1 } covers() { return !0 } static find(i, r) { for (let t = 0, e = 0; t < i.children.length; t++) { var n = i.children[t], s = e + n.length; if (r <= s) { if (n instanceof Df) return n; if (r < s) break } e = s + n.breakAfter } return null } }, ai = class zf extends b { constructor(t, e, i) { super(), this.widget = t, this.length = e, this.deco = i, this.breakAfter = 0, this.prevWidget = null } merge(t, e, i, r, n, s) { return !(i && (!(i instanceof zf && this.widget.compare(i.widget)) || 0 < t && n <= 0 || e < this.length && s <= 0) || (this.length = t + (i ? i.length : 0) + (this.length - e), 0)) } domAtPos(t) { return 0 == t ? Me.before(this.dom) : Me.after(this.dom, t == this.length) } split(t) { var e = this.length - t, t = (this.length = t, new zf(this.widget, e, this.deco)); return t.breakAfter = this.breakAfter, t } get children() { return qe } sync(t) { this.dom && this.widget.updateDOM(this.dom, t) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable) || (this.dom.contentEditable = "false") } get overrideDOMText() { return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : m.empty } domBoundsAround() { return null } become(t) { return t instanceof zf && t.widget.constructor == this.widget.constructor && (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) } ignoreMutation() { return !0 } ignoreEvent(t) { return this.widget.ignoreEvent(t) } get isEditable() { return !1 } get isWidget() { return !0 } coordsAt(t, e) { return this.widget.coordsAt(this.dom, t, e) } destroy() { super.destroy(), this.dom && this.widget.destroy(this.dom) } covers(t) { var { startSide: e, endSide: i } = this.deco; return e != i && (t < 0 ? e < 0 : 0 < i) } }, Ne = class { eq(t) { return !1 } updateDOM(t, e) { return !1 } compare(t) { return this == t || this.constructor == t.constructor && this.eq(t) } get estimatedHeight() { return -1 } get lineBreaks() { return 0 } ignoreEvent(t) { return !0 } coordsAt(t, e, i) { return null } get isHidden() { return !1 } get editable() { return !1 } destroy(t) { } }, li = (t => (t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t))(li = li || {}), S = class extends Gt { constructor(t, e, i, r) { super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = r } get heightRelevant() { return !1 } static mark(t) { return new hi(t) } static widget(t) { var e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block; return e += i && !t.inlineOrder ? 0 < e ? 3e8 : -4e8 : 0 < e ? 1e8 : -1e8, new di(t, e, e, i, t.widget || null, !1) } static replace(t) { let e = !!t.block, i, r; var n, s; return r = t.isBlockGap ? (i = -5e8, 4e8) : ({ start: n, end: s } = Oi(t, e), i = (n ? e ? -3e8 : -1 : 5e8) - 1, 1 + (s ? e ? 2e8 : 1 : -6e8)), new di(t, i, r, e, t.widget || null, !0) } static line(t) { return new ci(t) } static set(t, e = !1) { return w.of(t, e) } hasHeight() { return !!this.widget && -1 < this.widget.estimatedHeight } }, hi = (S.none = w.empty, class Bf extends S { constructor(t) { var { start: e, end: i } = Oi(t); super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null } eq(t) { var e; return this == t || t instanceof Bf && this.tagName == t.tagName && (this.class || (null == (e = this.attrs) ? void 0 : e.class)) == (t.class || (null == (e = t.attrs) ? void 0 : e.class)) && ni(this.attrs, t.attrs, "class") } range(t, e = t) { if (e <= t) throw new RangeError("Mark decorations may not be empty"); return super.range(t, e) } }), ci = (hi.prototype.point = !1, class Gf extends S { constructor(t) { super(-2e8, -2e8, null, t) } eq(t) { return t instanceof Gf && this.spec.class == t.spec.class && ni(this.spec.attributes, t.spec.attributes) } range(t, e = t) { if (e != t) throw new RangeError("Line decoration ranges must be zero-length"); return super.range(t, e) } }), di = (ci.prototype.mapMode = h.TrackBefore, ci.prototype.point = !0, class If extends S { constructor(t, e, i, r, n, s) { super(e, i, n, t), this.block = r, this.isReplace = s, this.mapMode = r ? e <= 0 ? h.TrackBefore : h.TrackAfter : h.TrackDel } get type() { return this.startSide != this.endSide ? li.WidgetRange : this.startSide <= 0 ? li.WidgetBefore : li.WidgetAfter } get heightRelevant() { return this.block || !!this.widget && (5 <= this.widget.estimatedHeight || 0 < this.widget.lineBreaks) } eq(t) { return t instanceof If && (e = this.widget, i = t.widget, e == i || !!(e && i && e.compare(i))) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide; var e, i } range(t, e = t) { if (this.isReplace && (e < t || t == e && 0 < this.startSide && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration"); if (this.isReplace || e == t) return super.range(t, e); throw new RangeError("Widget decorations can only have zero-length ranges") } }); function Oi(t, e = !1) { let { inclusiveStart: i, inclusiveEnd: r } = t; return null == i && (i = t.inclusive), null == r && (r = t.inclusive), { start: null != i ? i : e, end: null != r ? r : e } } function ui(t, e, i, r = 0) { var n = i.length - 1; 0 <= n && i[n] + r >= t ? i[n] = Math.max(i[n], e) : i.push(t, e) } di.prototype.point = !0; var fi = class Nf { constructor(t, e, i, r) { this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e } posCovered() { var t; return 0 == this.content.length ? !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos : !((t = this.content[this.content.length - 1]).breakAfter || t instanceof ai && t.deco.endSide < 0) } getLine() { return this.curLine || (this.content.push(this.curLine = new oi), this.atCursorPos = !0), this.curLine } flushBuffer(t = this.bufferMarks) { this.pendingBuffer && (this.curLine.append(pi(new Ke(-1), t), t.length), this.pendingBuffer = 0) } addBlockWidget(t) { this.flushBuffer(), this.curLine = null, this.content.push(t) } finish(t) { this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || t && this.content.length && this.content[this.content.length - 1] instanceof ai || this.getLine() } buildText(t, e, i) { for (; 0 < t;) { if (this.textOff == this.text.length) { var { value: r, lineBreak: n, done: s } = this.cursor.next(this.skip); if (this.skip = 0, s) throw new Error("Ran out of text content when drawing inline views"); if (n) { this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--; continue } this.text = r, this.textOff = 0 } s = Math.min(this.text.length - this.textOff, t, 512); this.flushBuffer(e.slice(e.length - i)), this.getLine().append(pi(new Fe(this.text.slice(this.textOff, this.textOff + s)), e), i), this.atCursorPos = !0, this.textOff += s, t -= s, i = 0 } } span(t, e, i, r) { this.buildText(e - t, i, r), this.pos = e, this.openStart < 0 && (this.openStart = r) } point(t, e, i, r, n, s) { if (this.disallowBlockEffectsFor[s] && i instanceof di) { if (i.block) throw new RangeError("Block decorations may not be specified via plugins"); if (e > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins") } var o, a, l, h, s = e - t; i instanceof di ? i.block ? (0 < i.startSide && !this.posCovered() && this.getLine(), this.addBlockWidget(new ai(i.widget || new mi("div"), s, i))) : (o = Je.create(i.widget || new mi("span"), s, s ? 0 : i.startSide), a = this.atCursorPos && !o.isEditable && n <= r.length && (t < e || 0 < i.startSide), l = !o.isEditable && (t < e || n > r.length || i.startSide <= 0), h = this.getLine(), 2 != this.pendingBuffer || a || o.isEditable || (this.pendingBuffer = 0), this.flushBuffer(r), a && (h.append(pi(new Ke(1), r), n), n = r.length + Math.max(0, n - r.length)), h.append(pi(o, r), n), this.atCursorPos = l, this.pendingBuffer = l ? t < e || n > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice())) : this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i), s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = n) } static build(t, e, i, r, n) { t = new Nf(t, e, i, n); return t.openEnd = w.spans(r, e, i, t), t.openStart < 0 && (t.openStart = t.openEnd), t.finish(t.openEnd), t } }; function pi(t, e) { for (var i of e) t = new He(i, [t], t.length); return t } var mi = class extends Ne { constructor(t) { super(), this.tag = t } eq(t) { return t.tag == this.tag } toDOM() { return document.createElement(this.tag) } updateDOM(t) { return t.nodeName.toLowerCase() == this.tag } get isHidden() { return !0 } }, k = (t => (t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t))(k = k || {}), gi = k.LTR, vi = k.RTL; function wi(e) { var i = []; for (let t = 0; t < e.length; t++)i.push(1 << +e[t]); return i } var bi, yi = wi("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Si = wi("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Qi = Object.create(null), xi = []; for (bi of ["()", "[]", "{}"]) { var ki = bi.charCodeAt(0), $i = bi.charCodeAt(1); Qi[ki] = $i, Qi[$i] = -ki } function Pi(t) { return t <= 247 ? yi[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? Si[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1 } var Zi = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/, Ti = class { get dir() { return this.level % 2 ? vi : gi } constructor(t, e, i) { this.from = t, this.to = e, this.level = i } side(t, e) { return this.dir == e == t ? this.to : this.from } forward(t, e) { return t == (this.dir == e) } static find(e, i, r, n) { let s = -1; for (let t = 0; t < e.length; t++) { var o = e[t]; if (o.from <= i && o.to >= i) { if (o.level == r) return t; (s < 0 || (0 != n ? n < 0 ? o.from < i : o.to > i : e[s].level > o.level)) && (s = t) } } if (s < 0) throw new RangeError("Index out of range"); return s } }; var W = []; function Ci(t, e, i, r, n, s, o) { var a = e % 2 ? 2 : 1, l = t, h = n, c = s, d = r, O = a; for (let t = 0; t <= d.length; t++) { var u = t ? d[t - 1].to : h, f = t < d.length ? d[t].from : c, p = t ? 256 : O; for (let e = u, i = p, r = p; e < f; e++) { let t = Pi(l.charCodeAt(e)); 512 == t ? t = i : 8 == t && 4 == r && (t = 16), W[e] = 4 == t ? 2 : t, 7 & t && (r = t), i = t } for (let i = u, r = p, n = p; i < f; i++) { let t = W[i]; if (128 == t) i < f - 1 && r == W[i + 1] && 24 & r ? t = W[i] = r : W[i] = 256; else if (64 == t) { let e = i + 1; for (; e < f && 64 == W[e];)e++; var m = i && 8 == r || e < c && 8 == W[e] ? 1 == n ? 1 : 8 : 256; for (let t = i; t < e; t++)W[t] = m; i = e - 1 } else 8 == t && 1 == n && (W[i] = 1); 7 & (r = t) && (n = t) } } var g = t, v = n, w = s, b = r, y = a, S = 1 == y ? 2 : 1; for (let t = 0, n = 0, s = 0; t <= b.length; t++) { var Q = t ? b[t - 1].to : v, x = t < b.length ? b[t].from : w; for (let e = Q, t, i, r; e < x; e++)if (i = Qi[t = g.charCodeAt(e)]) if (i < 0) { for (let t = n - 3; 0 <= t; t -= 3)if (xi[t + 1] == -i) { var k = xi[t + 2], k = 2 & k ? y : 4 & k ? 1 & k ? S : y : 0; k && (W[e] = W[xi[t]] = k), n = t; break } } else { if (189 == xi.length) break; xi[n++] = e, xi[n++] = t, xi[n++] = s } else if (2 == (r = W[e]) || 1 == r) { var $ = r == y; s = $ ? 0 : 1; for (let t = n - 3; 0 <= t; t -= 3) { var P = xi[t + 2]; if (2 & P) break; if ($) xi[t + 2] |= 2; else { if (4 & P) break; xi[t + 2] |= 4 } } } } var Z = n, T = s, C = r, X = a; for (let s = 0, i = X; s <= C.length; s++) { let t = s ? C[s - 1].to : Z, e = s < C.length ? C[s].from : T; for (let n = t; n < e;) { var A = W[n]; if (256 == A) { let r = n + 1; for (; ;)if (r == e) { if (s == C.length) break; r = C[s++].to, e = s < C.length ? C[s].from : T } else { if (256 != W[r]) break; r++ } var R = 1 == i, Y = R == (1 == (r < T ? W[r] : X)) ? R ? 1 : 2 : X; for (let t = r, e = s, i = e ? C[e - 1].to : Z; t > n;)t == i && (t = C[--e].from, i = e ? C[e - 1].to : Z), W[--t] = Y; n = r } else i = A, n++ } } !function s(o, a, l, h, c, d, O) { var u = h % 2 ? 2 : 1; if (h % 2 == c % 2) for (let r = a, n = 0; r < l;) { let t = !0, e = !1; (n == d.length || r < d[n].from) && (f = W[r]) != u && (t = !1, e = 16 == f); var f, p = t || 1 != u ? null : [], m = t ? h : h + 1; let i = r; t: for (; ;)if (n < d.length && i == d[n].from) { if (e) break; var g = d[n]; if (!t) for (let t = g.to, e = n + 1; ;) { if (t == l) break t; if (!(e < d.length && d[e].from == t)) { if (W[t] == u) break t; break } t = d[e++].to } n++, p ? p.push(g) : (g.from > r && O.push(new Ti(r, g.from, m)), Ci(o, g.direction == gi != !(m % 2) ? h + 1 : h, c, g.inner, g.from, g.to, O), r = g.to), i = g.to } else { if (i == l || (t ? W[i] != u : W[i] == u)) break; i++ } p ? s(o, r, i, h + 1, c, p, O) : r < i && O.push(new Ti(r, i, m)), r = i } else for (let r = l, n = d.length; r > a;) { let t = !0, e = !1; (!n || r > d[n - 1].to) && (v = W[r - 1]) != u && (t = !1, e = 16 == v); var v, w = t || 1 != u ? null : [], b = t ? h : h + 1; let i = r; t: for (; ;)if (n && i == d[n - 1].to) { if (e) break; var y = d[--n]; if (!t) for (let t = y.from, e = n; ;) { if (t == a) break t; if (!e || d[e - 1].to != t) { if (W[t - 1] == u) break t; break } t = d[--e].from } w ? w.push(y) : (y.to < r && O.push(new Ti(y.to, r, b)), Ci(o, y.direction == gi != !(b % 2) ? h + 1 : h, c, y.inner, y.from, y.to, O), r = y.from), i = y.from } else { if (i == a || (t ? W[i - 1] != u : W[i - 1] == u)) break; i-- } w ? s(o, i, r, h + 1, c, w, O) : i < r && O.push(new Ti(i, r, b)), r = i } }(t, n, s, e, i, r, o) } function Xi(t) { return [new Ti(0, t, 0)] } var Ai = ""; var Ri = d.define(), Yi = d.define(), Wi = d.define(), Vi = d.define(), Mi = d.define(), qi = d.define(), _i = d.define(), ji = d.define({ combine: t => t.some(t => t) }), Ei = d.define({ combine: t => t.some(t => t) }), Di = class Uf { constructor(t, e = "nearest", i = "nearest", r = 5, n = 5, s = !1) { this.range = t, this.y = e, this.x = i, this.yMargin = r, this.xMargin = n, this.isSnapshot = s } map(t) { return t.empty ? this : new Uf(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot) } clip(t) { return this.range.to <= t.doc.length ? this : new Uf(g.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot) } }, zi = c.define({ map: (t, e) => t.map(e) }); function Bi(t, e, i) { t = t.facet(Vi); t.length ? t[0](e) : window.onerror ? window.onerror(String(e), i, void 0, void 0, e) : i ? console.error(i + ":", e) : console.error(e) } var Gi = d.define({ combine: t => !t.length || t[0] }), Ii = 0, Ni = d.define(), a = class Lf { constructor(t, e, i, r, n) { this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = r, this.extension = n(this) } static define(t, e) { let { eventHandlers: i, eventObservers: r, provide: n, decorations: s } = e || {}; return new Lf(Ii++, t, i, r, e => { var t = [Ni.of(e)]; return s && t.push(Hi.of(t => { t = t.plugin(e); return t ? s(t) : S.none })), n && t.push(n(e)), t }) } static fromClass(e, t) { return Lf.define(t => new e(t), t) } }, Ui = class { constructor(t) { this.spec = t, this.mustUpdate = null, this.value = null } update(e) { if (this.value) { if (this.mustUpdate) { var i = this.mustUpdate; if (this.mustUpdate = null, this.value.update) try { this.value.update(i) } catch (t) { if (Bi(i.state, t, "CodeMirror plugin crashed"), this.value.destroy) try { this.value.destroy() } catch (t) { } this.deactivate() } } } else if (this.spec) try { this.value = this.spec.create(e) } catch (t) { Bi(e.state, t, "CodeMirror plugin crashed"), this.deactivate() } return this } destroy(e) { var t; if (null != (t = this.value) && t.destroy) try { this.value.destroy() } catch (t) { Bi(e.state, t, "CodeMirror plugin crashed") } } deactivate() { this.spec = this.value = null } }, Li = d.define(), Fi = d.define(), Hi = d.define(), Ji = d.define(), Ki = d.define(), tr = d.define(); function er(e, h) { var t = e.state.facet(tr); if (!t.length) return t; t = t.map(t => t instanceof Function ? t(e) : t); let i = []; return w.spans(t, h.from, h.to, { point() { }, span(t, e, r, n) { var s, o = t - h.from, a = e - h.from; let l = i; for (let i = r.length - 1; 0 <= i; i--, n--) { let t = r[i].spec.bidiIsolate, e; null == t && (t = ((e, i, r) => { for (let t = i; t < r; t++) { var n = Pi(e.charCodeAt(t)); if (1 == n) return gi; if (2 == n || 4 == n) return vi } return gi })(h.text, o, a)), l = (0 < n && l.length && (e = l[l.length - 1]).to == o && e.direction == t ? (e.to = a, e) : (s = { from: o, to: a, direction: t, inner: [] }, l.push(s), s)).inner } } }), i } var ir = d.define(); function rr(t) { let e = 0, i = 0, r = 0, n = 0; for (var s of t.state.facet(ir)) { s = s(t); s && (null != s.left && (e = Math.max(e, s.left)), null != s.right && (i = Math.max(i, s.right)), null != s.top && (r = Math.max(r, s.top)), null != s.bottom) && (n = Math.max(n, s.bottom)) } return { left: e, right: i, top: r, bottom: n } } var nr = d.define(), sr = class Ff { constructor(t, e, i, r) { this.fromA = t, this.toA = e, this.fromB = i, this.toB = r } join(t) { return new Ff(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB)) } addToSet(t) { let e = t.length, i = this; for (; 0 < e; e--) { var r = t[e - 1]; if (!(r.fromA > i.toA)) { if (r.toA < i.fromA) break; i = i.join(r), t.splice(e - 1, 1) } } return t.splice(e, 0, i), t } static extendWithRanges(n, s) { if (0 == s.length) return n; var o = []; for (let t = 0, e = 0, i = 0, r = 0; ; t++) { for (var a = t == n.length ? null : n[t], l = i - r, h = a ? a.fromB : 1e9; e < s.length && s[e] < h;) { var c = s[e], d = s[e + 1], c = Math.max(r, c), O = Math.min(h, d); if (c <= O && new Ff(c + l, O + l, c, O).addToSet(o), h < d) break; e += 2 } if (!a) return o; new Ff(a.fromA, a.toA, a.fromB, a.toB).addToSet(o), i = a.toA, r = a.toB } } }, or = class Hf { constructor(t, e, i) { this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = it.empty(this.startState.doc.length); for (var r of i) this.changes = this.changes.compose(r.changes); let n = []; this.changes.iterChangedRanges((t, e, i, r) => n.push(new sr(t, e, i, r))), this.changedRanges = n } static create(t, e, i) { return new Hf(t, e, i) } get viewportChanged() { return 0 < (4 & this.flags) } get heightChanged() { return 0 < (2 & this.flags) } get geometryChanged() { return this.docChanged || 0 < (10 & this.flags) } get focusChanged() { return 0 < (1 & this.flags) } get docChanged() { return !this.changes.empty } get selectionSet() { return this.transactions.some(t => t.selection) } get empty() { return 0 == this.flags && 0 == this.transactions.length } }, ar = class extends b { get length() { return this.view.state.doc.length } constructor(t) { super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = new Set, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new oi], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new sr(0, 0, 0, t.state.doc.length)], 0, null) } update(t) { let e, i = t.changedRanges, r = (0 < this.minWidth && i.length && (i.every(({ fromA: t, toA: e }) => e < this.minWidthFrom || t > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), -1); 0 <= this.view.inputState.composing && (null != (e = this.domChanged) && e.newSel ? r = this.domChanged.newSel.head : ((t, i) => { let r = !1; return i && t.iterChangedRanges((t, e) => { t < i.to && e > i.from && (r = !0) }), r })(t.changes, this.hasComposition) || t.selectionSet || (r = t.state.selection.main.head)); var n, s = -1 < r ? ((e, t, i) => { if (!(i = hr(e, i))) return null; var { node: r, from: n, to: s } = i, o = r.nodeValue; if (/[\n\r]/.test(o)) return null; if (e.state.doc.sliceString(i.from, i.to) != o) return null; var i = t.invertedDesc, a = new sr(i.mapPos(n), i.mapPos(s), n, s), l = []; for (let t = r.parentNode; ; t = t.parentNode) { var h = b.get(t); if (h instanceof He) l.push({ node: t, deco: h.mark }); else { if (h instanceof oi || "DIV" == t.nodeName && t.parentNode == e.contentDOM) return { range: a, text: r, marks: l, line: t }; if (t == e.contentDOM) return null; l.push({ node: t, deco: new hi({ inclusive: !0, attributes: (e => { var i = Object.create(null); for (let t = 0; t < e.attributes.length; t++) { var r = e.attributes[t]; i[r.name] = r.value } return i })(t), tagName: t.tagName.toLowerCase() }) }) } } })(this.view, t.changes, r) : null, o = (this.domChanged = null, this.hasComposition && (this.markedForComposition.clear(), { from: o, to: a } = this.hasComposition, i = new sr(o, a, t.changes.mapPos(o, -1), t.changes.mapPos(a, 1)).addToSet(i.slice())), this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (y.ie || y.chrome) && !s && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0), this.decorations), a = this.updateDeco(), l = (o = o, a = a, l = t.changes, n = new dr, w.compare(o, a, l, n), n.changes); return i = sr.extendWithRanges(i, l), !!(7 & this.flags || 0 != i.length) && (this.updateInner(i, t.startState.doc.length, s), t.transactions.length && (this.lastUpdate = Date.now()), !0) } updateInner(t, e, i) { this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e, i); let r = this.view.observer; r.ignore(() => { this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : ""; var t = y.chrome || y.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0; this.sync(this.view, t), this.flags &= -8, t && (t.written || r.selectionRange.focusNode != t.node) && (this.forceSelection = !0), this.dom.style.height = "" }), this.markedForComposition.forEach(t => t.flags &= -9); var n = []; if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (var s of this.children) s instanceof ai && s.widget instanceof lr && n.push(s.dom); r.updateGaps(n) } updateChildren(t, e, h) { var c = h ? h.range.addToSet(t.slice()) : t, d = this.childCursor(e); for (let l = c.length - 1; ; l--) { var O = 0 <= l ? c[l] : null; if (!O) break; let { fromA: t, toA: e, fromB: i, toB: r } = O, n, s, o, a; h && h.range.fromB < r && h.range.toB > i ? (O = fi.build(this.view.state.doc, i, h.range.fromB, this.decorations, this.dynamicDecorationMap), f = fi.build(this.view.state.doc, h.range.toB, r, this.decorations, this.dynamicDecorationMap), s = O.breakAtStart, o = O.openStart, a = f.openEnd, u = this.compositionView(h), f.breakAtStart ? u.breakAfter = 1 : f.content.length && u.merge(u.length, u.length, f.content[0], !1, f.openStart, 0) && (u.breakAfter = f.content[0].breakAfter, f.content.shift()), O.content.length && u.merge(0, 0, O.content[O.content.length - 1], !0, 0, O.openEnd) && O.content.pop(), n = O.content.concat(u).concat(f.content)) : { content: n, breakAtStart: s, openStart: o, openEnd: a } = fi.build(this.view.state.doc, i, r, this.decorations, this.dynamicDecorationMap); var { i: O, off: u } = d.findPos(e, 1), { i: f, off: p } = d.findPos(t, -1); Ee(this, f, p, O, u, n, s, o, a) } h && this.fixCompositionDOM(h) } compositionView(t) { let e = new Fe(t.text.nodeValue); e.flags |= 8; for (var { deco: i } of t.marks) e = new He(i, [e], e.length); t = new oi; return t.append(e, 0), t } fixCompositionDOM(e) { var i = (t, e) => { e.flags |= 8 | (e.children.some(t => 7 & t.flags) ? 1 : 0), this.markedForComposition.add(e); var i = b.get(t); i && i != e && (i.dom = null), e.setDOM(t) }; let r = this.childPos(e.range.fromB, 1), n = this.children[r.i]; i(e.line, n); for (let t = e.marks.length - 1; -1 <= t; t--)r = n.childPos(r.off, 1), n = n.children[r.i], i(0 <= t ? e.marks[t].node : e.text, n) } updateSelection(t = !1, e = !1) { !t && this.view.observer.selectionRange.focusNode || this.view.observer.readSelectionRange(); let a = this.view.root.activeElement, i = a == this.dom, l = !i && ye(this.dom, this.view.observer.selectionRange) && !(a && this.dom.contains(a)); if (i || e || l) { let e = this.forceSelection, r = (this.forceSelection = !1, this.view.state.selection.main), n = this.moveToLine(this.domAtPos(r.anchor)), s = r.empty ? n : this.moveToLine(this.domAtPos(r.head)); if (y.gecko && r.empty && !this.hasComposition && 1 == (t = n).node.nodeType && t.node.firstChild && (0 == t.offset || "false" == t.node.childNodes[t.offset - 1].contentEditable) && (t.offset == t.node.childNodes.length || "false" == t.node.childNodes[t.offset].contentEditable)) { let t = document.createTextNode(""); this.view.observer.ignore(() => n.node.insertBefore(t, n.node.childNodes[n.offset] || null)), n = s = new Me(t, 0), e = !0 } let o = this.view.observer.selectionRange; !e && o.focusNode && (Qe(n.node, n.offset, o.anchorNode, o.anchorOffset) && Qe(s.node, s.offset, o.focusNode, o.focusOffset) || this.suppressWidgetCursorChange(o, r)) || (this.view.observer.ignore(() => { y.android && y.chrome && this.dom.contains(o.focusNode) && ((e, i) => { for (let t = e; t && t != i; t = t.assignedSlot || t.parentNode)if (1 == t.nodeType && "false" == t.contentEditable) return 1 })(o.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 })); var t, e = we(this.view.root); if (e) if (r.empty) y.gecko && (i = n.node, t = n.offset, i = 1 != i.nodeType ? 0 : (t && "false" == i.childNodes[t - 1].contentEditable ? 1 : 0) | (t < i.childNodes.length && "false" == i.childNodes[t].contentEditable ? 2 : 0)) && 3 != i && (t = cr(n.node, n.offset, 1 == i ? 1 : -1)) && (n = new Me(t.node, t.offset)), e.collapse(n.node, n.offset), null != r.bidiLevel && void 0 !== e.caretBidiLevel && (e.caretBidiLevel = r.bidiLevel); else if (e.extend) { e.collapse(n.node, n.offset); try { e.extend(s.node, s.offset) } catch (t) { } } else { var i = document.createRange(); r.anchor > r.head && ([n, s] = [s, n]), i.setEnd(s.node, s.offset), i.setStart(n.node, n.offset), e.removeAllRanges(), e.addRange(i) } l && this.view.root.activeElement == this.dom && (this.dom.blur(), a) && a.focus() }), this.view.observer.setSelectionRange(n, s)), this.impreciseAnchor = n.precise ? null : new Me(o.anchorNode, o.anchorOffset), this.impreciseHead = s.precise ? null : new Me(o.focusNode, o.focusOffset) } } suppressWidgetCursorChange(t, e) { return this.hasComposition && e.empty && Qe(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head } enforceCursorAssoc() { var t, e, i, r, n, s, o; this.hasComposition || (t = this.view, e = t.state.selection.main, i = we(t.root), { anchorNode: r, anchorOffset: n } = t.observer.selectionRange, i && e.empty && e.assoc && i.modify && (o = oi.find(this, e.head)) && (s = o.posAtStart, e.head == s || e.head == s + o.length || (s = this.coordsAt(e.head, -1), o = this.coordsAt(e.head, 1), !s) || !o || s.bottom > o.top || (s = this.domAtPos(e.head + e.assoc), i.collapse(s.node, s.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange(), o = t.observer.selectionRange, t.docView.posFromDOM(o.anchorNode, o.anchorOffset) != e.from && i.collapse(r, n)))) } moveToLine(e) { let i = this.dom, r; if (e.node != i) return e; for (let t = e.offset; !r && t < i.childNodes.length; t++) { var n = b.get(i.childNodes[t]); n instanceof oi && (r = n.domAtPos(0)) } for (let t = e.offset - 1; !r && 0 <= t; t--) { var s = b.get(i.childNodes[t]); s instanceof oi && (r = s.domAtPos(s.length)) } return r ? new Me(r.node, r.offset, !0) : e } nearest(e) { for (let t = e; t;) { var i = b.get(t); if (i && i.rootView == this) return i; t = t.parentNode } return null } posFromDOM(t, e) { var i = this.nearest(t); if (i) return i.localPosFromDOM(t, e) + i.posAtStart; throw new RangeError("Trying to find position for a DOM position outside of the document") } domAtPos(t) { let { i: e, off: i } = this.childCursor().findPos(t, -1); for (; e < this.children.length - 1;) { var r = this.children[e]; if (i < r.length || r instanceof oi) break; e++, i = 0 } return this.children[e].domAtPos(i) } coordsAt(i, r) { let n = null, s = 0; for (let t = this.length, e = this.children.length - 1; 0 <= e; e--) { var o = this.children[e], a = t - o.breakAfter, l = a - o.length; if (a < i) break; l <= i && (l < i || o.covers(-1)) && (i < a || o.covers(1)) && (!n || o instanceof oi && !(n instanceof oi && 0 <= r)) && (n = o, s = l), t = l } return n ? n.coordsAt(i - s, r) : null } coordsForChar(t) { let { i: e, off: i } = this.childPos(t, 1), r = this.children[e]; if (r instanceof oi) { for (; r.children.length;) { let { i: t, off: e } = r.childPos(i, 1); for (; ; t++) { if (t == r.children.length) return null; if ((r = r.children[t]).length) break } i = e } if (r instanceof Fe) { t = O(r.text, i); if (t != i) { var n = Re(r.dom, i, t).getClientRects(); for (let t = 0; t < n.length; t++) { var s = n[t]; if (t == n.length - 1 || s.top < s.bottom && s.left < s.right) return s } } } } return null } measureVisibleLineHeights(t) { var i = [], { from: r, to: n } = t, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1; let a = -1, l = this.view.textDirection == k.LTR; for (let t = 0, e = 0; e < this.children.length; e++) { var h, c, d = this.children[e], O = t + d.length; if (n < O) break; t >= r && (c = d.dom.getBoundingClientRect(), i.push(c.height), o) && (h = (h = d.dom.lastChild) ? Se(h) : []).length && (h = h[h.length - 1], (c = l ? h.right - c.left : c.right - h.left) > a) && (a = c, this.minWidth = s, this.minWidthFrom = t, this.minWidthTo = O), t = O + d.breakAfter } return i } textDirectionAt(t) { t = this.childPos(t, 1).i; return "rtl" == getComputedStyle(this.children[t].dom).direction ? k.RTL : k.LTR } measureTextSize() { for (var t of this.children) if (t instanceof oi) { t = t.measureTextSize(); if (t) return t } let e = document.createElement("div"), i, r, n; return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => { this.dom.appendChild(e); var t = Se(e.firstChild)[0]; i = e.getBoundingClientRect().height, r = t ? t.width / 27 : 7, n = t ? t.height : i, e.remove() }), { lineHeight: i, charWidth: r, textHeight: n } } childCursor(t = this.length) { let e = this.children.length; return e && (t -= this.children[--e].length), new je(this.children, t, e) } computeBlockGapDeco() { var i = [], r = this.view.viewState; for (let t = 0, e = 0; ; e++) { var n, s = e == r.viewports.length ? null : r.viewports[e], o = s ? s.from - 1 : this.length; if (o > t && (n = (r.lineBlockAt(o).bottom - r.lineBlockAt(t).top) / this.view.scaleY, i.push(S.replace({ widget: new lr(n), block: !0, inclusive: !0, isBlockGap: !0 }).range(t, o))), !s) break; t = s.to + 1 } return S.set(i) } updateDeco() { var e = this.view.state.facet(Hi).map((t, e) => (this.dynamicDecorationMap[e] = "function" == typeof t) ? t(this.view) : t); let r = !1, t = this.view.state.facet(Ji).map((t, e) => { var i = "function" == typeof t; return i && (r = !0), i ? t(this.view) : t }); t.length && (this.dynamicDecorationMap[e.length] = r, e.push(w.join(t))); for (let t = e.length; t < e.length + 3; t++)this.dynamicDecorationMap[t] = !1; return this.decorations = [...e, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco] } scrollIntoView(i) { if (i.isSnapshot) r = this.view.viewState.lineBlockAt(i.range.head), this.view.scrollDOM.scrollTop = r.top - i.yMargin, this.view.scrollDOM.scrollLeft = i.xMargin; else { var r = i.range; let t = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), e; if (t) { !r.empty && (e = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (t = { left: Math.min(t.left, e.left), top: Math.min(t.top, e.top), right: Math.max(t.right, e.right), bottom: Math.max(t.bottom, e.bottom) }); var l, h, n = rr(this.view), n = { left: t.left - n.left, top: t.top - n.top, right: t.right + n.right, bottom: t.bottom + n.bottom }, { offsetWidth: s, offsetHeight: o } = this.view.scrollDOM, c = this.view.scrollDOM, d = n, O = r.head < r.anchor ? -1 : 1, u = i.x, f = i.y, p = Math.max(Math.min(i.xMargin, s), -s), m = Math.max(Math.min(i.yMargin, o), -o), g = this.view.textDirection == k.LTR, v = c.ownerDocument, w = v.defaultView || window; for (let o = c, a = !1; o && !a;)if (1 == o.nodeType) { let t, e = o == v.body, i = 1, r = 1; if (e) t = { left: 0, right: w.innerWidth, top: 0, bottom: w.innerHeight }; else { if (/^(fixed|sticky)$/.test(getComputedStyle(o).position) && (a = !0), o.scrollHeight <= o.clientHeight && o.scrollWidth <= o.clientWidth) { o = o.assignedSlot || o.parentNode; continue } var b = o.getBoundingClientRect(); ({ scaleX: i, scaleY: r } = Ze(o, b)), t = { left: b.left, right: b.left + o.clientWidth * i, top: b.top, bottom: b.top + o.clientHeight * r } } let n = 0, s = 0; if ("nearest" == f ? d.top < t.top ? (s = -(t.top - d.top + m), 0 < O && d.bottom > t.bottom + s && (s = d.bottom - t.bottom + s + m)) : d.bottom > t.bottom && (s = d.bottom - t.bottom + m, O < 0) && d.top - s < t.top && (s = -(t.top + s - d.top + m)) : (b = d.bottom - d.top, l = t.bottom - t.top, l = "center" == f && b <= l ? d.top + b / 2 - l / 2 : "start" == f || "center" == f && O < 0 ? d.top - m : d.bottom - l + m, s = l - t.top), "nearest" == u ? d.left < t.left ? (n = -(t.left - d.left + p), 0 < O && d.right > t.right + n && (n = d.right - t.right + n + p)) : d.right > t.right && (n = d.right - t.right + p, O < 0) && d.left < t.left + n && (n = -(t.left + n - d.left + p)) : (l = "center" == u ? d.left + (d.right - d.left) / 2 - (t.right - t.left) / 2 : "start" == u == g ? d.left - p : d.right - (t.right - t.left) + p, n = l - t.left), n || s) if (e) w.scrollBy(n, s); else { let t = 0, e = 0; s && (h = o.scrollTop, o.scrollTop += s / r, e = (o.scrollTop - h) * r), n && (h = o.scrollLeft, o.scrollLeft += n / i, t = (o.scrollLeft - h) * i), d = { left: d.left - t, top: d.top - e, right: d.right - t, bottom: d.bottom - e }, t && Math.abs(t - n) < 1 && (u = "nearest"), e && Math.abs(e - s) < 1 && (f = "nearest") } if (e) break; o = o.assignedSlot || o.parentNode } else { if (11 != o.nodeType) break; o = o.host } } } } }; var lr = class extends Ne { constructor(t) { super(), this.height = t } toDOM() { var t = document.createElement("div"); return t.className = "cm-gap", this.updateDOM(t), t } eq(t) { return t.height == this.height } updateDOM(t) { return t.style.height = this.height + "px", !0 } get editable() { return !0 } get estimatedHeight() { return this.height } }; function hr(t, e) { t = t.observer.selectionRange, t = t.focusNode && cr(t.focusNode, t.focusOffset, 0); return t ? { from: e = e - t.offset, to: e + t.node.nodeValue.length, node: t.node } : null } function cr(i, r, n) { if (n <= 0) for (let t = i, e = r; ;) { if (3 == t.nodeType) return { node: t, offset: e }; if (!(1 == t.nodeType && 0 < e)) break; t = t.childNodes[e - 1], e = $e(t) } if (0 <= n) for (let t = i, e = r; ;) { if (3 == t.nodeType) return { node: t, offset: e }; if (!(1 == t.nodeType && e < t.childNodes.length && 0 <= n)) break; t = t.childNodes[e], e = 0 } return null } var dr = class { constructor() { this.changes = [] } compareRange(t, e) { ui(t, e, this.changes) } comparePoint(t, e) { ui(t, e, this.changes) } }; function Or(t, e) { return t.top < e.bottom - 1 && t.bottom > e.top + 1 } function ur(t, e) { return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t } function fr(t, e) { return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t } function pr(t, r, n) { let s, o, a, l, h = !1, c, d, O, u; for (let i = t.firstChild; i; i = i.nextSibling) { var f = Se(i); for (let e = 0; e < f.length; e++) { let t = f[e]; o && Or(o, t) && (t = ur(fr(t, o.bottom), o.top)); m = r; m = (g = t).left > m ? g.left - m : Math.max(0, m - g.right), g = (g = n, (p = t).top > g ? p.top - g : Math.max(0, g - p.bottom)); if (0 == m && 0 == g) return (3 == i.nodeType ? mr : pr)(i, r, n); (!s || l > g || l == g && a > m) && (s = i, o = t, a = m, p = (l = g) ? n < t.top ? -1 : 1 : m ? r < t.left ? -1 : 1 : 0, h = !p || (0 < p ? e < f.length - 1 : 0 < e)), 0 == m ? n > t.bottom && (!O || O.bottom < t.bottom) ? (c = i, O = t) : n < t.top && (!u || u.top > t.top) && (d = i, u = t) : O && Or(O, t) ? O = fr(O, t.bottom) : u && Or(u, t) && (u = ur(u, t.top)) } } var p, m, g, e; return O && O.bottom >= n ? (s = c, o = O) : u && u.top <= n && (s = d, o = u), s ? (e = Math.max(o.left, Math.min(o.right, r)), 3 == s.nodeType ? mr(s, e, n) : h && "false" != s.contentEditable ? pr(s, e, n) : { node: t, offset: Array.prototype.indexOf.call(t.childNodes, s) + (r >= (o.left + o.right) / 2 ? 1 : 0) }) : { node: t, offset: 0 } } function mr(r, n, e) { var t = r.nodeValue.length; let s = -1, o = 1e9, a = 0; for (let i = 0; i < t; i++) { var l = Re(r, i, i + 1).getClientRects(); for (let t = 0; t < l.length; t++) { var h = l[t]; if (h.top != h.bottom) { a = a || n - h.left; var c = (e < h.top ? h.top - e : e - h.bottom) - 1; if (h.left - 1 <= n && h.right + 1 >= n && c < o) { let t = n >= (h.left + h.right) / 2, e = t; if ((y.chrome || y.gecko) && Re(r, i).getBoundingClientRect().left == h.right && (e = !t), c <= 0) return { node: r, offset: i + (e ? 1 : 0) }; s = i + (e ? 1 : 0), o = c } } } } return { node: r, offset: -1 < s ? s : 0 < a ? r.nodeValue.length : 0 } } function gr(i, t, r, n = -1) { var e = i.contentDOM.getBoundingClientRect(), s = e.top + i.viewState.paddingTop; let o, a = i.viewState.docHeight, { x: l, y: h } = t, c = h - s; if (c < 0) return 0; if (c > a) return i.state.doc.length; for (let t = i.viewState.heightOracle.textHeight / 2, e = !1; (o = i.elementAtHeight(c)).type != li.Text;)for (; !(0 <= (c = 0 < n ? o.bottom + t : o.top - t) && c <= a);) { if (e) return r ? null : 0; e = !0, n = -n } h = s + c; s = o.from; if (s < i.viewport.from) return 0 == i.viewport.from ? 0 : r ? null : vr(i, e, o, l, h); if (s > i.viewport.to) return i.viewport.to == i.state.doc.length ? i.state.doc.length : r ? null : vr(i, e, o, l, h); var d = i.dom.ownerDocument, O = i.root.elementFromPoint ? i.root : d; let u = O.elementFromPoint(l, h); (u = u && !i.contentDOM.contains(u) ? null : u) || (l = Math.max(e.left + 1, Math.min(e.right - 1, l)), (u = O.elementFromPoint(l, h)) && !i.contentDOM.contains(u) && (u = null)); let f, p = -1; if (u && 0 != (null == (e = i.docView.nearest(u)) ? void 0 : e.isEditable) && (d.caretPositionFromPoint ? (O = d.caretPositionFromPoint(l, h)) && ({ offsetNode: f, offset: p } = O) : d.caretRangeFromPoint && (e = d.caretRangeFromPoint(l, h)) && ({ startContainer: f, startOffset: p } = e, !i.contentDOM.contains(f) || y.safari && ((e, t, i) => { let r; if (3 == e.nodeType && t == (r = e.nodeValue.length)) { for (let t = e.nextSibling; t; t = t.nextSibling)if (1 != t.nodeType || "BR" != t.nodeName) return; return Re(e, r - 1, r).getBoundingClientRect().left > i } })(f, p, l) || y.chrome && ((e, t, i) => { if (0 == t) { for (let t = e; ;) { var r = t.parentNode; if (!r || 1 != r.nodeType || r.firstChild != t) return; if (r.classList.contains("cm-line")) break; t = r } return t = (1 == e.nodeType ? e : Re(e, 0, Math.max(e.nodeValue.length, 1))).getBoundingClientRect(), 5 < i - t.left } })(f, p, l)) && (f = void 0)), !f || !i.docView.dom.contains(f)) { O = oi.find(i.docView, s); if (!O) return c > o.top + o.height / 2 ? o.to : o.from; ({ node: f, offset: p } = pr(O.dom, l, h)) } d = i.docView.nearest(f); return d ? d.isWidget && 1 == (null == (e = d.dom) ? void 0 : e.nodeType) ? (s = d.dom.getBoundingClientRect(), t.y < s.top || t.y <= s.bottom && t.x <= (s.left + s.right) / 2 ? d.posAtStart : d.posAtEnd) : d.localPosFromDOM(f, p) + d.posAtStart : null } function vr(t, e, i, r, n) { let s = Math.round((r - e.left) * t.defaultCharacterWidth); t.lineWrapping && i.height > 1.5 * t.defaultLineHeight && (r = t.viewState.heightOracle.textHeight, e = Math.floor((n - i.top - .5 * (t.defaultLineHeight - r)) / r), s += e * t.viewState.heightOracle.lineLength); n = t.state.sliceDoc(i.from, i.to); return i.from + ae(n, s, t.state.tabSize) } function wr(t, e) { var i = t.lineBlockAt(e); if (Array.isArray(i.type)) for (var r of i.type) if (r.to > e || r.to == e && (r.to == i.to || r.type == li.Text)) return r; return i } function br(n, t, s, o) { let a = n.state.doc.lineAt(t.head), l = n.bidiSpans(a); var h = n.textDirectionAt(a.from); for (let i = t, r = null; ;) { let t = ((t, e, i, r, n) => { let s, o = r.head - t.from, a = Ti.find(e, o, null != (s = r.bidiLevel) ? s : -1, r.assoc), l = e[a], h = l.side(n, i); if (o == h) { r = a += n ? 1 : -1; if (r < 0 || r >= e.length) return null; l = e[a = r], o = l.side(!n, i), h = l.side(n, i) } let c = O(t.text, o, l.forward(n, i)); return (c < l.from || c > l.to) && (c = h), Ai = t.text.slice(Math.min(o, c), Math.max(o, c)), (r = a == (n ? e.length - 1 : 0) ? null : e[a + (n ? 1 : -1)]) && c == h && r.level + (n ? 0 : 1) < l.level ? g.cursor(r.side(!n, i) + t.from, r.forward(n, i) ? 1 : -1, r.level) : g.cursor(c + t.from, l.forward(n, i) ? -1 : 1, l.level) })(a, l, h, i, s), e = Ai; if (!t) { if (a.number == (s ? n.state.doc.lines : 1)) return i; e = "\n", a = n.state.doc.line(a.number + (s ? 1 : -1)), l = n.bidiSpans(a), t = n.visualLineSide(a, !s) } if (r) { if (!r(e)) return i } else { if (!o) return t; r = o(e) } i = t } } function yr(t, s, o) { for (; ;) { let n = 0; for (var e of t) e.between(s - 1, s + 1, (t, e, i) => { var r; t < s && s < e && (r = n || o || (s - t < e - s ? -1 : 1), s = r < 0 ? t : e, n = r) }); if (!n) return s } } function Sr(e, t, i) { t = yr(e.state.facet(Ki).map(t => t(e)), i.from, t.head > i.from ? -1 : 1); return t == i.from ? i : g.cursor(t, t < i.from ? 1 : -1) } var Qr = class { setSelectionOrigin(t) { this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now() } constructor(t) { this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, y.safari && t.contentDOM.addEventListener("input", () => null), y.gecko && (t = t.contentDOM.ownerDocument, Ur.has(t) || (Ur.add(t), t.addEventListener("copy", () => { }), t.addEventListener("cut", () => { }))) } handleEvent(t) { !((i, r) => { if (r.bubbles) { if (r.defaultPrevented) return; for (let t = r.target, e; t != i.contentDOM; t = t.parentNode)if (!t || 11 == t.nodeType || (e = b.get(t)) && e.ignoreEvent(r)) return } return 1 })(this.view, t) || this.ignoreDuringComposition(t) || "keydown" == t.type && this.keydown(t) || this.runHandlers(t.type, t) } runHandlers(t, e) { t = this.handlers[t]; if (t) { for (var i of t.observers) i(this.view, e); for (var r of t.handlers) { if (e.defaultPrevented) break; if (r(this.view, e)) { e.preventDefault(); break } } } } ensureHandlers(t) { var e, i, r = (t => { let e = Object.create(null); function i(t) { return e[t] || (e[t] = { observers: [], handlers: [] }) } for (var r of t) { var n = r.spec; if (n && n.domEventHandlers) for (var s in n.domEventHandlers) { var o = n.domEventHandlers[s]; o && i(s).handlers.push(xr(r.value, o)) } if (n && n.domEventObservers) for (var a in n.domEventObservers) { var l = n.domEventObservers[a]; l && i(a).observers.push(xr(r.value, l)) } } for (var h in Cr) i(h).handlers.push(Cr[h]); for (var c in Xr) i(c).observers.push(Xr[c]); return e })(t), n = this.handlers, s = this.view.contentDOM; for (e in r) if ("scroll" != e) { var o = !r[e].handlers.length; let t = n[e]; t && o != !t.handlers.length && (s.removeEventListener(e, this.handleEvent), t = null), t || s.addEventListener(e, this.handleEvent, { passive: o }) } for (i in n) "scroll" == i || r[i] || s.removeEventListener(i, this.handleEvent); this.handlers = r } keydown(e) { if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), 9 == e.keyCode && Date.now() < this.lastEscPress + 2e3) return !0; if (27 != e.keyCode && Pr.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), y.android && y.chrome && !e.synthetic && (13 == e.keyCode || 8 == e.keyCode)) return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0; let t; return !y.ios || e.synthetic || e.altKey || e.metaKey || !((t = kr.find(t => t.keyCode == e.keyCode)) && !e.ctrlKey || -1 < $r.indexOf(e.key) && e.ctrlKey && !e.shiftKey) ? (229 != e.keyCode && this.view.observer.forceFlush(), !1) : (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) } flushIOSKey() { var t = this.pendingIOSKey; return !!t && (this.pendingIOSKey = void 0, Ye(this.view.contentDOM, t.key, t.keyCode)) } ignoreDuringComposition(t) { return !!/^key/.test(t.type) && (0 < this.composing || !!(y.safari && !y.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && !(this.compositionPendingKey = !1)) } startMouseSelection(t) { this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t } update(t) { this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0) } destroy() { this.mouseSelection && this.mouseSelection.destroy() } }; function xr(i, r) { return (e, t) => { try { return r.call(i, t, e) } catch (t) { Bi(e.state, t) } } } var kr = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], $r = "dthko", Pr = [16, 17, 18, 20, 91, 92, 224, 225]; function Zr(t) { return .7 * Math.max(0, t) + 8 } var Tr = class { constructor(e, t, i, r) { this.view = e, this.startEvent = t, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = (e => { var i = e.ownerDocument; for (let t = e.parentNode; t && t != i.body;)if (1 == t.nodeType) { if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth) return t; t = t.assignedSlot || t.parentNode } else { if (11 != t.nodeType) break; t = t.host } return null })(e.contentDOM), this.atoms = e.state.facet(Ki).map(t => t(e)); i = e.contentDOM.ownerDocument; i.addEventListener("mousemove", this.move = this.move.bind(this)), i.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(v.allowMultipleSelections) && ((t, e) => (t = t.state.facet(Ri)).length ? t[0](e) : y.mac ? e.metaKey : e.ctrlKey)(e, t), this.dragging = !(!((t, e) => { var i = t.state.selection.main; if (!i.empty) { i = we(t.root); if (!i || 0 == i.rangeCount) return 1; var r = i.getRangeAt(0).getClientRects(); for (let t = 0; t < r.length; t++) { var n = r[t]; if (n.left <= e.clientX && n.right >= e.clientX && n.top <= e.clientY && n.bottom >= e.clientY) return 1 } } })(e, t) || 1 != Dr(t)) && null } start(t) { !1 === this.dragging && this.select(t) } move(i) { var r; if (0 == i.buttons) return this.destroy(); if (!(this.dragging || null == this.dragging && (r = this.startEvent, n = i, Math.max(Math.abs(r.clientX - n.clientX), Math.abs(r.clientY - n.clientY)) < 10))) { this.select(this.lastEvent = i); let t = 0, e = 0; var n = (null == (r = this.scrollParent) ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, s = rr(this.view); i.clientX - s.left <= n.left + 6 ? t = -Zr(n.left - i.clientX) : i.clientX + s.right >= n.right - 6 && (t = Zr(i.clientX - n.right)), i.clientY - s.top <= n.top + 6 ? e = -Zr(n.top - i.clientY) : i.clientY + s.bottom >= n.bottom - 6 && (e = Zr(i.clientY - n.bottom)), this.setScrollSpeed(t, e) } } up(t) { null == this.dragging && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy() } destroy() { this.setScrollSpeed(0, 0); var t = this.view.contentDOM.ownerDocument; t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null } setScrollSpeed(t, e) { this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : -1 < this.scrolling && (clearInterval(this.scrolling), this.scrolling = -1) } scroll() { this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), !1 === this.dragging && this.select(this.lastEvent) } skipAtoms(r) { let n = null; for (let i = 0; i < r.ranges.length; i++) { let t = r.ranges[i], e = null; var s, o; t.empty ? (s = yr(this.atoms, t.from, 0)) != t.from && (e = g.cursor(s, -1)) : (s = yr(this.atoms, t.from, -1), o = yr(this.atoms, t.to, 1), s == t.from && o == t.to || (e = g.range(t.from == t.anchor ? s : o, t.from == t.head ? s : o))), e && ((n = n || r.ranges.slice())[i] = e) } return n ? g.create(n, r.mainIndex) : r } select(t) { var e = this.view, t = this.skipAtoms(this.style.get(t, this.extend, this.multiple)); !this.mustSelect && t.eq(e.state.selection, !1 === this.dragging) || this.view.dispatch({ selection: t, userEvent: "select.pointer" }), this.mustSelect = !1 } update(t) { this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20) } }; var Cr = Object.create(null), Xr = Object.create(null), Ar = y.ie && y.ie_version < 15 || y.ios && y.webkit_version < 604; function Rr(t, n) { let s = t.state, e, o = 1, a = s.toText(n), l = a.lines == s.selection.ranges.length; if (null != Br && s.selection.ranges.every(t => t.empty) && Br == a.toString()) { let r = -1; e = s.changeByRange(t => { var e = s.doc.lineAt(t.from); if (e.from == r) return { range: t }; r = e.from; var i = s.toText((l ? a.line(o++).text : n) + s.lineBreak); return { changes: { from: e.from, insert: i }, range: g.cursor(t.from + i.length) } }) } else e = l ? s.changeByRange(t => { var e = a.line(o++); return { changes: { from: t.from, to: t.to, insert: e.text }, range: g.cursor(t.from + e.length) } }) : s.replaceSelection(a); t.dispatch(e, { userEvent: "input.paste", scrollIntoView: !0 }) } function Yr(i, r, n, s) { if (1 == s) return g.cursor(r, n); if (2 == s) { var [s, n, o = 1] = [i.state, r, n]; var a = s.charCategorizer(n), l = s.doc.lineAt(n), s = n - l.from; if (0 == l.length) return g.cursor(n); 0 == s ? o = 1 : s == l.length && (o = -1); let t = s, e = s; o < 0 ? t = O(l.text, s, !1) : e = O(l.text, s); for (var h = a(l.text.slice(t, e)); 0 < t;) { var c = O(l.text, t, !1); if (a(l.text.slice(c, t)) != h) break; t = c } for (; e < l.length;) { var d = O(l.text, e); if (a(l.text.slice(e, d)) != h) break; e = d } return g.range(t + l.from, e + l.from) } { n = oi.find(i.docView, r), o = i.state.doc.lineAt(n ? n.posAtEnd : r); let t = n ? n.posAtStart : o.from, e = n ? n.posAtEnd : o.to; return e < i.state.doc.length && e == o.to && e++, g.range(t, e) } } Xr.scroll = t => { t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft }, Cr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), 27 == e.keyCode && (t.inputState.lastEscPress = Date.now()), !1), Xr.touchstart = (t, e) => { t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer") }, Xr.touchmove = t => { t.inputState.setSelectionOrigin("select.pointer") }, Cr.mousedown = (e, i) => { if (e.observer.flush(), !(e.inputState.lastTouchTime > Date.now() - 2e3)) { let t = null; for (var r of e.state.facet(Wi)) if (t = r(e, i)) break; if (t = t || 0 != i.button ? t : ((a, t) => { let l = Mr(a, t), h = Dr(t), c = a.state.selection; return { update(t) { t.docChanged && (l.pos = t.changes.mapPos(l.pos), c = c.map(t.changes)) }, get(t, e, i) { let r = Mr(a, t), n, s = Yr(a, r.pos, r.bias, h); var o; return l.pos == r.pos || e || (t = Yr(a, l.pos, l.bias, h), o = Math.min(t.from, s.from), t = Math.max(t.to, s.to), s = o < s.from ? g.range(o, t) : g.range(t, o)), e ? c.replaceRange(c.main.extend(s.from, s.to)) : i && 1 == h && 1 < c.ranges.length && (n = ((e, i) => { for (let t = 0; t < e.ranges.length; t++) { var { from: r, to: n } = e.ranges[t]; if (r <= i && i <= n) return g.create(e.ranges.slice(0, t).concat(e.ranges.slice(t + 1)), e.mainIndex == t ? 0 : e.mainIndex - (e.mainIndex > t ? 1 : 0)) } return null })(c, r.pos)) ? n : i ? c.addRange(s) : g.create([s]) } } })(e, i)) { var n = !e.hasFocus, n = (e.inputState.startMouseSelection(new Tr(e, i, t, n)), n && e.observer.ignore(() => Ae(e.contentDOM)), e.inputState.mouseSelection); if (n) return n.start(i), !1 === n.dragging } } return !1 }; var Wr = (t, e) => t >= e.top && t <= e.bottom, Vr = (t, e, i) => Wr(e, i) && t >= i.left && t <= i.right; function Mr(t, e) { var i, r, n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1); return { pos: n, bias: (t = t, n = n, i = e.clientX, e = e.clientY, (t = oi.find(t.docView, n)) && 0 != (n = n - t.posAtStart) && (n == t.length || (r = t.coordsAt(n, -1)) && Vr(i, e, r) || (!(t = t.coordsAt(n, 1)) || !Vr(i, e, t)) && r && Wr(e, r)) ? -1 : 1) } } var qr = y.ie && y.ie_version <= 11, _r = null, jr = 0, Er = 0; function Dr(t) { var e, i; return qr ? (e = _r, i = Er, _r = t, Er = Date.now(), jr = !e || i > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (jr + 1) % 3 : 1) : t.detail } function zr(t, e, i, r) { var n, s; i && (n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), s = t.inputState.draggedContent, e = r && s && (r = e, (e = (e = t).state.facet(Yi)).length ? e[0](r) : y.mac ? !r.altKey : !r.ctrlKey) ? { from: s.from, to: s.to } : null, r = { from: n, insert: i }, s = t.state.changes(e ? [e, r] : r), t.focus(), t.dispatch({ changes: s, selection: { anchor: s.mapPos(n, -1), head: s.mapPos(n, 1) }, userEvent: e ? "move.drop" : "input.drop" }), t.inputState.draggedContent = null) } Cr.dragstart = (t, e) => { let i = t.state.selection.main; var r, n = (e.target.draggable && (r = t.docView.nearest(e.target)) && r.isWidget && (r = (n = r.posAtStart) + r.length, n >= i.to || r <= i.from) && (i = g.range(n, r)), t).inputState; return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = i, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(i.from, i.to)), e.dataTransfer.effectAllowed = "copyMove"), !1 }, Cr.dragend = t => (t.inputState.draggedContent = null, !1), Cr.drop = (e, n) => { if (!n.dataTransfer) return !1; if (e.state.readOnly) return !0; let s = n.dataTransfer.files; if (s && s.length) { let i = Array(s.length), t = 0, r = () => { ++t == s.length && zr(e, n, i.filter(t => null != t).join(e.state.lineBreak), !1) }; for (let e = 0; e < s.length; e++) { let t = new FileReader; t.onerror = r, t.onload = () => { /[\x00-\x08\x0e-\x1f]{2}/.test(t.result) || (i[e] = t.result), r() }, t.readAsText(s[e]) } return !0 } var t = n.dataTransfer.getData("Text"); return !!t && (zr(e, n, t, !0), !0) }, Cr.paste = (t, e) => { if (t.state.readOnly) return !0; t.observer.flush(); e = Ar ? null : e.clipboardData; if (e) return Rr(t, e.getData("text/plain") || e.getData("text/uri-text")), !0; var i = t, e = i.dom.parentNode; if (e) { let t = e.appendChild(document.createElement("textarea")); t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => { i.focus(), t.remove(), Rr(i, t.value) }, 50) } return !1 }; var Br = null, Gr = (Cr.copy = Cr.cut = (t, e) => { var { text: i, ranges: r, linewise: n } = (e => { let i = [], r = [], n = !1; for (var t of e.selection.ranges) t.empty || (i.push(e.sliceDoc(t.from, t.to)), r.push(t)); if (!i.length) { let t = -1; for (var { from: s } of e.selection.ranges) { s = e.doc.lineAt(s); s.number > t && (i.push(s.text), r.push({ from: s.from, to: Math.min(e.doc.length, s.to + 1) })), t = s.number } n = !0 } return { text: i.join(e.lineBreak), ranges: r, linewise: n } })(t.state); if (i || n) { Br = n ? i : null, "cut" != e.type || t.state.readOnly || t.dispatch({ changes: r, scrollIntoView: !0, userEvent: "delete.cut" }); n = Ar ? null : e.clipboardData; if (n) return n.clearData(), n.setData("text/plain", i), !0; var s = t, r = i, e = s.dom.parentNode; if (e) { let t = e.appendChild(document.createElement("textarea")); t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.value = r, t.focus(), t.selectionEnd = r.length, t.selectionStart = 0, setTimeout(() => { t.remove(), s.focus() }, 50) } } return !1 }, At.define()); function Ir(t, e) { var i, r = []; for (i of t.facet(_i)) { var n = i(t, e); n && r.push(n) } return r ? t.update({ effects: r, annotations: Gr.of(!0) }) : null } function Nr(e) { setTimeout(() => { var t = e.hasFocus; t != e.inputState.notifiedFocused && ((t = Ir(e.state, t)) ? e.dispatch(t) : e.update([])) }, 10) } Xr.focus = t => { t.inputState.lastFocusTime = Date.now(), t.scrollDOM.scrollTop || !t.inputState.lastScrollTop && !t.inputState.lastScrollLeft || (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Nr(t) }, Xr.blur = t => { t.observer.clearSelectionRange(), Nr(t) }, Xr.compositionstart = Xr.compositionupdate = t => { null == t.inputState.compositionFirstChange && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0) }, Xr.compositionend = t => { t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = 0 < t.observer.pendingRecords().length, t.inputState.compositionFirstChange = null, y.chrome && y.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => { t.inputState.composing < 0 && t.docView.hasComposition && t.update([]) }, 50) }, Xr.contextmenu = t => { t.inputState.lastContextMenu = Date.now() }, Cr.beforeinput = (i, e) => { let t, r; if (y.chrome && y.android && (r = kr.find(t => t.inputType == e.inputType)) && (i.observer.delayAndroidKey(r.key, r.keyCode), "Backspace" == r.key || "Delete" == r.key)) { let e = (null == (t = window.visualViewport) ? void 0 : t.height) || 0; setTimeout(() => { var t; ((null == (t = window.visualViewport) ? void 0 : t.height) || 0) > e + 10 && i.hasFocus && (i.contentDOM.blur(), i.focus()) }, 100) } return !1 }; var Ur = new Set; var Lr = ["pre-wrap", "normal", "pre-line", "break-spaces"], Fr = class { constructor(t) { this.lineWrapping = t, this.doc = m.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1 } heightForGap(t, e) { let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1; return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * .5) / this.lineLength))), this.lineHeight * i } heightForLine(t) { return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight } setDoc(t) { return this.doc = t, this } mustRefreshForWrapping(t) { return -1 < Lr.indexOf(t) != this.lineWrapping } mustRefreshForHeights(e) { let i = !1; for (let t = 0; t < e.length; t++) { var r = e[t]; r < 0 ? t++ : this.heightSamples[Math.floor(10 * r)] || (i = !0, this.heightSamples[Math.floor(10 * r)] = !0) } return i } refresh(t, e, i, r, n, s) { var t = -1 < Lr.indexOf(t), o = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != t; if (this.lineWrapping = t, this.lineHeight = e, this.charWidth = i, this.textHeight = r, this.lineLength = n, o) { this.heightSamples = {}; for (let t = 0; t < s.length; t++) { var a = s[t]; a < 0 ? t++ : this.heightSamples[Math.floor(10 * a)] = !0 } } return o } }, Hr = class { constructor(t, e) { this.from = t, this.heights = e, this.index = 0 } get more() { return this.index < this.heights.length } }, Jr = class Jf { constructor(t, e, i, r, n) { this.from = t, this.length = e, this.top = i, this.height = r, this._content = n } get type() { return "number" == typeof this._content ? li.Text : Array.isArray(this._content) ? this._content : this._content.type } get to() { return this.from + this.length } get bottom() { return this.top + this.height } get widget() { return this._content instanceof di ? this._content.widget : null } get widgetLineBreaks() { return "number" == typeof this._content ? this._content : 0 } join(t) { var e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]); return new Jf(this.from, this.length + t.length, this.top, this.height + t.height, e) } }, x = (t => (t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t))(x = x || {}), Kr = class Kf { constructor(t, e, i = 2) { this.length = t, this.height = e, this.flags = i } get outdated() { return 0 < (2 & this.flags) } set outdated(t) { this.flags = (t ? 2 : 0) | -3 & this.flags } setHeight(t, e) { this.height != e && (.001 < Math.abs(this.height - e) && (t.heightChanged = !0), this.height = e) } replace(t, e, i) { return Kf.of(i) } decomposeLeft(t, e) { e.push(this) } decomposeRight(t, e) { e.push(this) } applyChanges(o, a, l, h) { let c = this, d = l.doc; for (let s = h.length - 1; 0 <= s; s--) { let { fromA: t, toA: e, fromB: i, toB: r } = h[s], n = c.lineAt(t, x.ByPosNoHeight, l.setDoc(a), 0, 0); var O = n.to >= e ? n : c.lineAt(e, x.ByPosNoHeight, l, 0, 0); for (r += O.to - e, e = O.to; 0 < s && n.from <= h[s - 1].toA;)t = h[s - 1].fromA, i = h[s - 1].fromB, s--, t < n.from && (n = c.lineAt(t, x.ByPosNoHeight, l, 0, 0)); i += n.from - t, t = n.from; O = on.build(l.setDoc(d), o, i, r); c = c.replace(t, e, O) } return c.updateHeight(l, 0) } static empty() { return new en(0, 0) } static of(t) { if (1 == t.length) return t[0]; let e = 0, i = t.length, r = 0, n = 0; for (; ;) { var s; if (e == i) if (r > 2 * n) { var o = t[e - 1]; o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, r -= o.size } else { if (!(n > 2 * r)) break; o = t[i]; o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, n -= o.size } else r < n ? (s = t[e++]) && (r += s.size) : (s = t[--i]) && (n += s.size) } let a = 0; return null == t[e - 1] ? (a = 1, e--) : null == t[e] && (a = 1, i++), new nn(Kf.of(t.slice(0, e)), a, Kf.of(t.slice(i))) } }, tn = (Kr.prototype.size = 1, class extends Kr { constructor(t, e, i) { super(t, e), this.deco = i } blockAt(t, e, i, r) { return new Jr(r, this.length, i, this.height, this.deco || 0) } lineAt(t, e, i, r, n) { return this.blockAt(0, i, r, n) } forEachLine(t, e, i, r, n, s) { t <= n + this.length && n <= e && s(this.blockAt(0, i, r, n)) } updateHeight(t, e = 0, i, r) { return r && r.from <= e && r.more && this.setHeight(t, r.heights[r.index++]), this.outdated = !1, this } toString() { return `block(${this.length})` } }), en = class tp extends tn { constructor(t, e) { super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0 } blockAt(t, e, i, r) { return new Jr(r, this.length, i, this.height, this.breaks) } replace(t, e, i) { let r = i[0]; return 1 == i.length && (r instanceof tp || r instanceof rn && 4 & r.flags) && Math.abs(this.length - r.length) < 10 ? (r instanceof rn ? r = new tp(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : Kr.of(i) } updateHeight(t, e = 0, i = !1, r) { return r && r.from <= e && r.more ? this.setHeight(t, r.heights[r.index++]) : (i || this.outdated) && this.setHeight(t, Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this } toString() { return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})` } }, rn = class ep extends Kr { constructor(t) { super(t, 0) } heightMetrics(t, e) { var i = t.doc.lineAt(e).number, e = t.doc.lineAt(e + this.length).number, r = e - i + 1; let n, s = 0; return t.lineWrapping ? (t = Math.min(this.height, t.lineHeight * r), n = t / r, this.length > 1 + r && (s = (this.height - t) / (this.length - r - 1))) : n = this.height / r, { firstLine: i, lastLine: e, perLine: n, perChar: s } } blockAt(t, e, i, r) { var n, { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(e, r); return e.lineWrapping ? (r = r + Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length), l = a + (r = e.doc.lineAt(r)).length * l, n = Math.max(i, t - l / 2), new Jr(r.from, r.length, n, l, 0)) : (r = Math.max(0, Math.min(o - s, Math.floor((t - i) / a))), { from: n, length: l } = e.doc.line(s + r), new Jr(n, l, i + a * r, a, 0)) } lineAt(t, e, i, r, n) { var s, o; return e == x.ByHeight ? this.blockAt(t, i, r, n) : e == x.ByPosNoHeight ? ({ from: e, to: o } = i.doc.lineAt(t), new Jr(e, o - e, 0, 0, 0)) : ({ firstLine: o, perLine: e, perChar: s } = this.heightMetrics(i, n), t = e + (i = i.doc.lineAt(t)).length * s, o = i.number - o, new Jr(i.from, i.length, Math.max(r, Math.min(r + e * o + s * (i.from - n - o), r + this.height - t)), t, 0)) } forEachLine(i, r, n, s, o, a) { i = Math.max(i, o), r = Math.min(r, o + this.length); var { firstLine: l, perLine: h, perChar: c } = this.heightMetrics(n, o); for (let t = i, e = s; t <= r;) { var d = n.doc.lineAt(t), O = (t == i && (O = d.number - l, e += h * O + c * (i - o - O)), h + c * d.length); a(new Jr(d.from, d.length, e, O, 0)), e += O, t = d.to + 1 } } replace(t, e, i) { var r, e = this.length - e; return 0 < e && ((r = i[i.length - 1]) instanceof ep ? i[i.length - 1] = new ep(r.length + e) : i.push(null, new ep(e - 1))), 0 < t && ((r = i[0]) instanceof ep ? i[0] = new ep(t + r.length) : i.unshift(new ep(t - 1), null)), Kr.of(i) } decomposeLeft(t, e) { e.push(new ep(t - 1), null) } decomposeRight(t, e) { e.push(null, new ep(this.length - t - 1)) } updateHeight(r, n = 0, t = !1, s) { var o = n + this.length; if (s && s.from <= n + this.length && s.more) { let t = [], e = Math.max(n, s.from), i = -1; for (s.from > n && t.push(new ep(s.from - n - 1).updateHeight(r, n)); e <= o && s.more;) { var a = r.doc.lineAt(e).length, l = (t.length && t.push(null), s.heights[s.index++]), l = (-1 == i ? i = l : .001 <= Math.abs(l - i) && (i = -2), new en(a, l)); l.outdated = !1, t.push(l), e += a + 1 } e <= o && t.push(null, new ep(o - e).updateHeight(r, e)); var h = Kr.of(t); return (i < 0 || .001 <= Math.abs(h.height - this.height) || .001 <= Math.abs(i - this.heightMetrics(r, n).perLine)) && (r.heightChanged = !0), h } return (t || this.outdated) && (this.setHeight(r, r.heightForGap(n, n + this.length)), this.outdated = !1), this } toString() { return `gap(${this.length})` } }, nn = class extends Kr { constructor(t, e, i) { super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size } get break() { return 1 & this.flags } blockAt(t, e, i, r) { var n = i + this.left.height; return t < n ? this.left.blockAt(t, e, i, r) : this.right.blockAt(t, e, n, r + this.left.length + this.break) } lineAt(t, e, i, r, n) { var s = r + this.left.height, o = n + this.left.length + this.break, a = e == x.ByHeight ? t < s : t < o, t = a ? this.left.lineAt(t, e, i, r, n) : this.right.lineAt(t, e, i, s, o); return this.break || (a ? t.to < o : t.from > o) ? t : (e = e == x.ByPosNoHeight ? x.ByPosNoHeight : x.ByPos, a ? t.join(this.right.lineAt(o, e, i, s, o)) : this.left.lineAt(o, e, i, r, n).join(t)) } forEachLine(t, e, i, r, n, s) { var o, a = r + this.left.height, l = n + this.left.length + this.break; this.break ? (t < l && this.left.forEachLine(t, e, i, r, n, s), l <= e && this.right.forEachLine(t, e, i, a, l, s)) : (t < (o = this.lineAt(l, x.ByPos, i, r, n)).from && this.left.forEachLine(t, o.from - 1, i, r, n, s), t <= o.to && o.from <= e && s(o), o.to < e && this.right.forEachLine(o.to + 1, e, i, a, l, s)) } replace(t, e, i) { var r = this.left.length + this.break; if (e < r) return this.balanced(this.left.replace(t, e, i), this.right); if (t > this.left.length) return this.balanced(this.left, this.right.replace(t - r, e - r, i)); var n, s = [], r = (0 < t && this.decomposeLeft(t, s), s.length); for (n of i) s.push(n); return 0 < t && sn(s, r - 1), e < this.length && (i = s.length, this.decomposeRight(e, s), sn(s, i)), Kr.of(s) } decomposeLeft(t, e) { let i = this.left.length; if (t <= i) return this.left.decomposeLeft(t, e); e.push(this.left), this.break && t >= ++i && e.push(null), t > i && this.right.decomposeLeft(t - i, e) } decomposeRight(t, e) { var i = this.left.length, r = i + this.break; if (r <= t) return this.right.decomposeRight(t - r, e); t < i && this.left.decomposeRight(t, e), this.break && t < r && e.push(null), e.push(this.right) } balanced(t, e) { return t.size > 2 * e.size || e.size > 2 * t.size ? Kr.of(this.break ? [t, null, e] : [t, e]) : (this.left = t, this.right = e, this.height = t.height + e.height, this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this) } updateHeight(t, e = 0, i = !1, r) { let { left: n, right: s } = this, o = e + n.length + this.break, a = null; return r && r.from <= e + n.length && r.more ? a = n = n.updateHeight(t, e, i, r) : n.updateHeight(t, e, i), r && r.from <= o + s.length && r.more ? a = s = s.updateHeight(t, o, i, r) : s.updateHeight(t, o, i), a ? this.balanced(n, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this) } toString() { return this.left + (this.break ? " " : "-") + this.right } }; function sn(t, e) { let i, r; null == t[e] && (i = t[e - 1]) instanceof rn && (r = t[e + 1]) instanceof rn && t.splice(e - 1, 3, new rn(i.length + 1 + r.length)) } var on = class ip { constructor(t, e) { this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t } get isCovered() { return this.covering && this.nodes[this.nodes.length - 1] == this.covering } span(t, e) { var i, r; -1 < this.lineStart && (i = Math.min(e, this.lineEnd), (r = this.nodes[this.nodes.length - 1]) instanceof en ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new en(i - this.pos, -1)), (this.writtenTo = i) < e) && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1), this.pos = e } point(e, i, r) { if (e < i || r.heightRelevant) { let t = r.widget ? r.widget.estimatedHeight : 0; var n = r.widget ? r.widget.lineBreaks : 0, s = (t < 0 && (t = this.oracle.lineHeight), i - e); r.block ? this.addBlock(new tn(s, t, r)) : (s || n || 5 <= t) && this.addLineDeco(t, n, s) } else e < i && this.span(e, i); -1 < this.lineEnd && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to) } enterLine() { var t, e; -1 < this.lineStart || ({ from: t, to: e } = this.oracle.doc.lineAt(this.pos), this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new en(this.pos - t, -1)), this.writtenTo = this.pos) } blankContent(t, e) { var i = new rn(e - t); return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i } ensureLine() { this.enterLine(); var t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null; return t instanceof en || (t = new en(0, -1), this.nodes.push(t)), t } addBlock(t) { this.enterLine(); var e = t.deco; e && 0 < e.startSide && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && 0 < e.endSide && (this.covering = t) } addLineDeco(t, e, i) { var r = this.ensureLine(); r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, t), r.breaks += e, this.writtenTo = this.pos = this.pos + i } finish(t) { var e, i = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1]; !(-1 < this.lineStart) || i instanceof en || this.isCovered ? (this.writtenTo < this.pos || null == i) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new en(0, -1)); let r = t; for (e of this.nodes) e instanceof en && e.updateHeight(this.oracle, r), r += e ? e.length : 1; return this.nodes } static build(t, e, i, r) { t = new ip(i, t); return w.spans(e, i, r, t, 0), t.finish(i) } }; var an = class { constructor() { this.changes = [] } compareRange() { } comparePoint(t, e, i, r) { (t < e || i && i.heightRelevant || r && r.heightRelevant) && ui(t, e, this.changes, 5) } }; var ln = class { constructor(t, e, i) { this.from = t, this.to = e, this.size = i } static same(e, i) { if (e.length != i.length) return !1; for (let t = 0; t < e.length; t++) { var r = e[t], n = i[t]; if (r.from != n.from || r.to != n.to || r.size != n.size) return !1 } return !0 } draw(t, e) { return S.replace({ widget: new hn(this.size * (e ? t.scaleY : t.scaleX), e) }).range(this.from, this.to) } }, hn = class extends Ne { constructor(t, e) { super(), this.size = t, this.vertical = e } eq(t) { return t.size == this.size && t.vertical == this.vertical } toDOM() { var t = document.createElement("div"); return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t } get estimatedHeight() { return this.vertical ? this.size : -1 } }, cn = class { constructor(t) { this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = fn, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = k.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1; var e = t.facet(Fi).some(t => "function" != typeof t && "cm-lineWrapping" == t.class); this.heightOracle = new Fr(e), this.stateDeco = t.facet(Hi).filter(t => "function" != typeof t), this.heightMap = Kr.empty().applyChanges(this.stateDeco, m.empty, this.heightOracle.setDoc(t.doc), [new sr(0, 0, 0, t.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = S.set(this.lineGaps.map(t => t.draw(this, !1))), this.computeVisibleRanges() } updateForViewport() { var e, r, n = [this.viewport], s = this.state.selection.main; for (let t = 0; t <= 1; t++) { let i = t ? s.head : s.anchor; n.some(({ from: t, to: e }) => i >= t && i <= e) || ({ from: e, to: r } = this.lineBlockAt(i), n.push(new dn(e, r))) } this.viewports = n.sort((t, e) => t.from - e.from), this.scaler = this.heightMap.height <= 7e6 ? fn : new pn(this.heightOracle, this.heightMap, this.viewports) } updateViewportLines() { this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, t => { this.viewportLines.push(1 == this.scaler.scale ? t : mn(t, this.scaler)) }) } update(t, e = null) { this.state = t.state; var i = this.stateDeco, r = (this.stateDeco = this.state.facet(Hi).filter(t => "function" != typeof t), t.changedRanges), r = sr.extendWithRanges(r, (r = i, i = this.stateDeco, n = t ? t.changes : it.empty(this.state.doc.length), o = new an, w.compare(r, i, n, o, 0), o.changes)), i = this.heightMap.height, n = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop); this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), r), this.heightMap.height != i && (t.flags |= 2), n ? (this.scrollAnchorPos = t.changes.mapPos(n.from, -1), this.scrollAnchorHeight = n.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height); let s = r.length ? this.mapViewport(this.viewport, t.changes) : this.viewport; (e && (e.range.head < s.from || e.range.head > s.to) || !this.viewportIsAppropriate(s)) && (s = this.getViewport(0, e)); var o = !t.changes.empty || 2 & t.flags || s.from != this.viewport.from || s.to != this.viewport.to; this.viewport = s, this.updateForViewport(), o && this.updateViewportLines(), (this.lineGaps.length || 4e3 < this.viewport.to - this.viewport.from) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(Ei) && (this.mustEnforceCursorAssoc = !0) } measure(t) { var e = t.contentDOM, i = window.getComputedStyle(e), r = this.heightOracle, n = i.whiteSpace; this.defaultTextDirection = "rtl" == i.direction ? k.RTL : k.LTR; let s = this.heightOracle.mustRefreshForWrapping(n); var o = e.getBoundingClientRect(); let a = s || this.mustMeasureContent || this.contentDOMHeight != o.height, l = (this.contentDOMHeight = o.height, this.mustMeasureContent = !1, 0), h = 0; o.width && o.height && ({ scaleX: c, scaleY: d } = Ze(e, o), this.scaleX == c && this.scaleY == d || (this.scaleX = c, this.scaleY = d, l |= 8, s = a = !0)); var c = (parseInt(i.paddingTop) || 0) * this.scaleY, d = (parseInt(i.paddingBottom) || 0) * this.scaleY, i = (this.paddingTop == c && this.paddingBottom == d || (this.paddingTop = c, this.paddingBottom = d, l |= 10), this.editorWidth != t.scrollDOM.clientWidth && (r.lineWrapping && (a = !0), this.editorWidth = t.scrollDOM.clientWidth, l |= 8), t.scrollDOM.scrollTop * this.scaleY), c = (this.scrollTop != i && (this.scrollAnchorHeight = -1, this.scrollTop = i), this.scrolledToBottom = Ve(t.scrollDOM), (this.printing ? function(t, e) { return { left: 0, right: (t = t.getBoundingClientRect()).right - t.left, top: e, bottom: t.bottom - (t.top + e) } } : function(e, t) { var i = e.getBoundingClientRect(), r = e.ownerDocument, n = r.defaultView || window; let s = Math.max(0, i.left), o = Math.min(n.innerWidth, i.right), a = Math.max(0, i.top), l = Math.min(n.innerHeight, i.bottom); for (let t = e.parentNode; t && t != r.body;)if (1 == t.nodeType) { var h, c = t, d = window.getComputedStyle(c); (c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && "visible" != d.overflow && (h = c.getBoundingClientRect(), s = Math.max(s, h.left), o = Math.min(o, h.right), a = Math.max(a, h.top), l = t == e.parentNode ? h.bottom : Math.min(l, h.bottom)), t = "absolute" == d.position || "fixed" == d.position ? c.offsetParent : c.parentNode } else { if (11 != t.nodeType) break; t = t.host } return { left: s - i.left, right: Math.max(s, o) - i.left, top: a - (i.top + t), bottom: Math.max(a, l) - (i.top + t) } })(e, this.paddingTop)), d = c.top - this.pixelViewport.top, i = c.bottom - this.pixelViewport.bottom, e = (this.pixelViewport = c, this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left); if (e != this.inView && (this.inView = e) && (a = !0), !this.inView && !this.scrollTarget) return 0; c = o.width; if (this.contentDOMWidth == c && this.editorHeight == t.scrollDOM.clientHeight || (this.contentDOMWidth = o.width, this.editorHeight = t.scrollDOM.clientHeight, l |= 8), a) { var O, u, f = t.docView.measureVisibleLineHeights(this.viewport); ((s = r.mustRefreshForHeights(f) ? !0 : s) || r.lineWrapping && Math.abs(c - this.contentDOMWidth) > r.charWidth) && ({ lineHeight: e, charWidth: o, textHeight: O } = t.docView.measureTextSize(), s = 0 < e && r.refresh(n, e, o, O, c / o, f)) && (t.docView.minWidth = 0, l |= 8), 0 < d && 0 < i ? h = Math.max(d, i) : d < 0 && i < 0 && (h = Math.min(d, i)), r.heightChanged = !1; for (u of this.viewports) { var p = u.from == this.viewport.from ? f : t.docView.measureVisibleLineHeights(u); this.heightMap = (s ? Kr.empty().applyChanges(this.stateDeco, m.empty, this.heightOracle, [new sr(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(r, 0, s, new Hr(u.from, p)) } r.heightChanged && (l |= 2) } n = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to); return n && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (2 & l || n) && this.updateViewportLines(), (this.lineGaps.length || 4e3 < this.viewport.to - this.viewport.from) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, t)), l |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), l } get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top) } get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom) } getViewport(t, i) { var t = .5 - Math.max(-.5, Math.min(.5, t / 1e3 / 2)), r = this.heightMap, n = this.heightOracle, { visibleTop: s, visibleBottom: o } = this; let a = new dn(r.lineAt(s - 1e3 * t, x.ByHeight, n, 0, 0).from, r.lineAt(o + 1e3 * (1 - t), x.ByHeight, n, 0, 0).to); if (i) { s = i.range.head; if (s < a.from || s > a.to) { o = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top); let t = r.lineAt(s, x.ByPos, n, 0, 0), e; e = "center" == i.y ? (t.top + t.bottom) / 2 - o / 2 : "start" == i.y || "nearest" == i.y && s < a.from ? t.top : t.bottom - o, a = new dn(r.lineAt(e - 500, x.ByHeight, n, 0, 0).from, r.lineAt(e + o + 500, x.ByHeight, n, 0, 0).to) } } return a } mapViewport(t, e) { var i = e.mapPos(t.from, -1), e = e.mapPos(t.to, 1); return new dn(this.heightMap.lineAt(i, x.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(e, x.ByPos, this.heightOracle, 0, 0).to) } viewportIsAppropriate({ from: t, to: e }, i = 0) { var r, n, s, o; return !this.inView || (r = this.heightMap.lineAt(t, x.ByPos, this.heightOracle, 0, 0).top, n = this.heightMap.lineAt(e, x.ByPos, this.heightOracle, 0, 0).bottom, { visibleTop: s, visibleBottom: o } = this, (0 == t || r <= s - Math.max(10, Math.min(-i, 250))) && (e == this.state.doc.length || n >= o + Math.max(10, Math.min(i, 250))) && s - 2e3 < r && n < o + 2e3) } mapLineGaps(t, e) { if (!t.length || e.empty) return t; var i, r = []; for (i of t) e.touchesRange(i.from, i.to) || r.push(new ln(e.mapPos(i.from), e.mapPos(i.to), i.size)); return r } ensureLineGaps(h, c) { let d = this.heightOracle.lineWrapping, n = d ? 1e4 : 2e3, O = n >> 1, t = n << 1; if (this.defaultTextDirection != k.LTR && !d) return []; let u = [], f = (r, n, s, o) => { if (!(n - r < O)) { let t = this.state.selection.main, i = [t.from]; t.empty || i.push(t.to); for (var a of i) if (a > r && a < n) return f(r, a - 10, s, o), void f(a + 10, n, s, o); let e = ((t, e) => { for (var i of t) if (e(i)) return i })(h, e => e.from >= s.from && e.to <= s.to && Math.abs(e.from - r) < O && Math.abs(e.to - n) < O && !i.some(t => e.from < t && e.to > t)); var l; e || (n < s.to && c && d && c.visibleRanges.some(t => t.from <= n && t.to >= n) && (l = c.moveToLineBoundary(g.cursor(n), !1, !0).head, r < l) && (n = l), e = new ln(r, n, this.gapSize(s, r, n, o))), u.push(e) } }; for (var s of this.viewportLines) if (!(s.length < t)) { var o = ((t, e, i) => { let r = [], n = t, s = 0; return w.spans(i, t, e, { span() { }, point(t, e) { t > n && (r.push({ from: n, to: t }), s += t - n), n = e } }, 20), n < e && (r.push({ from: n, to: e }), s += e - n), { total: s, ranges: r } })(s.from, s.to, this.stateDeco); if (!(o.total < t)) { var a = this.scrollTarget ? this.scrollTarget.range.head : null; let i, r; if (d) { var l = n / this.heightOracle.lineLength * this.heightOracle.lineHeight; let t, e; e = null != a ? (p = un(o, a), m = ((this.visibleBottom - this.visibleTop) / 2 + l) / s.height, t = p - m, p + m) : (t = (this.visibleTop - s.top - l) / s.height, (this.visibleBottom - s.top + l) / s.height), i = On(o, t), r = On(o, e) } else { var p = o.total * this.heightOracle.charWidth, m = n * this.heightOracle.charWidth; let t, e; e = null != a ? (l = un(o, a), a = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + m) / p, t = l - a, l + a) : (t = (this.pixelViewport.left - m) / p, (this.pixelViewport.right + m) / p), i = On(o, t), r = On(o, e) } i > s.from && f(s.from, i, s, o), r < s.to && f(r, s.to, s, o) } } return u } gapSize(t, e, i, r) { i = un(r, i) - un(r, e); return this.heightOracle.lineWrapping ? t.height * i : r.total * this.heightOracle.charWidth * i } updateLineGaps(t) { ln.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = S.set(t.map(t => t.draw(this, this.heightOracle.lineWrapping)))) } computeVisibleRanges() { let t = this.stateDeco, i = (this.lineGaps.length && (t = t.concat(this.lineGapDeco)), []); w.spans(t, this.viewport.from, this.viewport.to, { span(t, e) { i.push({ from: t, to: e }) }, point() { } }, 20); var e = i.length != this.visibleRanges.length || this.visibleRanges.some((t, e) => t.from != i[e].from || t.to != i[e].to); return this.visibleRanges = i, e ? 4 : 0 } lineBlockAt(e) { return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find(t => t.from <= e && t.to >= e) || mn(this.heightMap.lineAt(e, x.ByPos, this.heightOracle, 0, 0), this.scaler) } lineBlockAtHeight(t) { return mn(this.heightMap.lineAt(this.scaler.fromDOM(t), x.ByHeight, this.heightOracle, 0, 0), this.scaler) } scrollAnchorAt(t) { var e = this.lineBlockAtHeight(t + 8); return e.from >= this.viewport.from || 200 < this.viewportLines[0].top - t ? e : this.viewportLines[0] } elementAtHeight(t) { return mn(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler) } get docHeight() { return this.scaler.toDOM(this.heightMap.height) } get contentHeight() { return this.docHeight + this.paddingTop + this.paddingBottom } }, dn = class { constructor(t, e) { this.from = t, this.to = e } }; function On({ total: t, ranges: e }, i) { if (i <= 0) return e[0].from; if (1 <= i) return e[e.length - 1].to; let r = Math.floor(t * i); for (let t = 0; ; t++) { var { from: n, to: s } = e[t], s = s - n; if (r <= s) return n + r; r -= s } } function un(t, e) { let i = 0; for (var { from: r, to: n } of t.ranges) { if (e <= n) { i += e - r; break } i += n - r } return i / t.total } var fn = { toDOM(t) { return t }, fromDOM(t) { return t }, scale: 1 }, pn = class { constructor(n, s, t) { let o = 0, e = 0, i = 0; this.viewports = t.map(({ from: t, to: e }) => { var i = s.lineAt(t, x.ByPos, n, 0, 0).top, r = s.lineAt(e, x.ByPos, n, 0, 0).bottom; return o += r - i, { from: t, to: e, top: i, bottom: r, domTop: 0, domBottom: 0 } }), this.scale = (7e6 - o) / (s.height - o); for (var r of this.viewports) r.domTop = i + (r.top - e) * this.scale, i = r.domBottom = r.domTop + (r.bottom - r.top), e = r.bottom } toDOM(r) { for (let t = 0, e = 0, i = 0; ; t++) { var n = t < this.viewports.length ? this.viewports[t] : null; if (!n || r < n.top) return i + (r - e) * this.scale; if (r <= n.bottom) return n.domTop + (r - n.top); e = n.bottom, i = n.domBottom } } fromDOM(r) { for (let t = 0, e = 0, i = 0; ; t++) { var n = t < this.viewports.length ? this.viewports[t] : null; if (!n || r < n.domTop) return e + (r - i) / this.scale; if (r <= n.domBottom) return n.top + (r - n.domTop); e = n.bottom, i = n.domBottom } } }; function mn(t, e) { var i, r; return 1 == e.scale ? t : (i = e.toDOM(t.top), r = e.toDOM(t.bottom), new Jr(t.from, t.length, i, r - i, Array.isArray(t._content) ? t._content.map(t => mn(t, e)) : t._content)) } var gn = d.define({ combine: t => t.join(" ") }), vn = d.define({ combine: t => -1 < t.indexOf(!0) }), wn = Oe.newName(), bn = Oe.newName(), yn = Oe.newName(), Sn = { "&light": "." + bn, "&dark": "." + yn }; function Qn(e, t, i) { return new Oe(t, { finish(t) { return /&/.test(t) ? t.replace(/&\w*/, t => { if ("&" == t) return e; if (i && i[t]) return i[t]; throw new RangeError("Unsupported selector: " + t) }) : e + " " + t } }) } var xn = Qn("." + wn, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, Sn), kn = class { constructor(t, e) { this.points = t, this.text = "", this.lineSeparator = e.facet(v.lineSeparator) } append(t) { this.text += t } lineBreak() { this.text += "ï¿¿" } readRange(e, i) { if (e) { var r = e.parentNode; for (let t = e; ;) { this.findPointBefore(r, t); var n = this.text.length, s = (this.readNode(t), t.nextSibling); if (s == i) break; var o = b.get(t), a = b.get(s); (o && a ? o.breakAfter : (o ? o.breakAfter : $n(t)) || $n(s) && ("BR" != t.nodeName || t.cmIgnore) && this.text.length > n) && this.lineBreak(), t = s } this.findPointBefore(r, i) } return this } readTextNode(s) { var t, o = s.nodeValue; for (t of this.points) t.node == s && (t.pos = this.text.length + Math.min(t.offset, o.length)); for (let r = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ;) { let t = -1, e = 1, i; if (this.lineSeparator ? (t = o.indexOf(this.lineSeparator, r), e = this.lineSeparator.length) : (i = n.exec(o)) && (t = i.index, e = i[0].length), this.append(o.slice(r, t < 0 ? o.length : t)), t < 0) break; if (this.lineBreak(), 1 < e) for (var a of this.points) a.node == s && a.pos > this.text.length && (a.pos -= e - 1); r = t + e } } readNode(t) { if (!t.cmIgnore) { var e = b.get(t), e = e && e.overrideDOMText; if (null != e) { this.findPointInside(t, e.length); for (var i = e.iter(); !i.next().done;)i.lineBreak ? this.lineBreak() : this.append(i.value) } else 3 == t.nodeType ? this.readTextNode(t) : "BR" == t.nodeName ? t.nextSibling && this.lineBreak() : 1 == t.nodeType && this.readRange(t.firstChild, null) } } findPointBefore(t, e) { for (var i of this.points) i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length) } findPointInside(t, e) { for (var i of this.points) (3 == t.nodeType ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (((t, e, i) => { for (; ;) { if (!e || i < $e(e)) return; if (e == t) return 1; i = xe(e) + 1, e = e.parentNode } })(t, i.node, i.offset) ? e : 0)) } }; function $n(t) { return 1 == t.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName) } var Pn = class { constructor(t, e) { this.node = t, this.offset = e, this.pos = -1 } }, Zn = class { constructor(i, r, n, s) { this.typeOver = s, this.bounds = null, this.text = ""; var { impreciseHead: s, impreciseAnchor: o } = i.docView; if (i.state.readOnly && -1 < r) this.newSel = null; else if (-1 < r && (this.bounds = i.docView.domBoundsAround(r, n, 0))) { var n = s || o ? [] : (r = [], (n = i).root.activeElement == n.contentDOM && ({ anchorNode: n, anchorOffset: t, focusNode: a, focusOffset: l } = n.observer.selectionRange, n) && (r.push(new Pn(n, t)), a == n && l == t || r.push(new Pn(a, l))), r), t = new kn(n, i.state); t.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = t.text, this.newSel = ((t, e) => { var i; return 0 != t.length && (i = t[0].pos, t = 2 == t.length ? t[1].pos : i, -1 < i) && -1 < t ? g.single(i + e, t + e) : null })(n, this.bounds.from) } else { var a = i.observer.selectionRange; let t = s && s.node == a.focusNode && s.offset == a.focusOffset || !be(i.contentDOM, a.focusNode) ? i.state.selection.main.head : i.docView.posFromDOM(a.focusNode, a.focusOffset), e = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !be(i.contentDOM, a.anchorNode) ? i.state.selection.main.anchor : i.docView.posFromDOM(a.anchorNode, a.anchorOffset); var l = i.viewport; y.ios && i.state.selection.main.empty && t != e && (0 < l.from || l.to < i.state.doc.length) && (r = l.from - Math.min(t, e), n = l.to - Math.max(t, e), 0 != r && 1 != r || 0 != n && -1 != n || (t = 0, e = i.state.doc.length)), this.newSel = g.single(e, t) } } }; function Tn(r, i) { let n, s = i.newSel, o = r.state.selection.main; var a = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1; if (i.bounds) { var { from: l, to: h } = i.bounds; let t = o.from, e = null; (8 === a || y.android && i.text.length < h - l) && (t = o.to, e = "end"); h = ((t, e, i, r) => { let n = Math.min(t.length, e.length), s = 0; for (; s < n && t.charCodeAt(s) == e.charCodeAt(s);)s++; if (s == n && t.length == e.length) return null; let o = t.length, a = e.length; for (; 0 < o && 0 < a && t.charCodeAt(o - 1) == e.charCodeAt(a - 1);)o--, a--; return "end" == r && (r = Math.max(0, s - Math.min(o, a)), i -= o + r - s), o < s && t.length < e.length ? (r = i <= s && i >= o ? s - i : 0, s -= r, a = s + (a - o), o = s) : a < s && (r = i <= s && i >= a ? s - i : 0, s -= r, o = s + (o - a), a = s), { from: s, toA: o, toB: a } })(r.state.doc.sliceString(l, h, "ï¿¿"), i.text, t - l, e); h && (y.chrome && 13 == a && h.toB == h.from + 2 && "ï¿¿ï¿¿" == i.text.slice(h.from, h.toB) && h.toB--, n = { from: l + h.from, to: l + h.toA, insert: m.of(i.text.slice(h.from, h.toB).split("ï¿¿")) }) } else s && (!r.hasFocus && r.state.facet(Gi) || s.main.eq(o)) && (s = null); if (!n && !s) return !1; if (!n && i.typeOver && !o.empty && s && s.main.empty ? n = { from: o.from, to: o.to, insert: r.state.doc.slice(o.from, o.to) } : n && n.from >= o.from && n.to <= o.to && (n.from != o.from || n.to != o.to) && o.to - o.from - (n.to - n.from) <= 4 ? n = { from: o.from, to: o.to, insert: r.state.doc.slice(o.from, n.from).append(n.insert).append(r.state.doc.slice(n.to, o.to)) } : (y.mac || y.android) && n && n.from == n.to && n.from == o.head - 1 && /^\. ?$/.test(n.insert.toString()) && "off" == r.contentDOM.getAttribute("autocorrect") ? (s && 2 == n.insert.length && (s = g.single(s.main.anchor - 1, s.main.head - 1)), n = { from: o.from, to: o.to, insert: m.of([" "]) }) : y.chrome && n && n.from == n.to && n.from == o.head && "\n " == n.insert.toString() && r.lineWrapping && (s = s && g.single(s.main.anchor - 1, s.main.head - 1), n = { from: o.from, to: o.to, insert: m.of([" "]) }), n) { if ((!y.ios || !r.inputState.flushIOSKey()) && (!y.android || !(n.from == o.from && n.to == o.to && 1 == n.insert.length && 2 == n.insert.lines && Ye(r.contentDOM, "Enter", 13) || (n.from == o.from - 1 && n.to == o.to && 0 == n.insert.length || 8 == a && n.insert.length < n.to - n.from && n.to > o.head) && Ye(r.contentDOM, "Backspace", 8) || n.from == o.from && n.to == o.to + 1 && 0 == n.insert.length && Ye(r.contentDOM, "Delete", 46)))) { let e = n.insert.toString(); 0 <= r.inputState.composing && r.inputState.composing++; let t, i = () => t = t || ((h, c, e) => { let i, d = h.state, O = d.selection.main; if (c.from >= O.from && c.to <= O.to && c.to - c.from >= (O.to - O.from) / 3 && (!e || e.main.empty && e.main.from == c.from + c.insert.length) && h.inputState.composing < 0) { var u = O.from < c.from ? d.sliceDoc(O.from, c.from) : "", t = O.to > c.to ? d.sliceDoc(c.to, O.to) : ""; i = d.replaceSelection(h.state.toText(u + c.insert.sliceString(0, void 0, h.state.lineBreak) + t)) } else { let a = d.changes(c), l = e && e.main.to <= a.newLength ? e.main : void 0; if (1 < d.selection.ranges.length && 0 <= h.inputState.composing && c.to <= O.to && c.to >= O.to - 10) { let r = h.state.sliceDoc(c.from, c.to), n, t = e && hr(h, e.main.head); n = t ? (u = c.insert.length - (c.to - c.from), { from: t.from, to: t.to - u }) : h.state.doc.lineAt(O.head); let s = O.to - c.to, o = O.to - O.from; i = d.changeByRange(t => { var e, i; return t.from == O.from && t.to == O.to ? { changes: a, range: l || t.map(a) } : (e = (i = t.to - s) - r.length, t.to - t.from != o || h.state.sliceDoc(e, i) != r || t.to >= n.from && t.from <= n.to ? { range: t } : (e = d.changes({ from: e, to: i, insert: c.insert }), i = t.to - O.to, { changes: e, range: l ? g.range(Math.max(0, l.anchor + i), Math.max(0, l.head + i)) : t.map(e) })) }) } else i = { changes: a, selection: l && d.selection.replaceRange(l) } } let r = "input.type"; return (h.composing || h.inputState.compositionPendingChange && h.inputState.compositionEndedAt > Date.now() - 50) && (h.inputState.compositionPendingChange = !1, r += ".compose", h.inputState.compositionFirstChange) && (r += ".start", h.inputState.compositionFirstChange = !1), d.update(i, { userEvent: r, scrollIntoView: !0 }) })(r, n, s); r.state.facet(qi).some(t => t(r, n.from, n.to, e, i)) || r.dispatch(i()) } return !0 } if (!s || s.main.eq(o)) return !1; { let t = !1, e = "select"; return r.inputState.lastSelectionTime > Date.now() - 50 && ("select" == r.inputState.lastSelectionOrigin && (t = !0), e = r.inputState.lastSelectionOrigin), r.dispatch({ selection: s, scrollIntoView: t, userEvent: e }), !0 } } var Cn = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 }, Xn = y.ie && y.ie_version <= 11, An = class { constructor(i) { this.view = i, this.active = !1, this.selectionRange = new Ce, this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = i.contentDOM, this.observer = new MutationObserver(t => { for (var e of t) this.queue.push(e); (y.ie && y.ie_version <= 11 || y.ios && i.composing) && t.some(t => "childList" == t.type && t.removedNodes.length || "characterData" == t.type && t.oldValue.length > t.target.nodeValue.length) ? this.flushSoon() : this.flush() }), Xn && (this.onCharData = t => { this.queue.push({ target: t.target, type: "characterData", oldValue: t.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver(() => { var t; (null == (t = this.view.docView) ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize() }), this.resizeScroll.observe(i.scrollDOM)), this.addWindowListeners(this.win = i.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver(t => { this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), 0 < t.length && 0 < t[t.length - 1].intersectionRatio != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView) && this.onScrollChanged(document.createEvent("Event")) }, { threshold: [0, .001] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver(t => { 0 < t.length && 0 < t[t.length - 1].intersectionRatio && this.onScrollChanged(document.createEvent("Event")) }, {})), this.listenForScroll(), this.readSelectionRange() } onScrollChanged(t) { this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure() } onScroll(t) { this.intersecting && this.flush(!1), this.onScrollChanged(t) } onResize() { this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => { this.resizeTimeout = -1, this.view.requestMeasure() }, 50)) } onPrint() { this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => { this.view.viewState.printing = !1, this.view.requestMeasure() }, 500) } updateGaps(i) { if (this.gapIntersection && (i.length != this.gaps.length || this.gaps.some((t, e) => t != i[e]))) { this.gapIntersection.disconnect(); for (var t of i) this.gapIntersection.observe(t); this.gaps = i } } onSelectionChange(t) { var e, i, r, n = this.selectionChanged; this.readSelectionRange() && !this.delayedAndroidKey && (e = this.view, i = this.selectionRange, e.state.facet(Gi) ? e.root.activeElement == this.dom : ye(e.dom, i)) && ((r = i.anchorNode && e.docView.nearest(i.anchorNode)) && r.ignoreEvent(t) ? n || (this.selectionChanged = !1) : (y.ie && y.ie_version <= 11 || y.android && y.chrome) && !e.state.selection.main.empty && i.focusNode && Qe(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1)) } readSelectionRange() { var t, e = this.view, i = y.safari && 11 == e.root.nodeType && (t => { let e = t.activeElement; for (; e && e.shadowRoot;)e = e.shadowRoot.activeElement; return e })(this.dom.ownerDocument) == this.dom && (t => { let e = null; function i(t) { t.preventDefault(), t.stopImmediatePropagation(), e = t.getTargetRanges()[0] } if (t.contentDOM.addEventListener("beforeinput", i, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, !0), !e) return null; let r = e.startContainer, n = e.startOffset, s = e.endContainer, o = e.endOffset, a = t.docView.domAtPos(t.state.selection.main.anchor); return Qe(a.node, a.offset, s, o) && ([r, n, s, o] = [s, o, r, n]), { anchorNode: r, anchorOffset: n, focusNode: s, focusOffset: o } })(this.view) || we(e.root); return !(!i || this.selectionRange.eq(i) || ((t = ye(this.dom, i)) && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && ((t, e) => { let i = e.focusNode, r = e.focusOffset; if (i && e.anchorNode == i && e.anchorOffset == r) for (r = Math.min(r, $e(i)); ;)if (r) { if (1 != i.nodeType) return; var n = i.childNodes[r - 1]; "false" == n.contentEditable ? r-- : (i = n, r = $e(i)) } else { if (i == t) return 1; r = xe(i), i = i.parentNode } })(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), 1) : (this.selectionRange.setRange(i), t && (this.selectionChanged = !0), 0))) } setSelectionRange(t, e) { this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1 } clearSelectionRange() { this.selectionRange.set(null, 0, null, 0) } listenForScroll() { this.parentCheck = -1; let e = 0, i = null; for (let t = this.dom; t;)if (1 == t.nodeType) !i && e < this.scrollTargets.length && this.scrollTargets[e] == t ? e++ : i = i || this.scrollTargets.slice(0, e), i && i.push(t), t = t.assignedSlot || t.parentNode; else { if (11 != t.nodeType) break; t = t.host } if (i = e < this.scrollTargets.length && !i ? this.scrollTargets.slice(0, e) : i) { for (var t of this.scrollTargets) t.removeEventListener("scroll", this.onScroll); for (var r of this.scrollTargets = i) r.addEventListener("scroll", this.onScroll) } } ignore(t) { if (!this.active) return t(); try { return this.stop(), t() } finally { this.start(), this.clear() } } start() { this.active || (this.observer.observe(this.dom, Cn), Xn && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0) } stop() { this.active && (this.active = !1, this.observer.disconnect(), Xn) && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData) } clear() { this.processRecords(), this.queue.length = 0, this.selectionChanged = !1 } delayAndroidKey(t, e) { this.delayedAndroidKey || (this.flushingAndroidKey = this.view.win.requestAnimationFrame(() => { var t = this.delayedAndroidKey; t && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = t.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush()) && t.force && Ye(this.dom, t.key, t.keyCode) })), this.delayedAndroidKey && "Enter" != t || (this.delayedAndroidKey = { key: t, keyCode: e, force: this.lastChange < Date.now() - 50 || !(null == (t = this.delayedAndroidKey) || !t.force) }) } clearDelayedAndroidKey() { this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1 } flushSoon() { this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1, this.flush() })) } forceFlush() { 0 <= this.delayedFlush && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush() } pendingRecords() { for (var t of this.observer.takeRecords()) this.queue.push(t); return this.queue } processRecords() { var t, e = this.pendingRecords(); e.length && (this.queue = []); let i = -1, r = -1, n = !1; for (t of e) { var s = this.readMutation(t); s && (s.typeOver && (n = !0), -1 == i ? { from: i, to: r } = s : (i = Math.min(s.from, i), r = Math.max(s.to, r))) } return { from: i, to: r, typeOver: n } } readChange() { var { from: t, to: e, typeOver: i } = this.processRecords(), r = this.selectionChanged && ye(this.dom, this.selectionRange); if (t < 0 && !r) return null; -1 < t && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1; r = new Zn(this.view, t, e, i); return this.view.docView.domChanged = { newSel: r.newSel ? r.newSel.main : null }, r } flush(t = !0) { if (0 <= this.delayedFlush || this.delayedAndroidKey) return !1; t && this.readSelectionRange(); var e, t = this.readChange(); return t ? (e = this.view.state, t = Tn(this.view, t), this.view.state == e && this.view.update([]), t) : (this.view.requestMeasure(), !1) } readMutation(t) { var e, i, r = this.view.docView.nearest(t.target); return !r || r.ignoreMutation(t) ? null : (r.markDirty("attributes" == t.type), "attributes" == t.type && (r.flags |= 4), "childList" == t.type ? (e = Rn(r, t.previousSibling || t.target.previousSibling, -1), i = Rn(r, t.nextSibling || t.target.nextSibling, 1), { from: e ? r.posAfter(e) : r.posAtStart, to: i ? r.posBefore(i) : r.posAtEnd, typeOver: !1 }) : "characterData" == t.type ? { from: r.posAtStart, to: r.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null) } setWindow(t) { t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win)) } addWindowListeners(t) { t.addEventListener("resize", this.onResize), t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange) } removeWindowListeners(t) { t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange) } destroy() { var t, e; this.stop(), null != (t = this.intersection) && t.disconnect(), null != (t = this.gapIntersection) && t.disconnect(), null != (t = this.resizeScroll) && t.disconnect(); for (e of this.scrollTargets) e.removeEventListener("scroll", this.onScroll); this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey) } }; function Rn(t, e, i) { for (; e;) { var r = b.get(e); if (r && r.parent == t) return r; r = e.parentNode; e = r != t.dom ? r : 0 < i ? e.nextSibling : e.previousSibling } return null } var $ = class rp { get state() { return this.viewState.state } get viewport() { return this.viewState.viewport } get visibleRanges() { return this.viewState.visibleRanges } get inView() { return this.viewState.inView } get composing() { return 0 < this.inputState.composing } get compositionStarted() { return 0 <= this.inputState.composing } get root() { return this._root } get win() { return this.dom.ownerDocument.defaultView || window } constructor(t = {}) { this.plugins = [], this.pluginMap = new Map, this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom); let e = t.dispatch; this.dispatchTransactions = t.dispatchTransactions || (e ? t => t.forEach(t => e(t, this)) : t => this.update(t)), this.dispatch = this.dispatch.bind(this), this._root = t.root || (t => { for (; t;) { if (t && (9 == t.nodeType || 11 == t.nodeType && t.host)) return t; t = t.assignedSlot || t.parentNode } return null })(t.parent) || document, this.viewState = new cn(t.state || v.create(t)), t.scrollTo && t.scrollTo.is(zi) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Ni).map(t => new Ui(t)); for (var i of this.plugins) i.update(this); this.observer = new An(this), this.inputState = new Qr(this), this.inputState.ensureHandlers(this.plugins), this.docView = new ar(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure() } dispatch(...t) { t = 1 == t.length && t[0] instanceof Wt ? t : 1 == t.length && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)]; this.dispatchTransactions(t, this) } update(o) { if (0 != this.updateState) throw new Error("Calls to EditorView.update are not allowed while an update is in progress"); let a = !1, l = !1, h, c = this.state; for (var t of o) { if (t.startState != c) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state."); c = t.state } if (this.destroyed) this.viewState.state = c; else { let t = this.hasFocus, e = 0, i = null, r = (o.some(t => t.annotation(Gr)) ? (this.inputState.notifiedFocused = t, e = 1) : t == this.inputState.notifiedFocused || (this.inputState.notifiedFocused = t, i = Ir(c, t)) || (e = 1), this.observer.delayedAndroidKey), n = null; if (r ? (this.observer.clearDelayedAndroidKey(), (!(n = this.observer.readChange()) || this.state.doc.eq(c.doc)) && this.state.selection.eq(c.selection) || (n = null)) : this.observer.clear(), c.facet(v.phrases) != this.state.facet(v.phrases)) return this.setState(c); (h = or.create(this, c, o)).flags |= e; let s = this.viewState.scrollTarget; try { this.updateState = 2; for (var d of o) { var O, u; s = s && s.map(d.changes), d.scrollIntoView && (O = d.state.selection.main, s = new Di(O.empty ? O : g.cursor(O.head, O.head > O.anchor ? -1 : 1))); for (u of d.effects) u.is(zi) && (s = u.value.clip(this.state)) } this.viewState.update(h, s), this.bidiCache = Vn.update(this.bidiCache, h.changes), h.empty || (this.updatePlugins(h), this.inputState.update(h)), a = this.docView.update(h), this.state.facet(nr) != this.styleModules && this.mountStyles(), l = this.updateAttrs(), this.showAnnouncements(o), this.docView.updateSelection(a, o.some(t => t.isUserEvent("select.pointer"))) } finally { this.updateState = 0 } if (h.startState.facet(gn) != h.state.facet(gn) && (this.viewState.mustMeasureContent = !0), (a || l || s || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !h.empty) for (var f of this.state.facet(Mi)) try { f(h) } catch (t) { Bi(this.state, t, "update listener") } (i || n) && Promise.resolve().then(() => { i && this.state == i.startState && this.dispatch(i), n && !Tn(this, n) && r.force && Ye(this.contentDOM, r.key, r.keyCode) }) } } setState(t) { if (0 != this.updateState) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress"); if (this.destroyed) this.viewState.state = t; else { this.updateState = 2; var e = this.hasFocus; try { for (var i of this.plugins) i.destroy(this); this.viewState = new cn(t), this.plugins = t.facet(Ni).map(t => new Ui(t)), this.pluginMap.clear(); for (var r of this.plugins) r.update(this); this.docView.destroy(), this.docView = new ar(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [] } finally { this.updateState = 0 } e && this.focus(), this.requestMeasure() } } updatePlugins(t) { var e = t.startState.facet(Ni), i = t.state.facet(Ni); if (e != i) { var r, n, s = []; for (r of i) { var o = e.indexOf(r); o < 0 ? s.push(new Ui(r)) : ((o = this.plugins[o]).mustUpdate = t, s.push(o)) } for (n of this.plugins) n.mustUpdate != t && n.destroy(this); this.plugins = s, this.pluginMap.clear() } else for (var a of this.plugins) a.mustUpdate = t; for (let t = 0; t < this.plugins.length; t++)this.plugins[t].update(this); e != i && this.inputState.ensureHandlers(this.plugins) } measure(t = !0) { if (!this.destroyed) if (-1 < this.measureScheduled && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) this.measureScheduled = -1, this.requestMeasure(); else { this.measureScheduled = 0, t && this.observer.forceFlush(); let n = null, s = this.scrollDOM, o = s.scrollTop * this.scaleY, { scrollAnchorPos: a, scrollAnchorHeight: l } = this.viewState; 1 < Math.abs(o - this.viewState.scrollTop) && (l = -1), this.viewState.scrollAnchorHeight = -1; try { for (let r = 0; ; r++) { l < 0 && (l = Ve(s) ? (a = -1, this.viewState.heightMap.height) : (h = this.viewState.scrollAnchorAt(o), a = h.from, h.top)), this.updateState = 1; var h, c = this.viewState.measure(this); if (!c && !this.measureRequests.length && null == this.viewState.scrollTarget) break; if (5 < r) { console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize"); break } let e = []; 4 & c || ([this.measureRequests, e] = [e, this.measureRequests]); var d = e.map(t => { try { return t.read(this) } catch (t) { return Bi(this.state, t), Wn } }); let t = or.create(this, this.state, []), i = !1; t.flags |= c, n ? n.flags |= c : n = t, this.updateState = 2, t.empty || (this.updatePlugins(t), this.inputState.update(t), this.updateAttrs(), i = this.docView.update(t)); for (let t = 0; t < e.length; t++)if (d[t] != Wn) try { var O = e[t]; O.write && O.write(d[t], this) } catch (t) { Bi(this.state, t) } if (i && this.docView.updateSelection(!0), !t.viewportChanged && 0 == this.measureRequests.length) { if (this.viewState.editorHeight) { if (this.viewState.scrollTarget) { this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, l = -1; continue } var u = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - l; if (1 < u || u < -1) { o += u, s.scrollTop = o / this.scaleY, l = -1; continue } } break } } } finally { this.updateState = 0, this.measureScheduled = -1 } if (n && !n.empty) for (var e of this.state.facet(Mi)) e(n) } } get themeClasses() { return wn + " " + (this.state.facet(vn) ? yn : bn) + " " + this.state.facet(gn) } updateAttrs() { let i = Mn(this, Li, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), r = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(Gi) ? "true" : "false", class: "cm-content", style: y.tabSize + ": " + this.state.tabSize, role: "textbox", "aria-multiline": "true" }; this.state.readOnly && (r["aria-readonly"] = "true"), Mn(this, Fi, r); var t = this.observer.ignore(() => { var t = si(this.contentDOM, this.contentAttrs, r), e = si(this.dom, this.editorAttrs, i); return t || e }); return this.editorAttrs = i, this.contentAttrs = r, t } showAnnouncements(t) { let e = !0; for (var i of t) for (var r of i.effects) r.is(rp.announce) && (e && (this.announceDOM.textContent = ""), e = !1, this.announceDOM.appendChild(document.createElement("div")).textContent = r.value) } mountStyles() { this.styleModules = this.state.facet(nr); var t = this.state.facet(rp.cspNonce); Oe.mount(this.root, this.styleModules.concat(xn).reverse(), t ? { nonce: t } : void 0) } readMeasured() { if (2 == this.updateState) throw new Error("Reading the editor layout isn't allowed during an update"); 0 == this.updateState && -1 < this.measureScheduled && this.measure(!1) } requestMeasure(e) { if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e && !(-1 < this.measureRequests.indexOf(e))) { if (null != e.key) for (let t = 0; t < this.measureRequests.length; t++)if (this.measureRequests[t].key === e.key) return void (this.measureRequests[t] = e); this.measureRequests.push(e) } } plugin(e) { let t = this.pluginMap.get(e); return (void 0 === t || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find(t => t.spec == e) || null), t && t.update(this).value } get documentTop() { return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop } get documentPadding() { return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom } } get scaleX() { return this.viewState.scaleX } get scaleY() { return this.viewState.scaleY } elementAtHeight(t) { return this.readMeasured(), this.viewState.elementAtHeight(t) } lineBlockAtHeight(t) { return this.readMeasured(), this.viewState.lineBlockAtHeight(t) } get viewportLineBlocks() { return this.viewState.viewportLines } lineBlockAt(t) { return this.viewState.lineBlockAt(t) } get contentHeight() { return this.viewState.contentHeight } moveByChar(t, e, i) { return Sr(this, t, br(this, t, e, i)) } moveByGroup(s, t) { return Sr(this, s, br(this, s, t, t => { { var r = this, n = s.head; let e = r.state.charCategorizer(n), i = e(t); return t => { t = e(t); return (i = i == p.Space ? t : i) == t } } })) } visualLineSide(t, e) { var i = this.bidiSpans(t), r = this.textDirectionAt(t.from), i = i[e ? i.length - 1 : 0]; return g.cursor(i.side(e, r) + t.from, i.forward(!e, r) ? 1 : -1) } moveToLineBoundary(t, e, i = !0) { var r = wr(s = this, (t = t).head); if (i = i && r.type == li.Text && (s.lineWrapping || r.widgetLineBreaks) ? s.coordsAtPos(t.assoc < 0 && t.head > r.from ? t.head - 1 : t.head) : null) { var t = s.dom.getBoundingClientRect(), n = s.textDirectionAt(r.from), s = s.posAtCoords({ x: e == (n == k.LTR) ? t.right - 1 : t.left + 1, y: (i.top + i.bottom) / 2 }); if (null != s) return g.cursor(s, e ? -1 : 1) } return g.cursor(e ? r.to : r.from, e ? -1 : 1) } moveVertically(t, e, i) { return Sr(this, t, ((e, t, i, r) => { var n = t.head, s = i ? 1 : -1; if (n == (i ? e.state.doc.length : 0)) return g.cursor(n, t.assoc); let o = t.goalColumn, a; var l = e.contentDOM.getBoundingClientRect(), i = e.coordsAtPos(n, t.assoc || -1), t = e.documentTop, h = (a = i ? (null == o && (o = i.left - l.left), s < 0 ? i.top : i.bottom) : (i = e.viewState.lineBlockAt(n), null == o && (o = Math.min(l.right - l.left, e.defaultCharacterWidth * (n - i.from))), (s < 0 ? i.top : i.bottom) + t), l.left + o), c = null != r ? r : e.viewState.heightOracle.textHeight >> 1; for (let t = 0; ; t += 10) { var d, O = a + (c + t) * s, u = gr(e, { x: h, y: O }, !1, s); if (O < l.top || O > l.bottom || (s < 0 ? u < n : n < u)) return O = !(d = e.docView.coordsForChar(u)) || O < d.top ? -1 : 1, g.cursor(u, O, void 0, o) } })(this, t, e, i)) } domAtPos(t) { return this.docView.domAtPos(t) } posAtDOM(t, e = 0) { return this.docView.posFromDOM(t, e) } posAtCoords(t, e = !0) { return this.readMeasured(), gr(this, t, e) } coordsAtPos(t, e = 1) { this.readMeasured(); var i, r, n = this.docView.coordsAt(t, e); return n && n.left != n.right ? (i = this.state.doc.lineAt(t), Pe(n, (r = this.bidiSpans(i))[Ti.find(r, t - i.from, -1, e)].dir == k.LTR == 0 < e)) : n } coordsForChar(t) { return this.readMeasured(), this.docView.coordsForChar(t) } get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth } get defaultLineHeight() { return this.viewState.heightOracle.lineHeight } get textDirection() { return this.viewState.defaultTextDirection } textDirectionAt(t) { return !this.state.facet(ji) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t)) } get lineWrapping() { return this.viewState.heightOracle.lineWrapping } bidiSpans(t) { if (t.length > Yn) return Xi(t.length); let e = this.textDirectionAt(t.from), i; for (var r of this.bidiCache) if (r.from == t.from && r.dir == e && (r.fresh || function e(i, r) { if (i.length == r.length) { for (let t = 0; t < i.length; t++) { var n = i[t], s = r[t]; if (n.from != s.from || n.to != s.to || n.direction != s.direction || !e(n.inner, s.inner)) return } return 1 } }(r.isolates, i = er(this, t)))) return r.order; i = i || er(this, t); var n = ((t, e, i) => { if (!t) return [new Ti(0, 0, e == vi ? 1 : 0)]; if (e == gi && !i.length && !Zi.test(t)) return Xi(t.length); if (i.length) for (; t.length > W.length;)W[W.length] = 256; var r = []; return Ci(t, e = e == gi ? 0 : 1, e, i, 0, t.length, r), r })(t.text, e, i); return this.bidiCache.push(new Vn(t.from, t.to, e, i, !0, n)), n } get hasFocus() { var t; return (this.dom.ownerDocument.hasFocus() || y.safari && (null == (t = this.inputState) ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM } focus() { this.observer.ignore(() => { Ae(this.contentDOM), this.docView.updateSelection() }) } setRoot(t) { this._root != t && (this._root = t, this.observer.setWindow((9 == t.nodeType ? t : t.ownerDocument).defaultView || window), this.mountStyles()) } destroy() { for (var t of this.plugins) t.destroy(this); this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), -1 < this.measureScheduled && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0 } static scrollIntoView(t, e = {}) { return zi.of(new Di("number" == typeof t ? g.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin)) } scrollSnapshot() { var { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t); return zi.of(new Di(g.cursor(i.from), "start", "start", i.top - t, e, !0)) } static domEventHandlers(t) { return a.define(() => ({}), { eventHandlers: t }) } static domEventObservers(t) { return a.define(() => ({}), { eventObservers: t }) } static theme(t, e) { var i = Oe.newName(), i = [gn.of(i), nr.of(Qn("." + i, t))]; return e && e.dark && i.push(vn.of(!0)), i } static baseTheme(t) { return vt.lowest(nr.of(Qn("." + wn, t, Sn))) } static findFromDOM(t) { var e = t.querySelector(".cm-content"), e = e && b.get(e) || b.get(t); return (null == (t = null == e ? void 0 : e.rootView) ? void 0 : t.view) || null } }, Yn = ($.styleModule = nr, $.inputHandler = qi, $.focusChangeEffect = _i, $.perLineTextDirection = ji, $.exceptionSink = Vi, $.updateListener = Mi, $.editable = Gi, $.mouseSelectionStyle = Wi, $.dragMovesSelection = Yi, $.clickAddsSelectionRange = Ri, $.decorations = Hi, $.outerDecorations = Ji, $.atomicRanges = Ki, $.bidiIsolatedRanges = tr, $.scrollMargins = ir, $.darkTheme = vn, $.cspNonce = d.define({ combine: t => t.length ? t[0] : "" }), $.contentAttributes = Fi, $.editorAttributes = Li, $.lineWrapping = $.contentAttributes.of({ class: "cm-lineWrapping" }), $.announce = c.define(), 4096), Wn = {}, Vn = class np { constructor(t, e, i, r, n, s) { this.from = t, this.to = e, this.dir = i, this.isolates = r, this.fresh = n, this.order = s } static update(e, i) { if (i.empty && !e.some(t => t.fresh)) return e; var r = [], n = e.length ? e[e.length - 1].dir : k.LTR; for (let t = Math.max(0, e.length - 10); t < e.length; t++) { var s = e[t]; s.dir != n || i.touchesRange(s.from, s.to) || r.push(new np(i.mapPos(s.from, 1), i.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order)) } return r } }; function Mn(i, r, n) { for (let t = i.state.facet(r), e = t.length - 1; 0 <= e; e--) { var s = t[e], s = "function" == typeof s ? s(i) : s; s && ii(s, n) } return n } var qn = y.mac ? "mac" : y.windows ? "win" : y.linux ? "linux" : "key"; function _n(t, e, i) { return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), t = !1 !== i && e.shiftKey ? "Shift-" + t : t } var Ge = vt.default($.domEventHandlers({ keydown(t, e) { return Gn(Dn(e.state), t, e, "editor") } })), jn = d.define({ enables: Ge }), En = new WeakMap; function Dn(t) { t = t.facet(jn); let e = En.get(t); return e || En.set(t, e = ((t, h = qn) => { let a = Object.create(null), r = Object.create(null), l = (t, e) => { var i = r[t]; if (null == i) r[t] = e; else if (i != e) throw new Error("Key binding " + t + " is used both as a regular binding and as a multi-stroke prefix") }, e = (r, t, e, i, n) => { var s = a[r] || (a[r] = Object.create(null)), o = t.split(/ (?!$)/).map(s => { { var o = h, a = s.split(/-(?!$)/); let t = a[a.length - 1]; "Space" == t && (t = " "); let e, i, r, n; for (let t = 0; t < a.length - 1; ++t) { var l = a[t]; if (/^(cmd|meta|m)$/i.test(l)) n = !0; else if (/^a(lt)?$/i.test(l)) e = !0; else if (/^(c|ctrl|control)$/i.test(l)) i = !0; else if (/^s(hift)?$/i.test(l)) r = !0; else { if (!/^mod$/i.test(l)) throw new Error("Unrecognized modifier name: " + l); "mac" == o ? n = !0 : i = !0 } } return e && (t = "Alt-" + t), i && (t = "Ctrl-" + t), n && (t = "Meta-" + t), t = r ? "Shift-" + t : t } }); for (let t = 1; t < o.length; t++) { let i = o.slice(0, t).join(" "); l(i, !0), s[i] || (s[i] = { preventDefault: !0, stopPropagation: !1, run: [t => { let e = zn = { view: t, prefix: i, scope: r }; return setTimeout(() => { zn == e && (zn = null) }, Bn), !0 }] }) } var t = o.join(" "), t = (l(t, !1), s[t] || (s[t] = { preventDefault: !1, stopPropagation: !1, run: (null == (t = null == (t = s._any) ? void 0 : t.run) ? void 0 : t.slice()) || [] })); e && t.run.push(e), i && (t.preventDefault = !0), n && (t.stopPropagation = !0) }; for (var i of t) { var n = i.scope ? i.scope.split(" ") : ["editor"]; if (i.any) for (var s of n) { var o, c = a[s] || (a[s] = Object.create(null)); for (o in c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] }), c) c[o].run.push(i.any) } var d = i[h] || i.key; if (d) for (var O of n) e(O, d, i.run, i.preventDefault, i.stopPropagation), i.shift && e(O, "Shift-" + d, i.shift, i.preventDefault, i.stopPropagation) } return a })(t.reduce((t, e) => t.concat(e), []))), e } var zn = null, Bn = 4e3; function Gn(t, i, r, e) { n = i; var n = n = "Down" == (n = "Right" == (n = "Up" == (n = "Left" == (n = "Del" == (n = "Esc" == (n = !(ge && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || ve && n.shiftKey && n.key && 1 == n.key.length || "Unidentified" == n.key) && n.key || (n.shiftKey ? me : pe)[n.keyCode] || n.key || "Unidentified") ? "Escape" : n) ? "Delete" : n) ? "ArrowLeft" : n) ? "ArrowUp" : n) ? "ArrowRight" : n) ? "ArrowDown" : n, s = K(Q(n, 0)) == n.length && " " != n; let o = "", a = !1, l = !1, h = !1, c = (zn && zn.view == r && zn.scope == e && (o = zn.prefix + " ", Pr.indexOf(i.keyCode) < 0) && (l = !0, zn = null), new Set); var d = t => { if (t) { for (var e of t.run) if (!c.has(e) && (c.add(e), e(r, i))) return t.stopPropagation && (h = !0), !0; t.preventDefault && (t.stopPropagation && (h = !0), l = !0) } return !1 }; let O = t[e], u, f; return O && (d(O[o + _n(n, i, !s)]) ? a = !0 : s && (i.altKey || i.metaKey || i.ctrlKey) && !(y.windows && i.ctrlKey && i.altKey) && (u = pe[i.keyCode]) && u != n ? (d(O[o + _n(u, i, !0)]) || i.shiftKey && (f = me[i.keyCode]) != n && f != u && d(O[o + _n(f, i, !1)])) && (a = !0) : s && i.shiftKey && d(O[o + _n(n, i, !0)]) && (a = !0), !a) && d(O._any) && (a = !0), (a = l ? !0 : a) && h && i.stopPropagation(), a } var In = class sp { constructor(t, e, i, r, n) { this.className = t, this.left = e, this.top = i, this.width = r, this.height = n } draw() { var t = document.createElement("div"); return t.className = this.className, this.adjust(t), t } update(t, e) { return e.className == this.className && (this.adjust(t), !0) } adjust(t) { t.style.left = this.left + "px", t.style.top = this.top + "px", null != this.width && (t.style.width = this.width + "px"), t.style.height = this.height + "px" } eq(t) { return this.left == t.left && this.top == t.top && this.width == t.width && this.height == t.height && this.className == t.className } static forRange(d, O, u) { var f; if (u.empty) return (f = d.coordsAtPos(u.head, u.assoc || 1)) ? (b = Nn(d), [new sp(O, f.left - b.left, f.top - b.top, null, f.bottom - f.top)]) : []; { var w = d; var p = O; var b = u; if (b.to <= w.viewport.from || b.from >= w.viewport.to) return []; let t = Math.max(b.from, w.viewport.from), e = Math.min(b.to, w.viewport.to), m = w.textDirection == k.LTR, i = w.contentDOM, r = i.getBoundingClientRect(), n = Nn(w), s = i.querySelector(".cm-line"), o = s && window.getComputedStyle(s), g = r.left + (o ? parseInt(o.paddingLeft) + Math.min(0, parseInt(o.textIndent)) : 0), v = r.right - (o ? parseInt(o.paddingRight) : 0), a = wr(w, t), l = wr(w, e), h = a.type == li.Text ? a : null, c = l.type == li.Text ? l : null; return h && (w.lineWrapping || a.widgetLineBreaks) && (h = Un(w, t, h)), c && (w.lineWrapping || l.widgetLineBreaks) && (c = Un(w, e, c)), h && c && h.from == c.from ? S(Q(b.from, b.to, h)) : (f = h ? Q(b.from, null, h) : x(a, !1), b = c ? Q(null, b.to, c) : x(l, !0), d = [], (h || a).to < (c || l).from - (h && c ? 1 : 0) || 1 < a.widgetLineBreaks && f.bottom + w.defaultLineHeight / 2 < b.top ? d.push(y(g, f.bottom, v, b.top)) : f.bottom < b.top && w.elementAtHeight((f.bottom + b.top) / 2).type == li.Text && (f.bottom = b.top = (f.bottom + b.top) / 2), S(f).concat(d).concat(S(b))); function y(t, e, i, r) { return new In(p, t - n.left, e - n.top - .01, i - t, r - e + .01) } function S({ top: e, bottom: i, horizontal: r }) { var n = []; for (let t = 0; t < r.length; t += 2)n.push(y(r[t], e, r[t + 1], i)); return n } function Q(i, r, s) { let o = 1e9, a = -1e9, l = []; function n(t, e, i, r, n) { t = w.coordsAtPos(t, t == s.to ? -2 : 2), i = w.coordsAtPos(i, i == s.from ? 2 : -2); t && i && (o = Math.min(t.top, i.top, o), a = Math.max(t.bottom, i.bottom, a), n == k.LTR ? l.push(m && e ? g : t.left, m && r ? v : i.right) : l.push(!m && r ? g : i.left, !m && e ? v : t.right)) } var h, c = null != i ? i : s.from, d = null != r ? r : s.to; for (h of w.visibleRanges) if (h.to > c && h.from < d) for (let t = Math.max(h.from, c), e = Math.min(h.to, d); ;) { var O, u = w.state.doc.lineAt(t); for (O of w.bidiSpans(u)) { var f = O.from + u.from, p = O.to + u.from; if (e <= f) break; p > t && n(Math.max(f, t), null == i && f <= c, Math.min(p, e), null == r && d <= p, O.dir) } if ((t = u.to + 1) >= e) break } return 0 == l.length && n(c, null == i, d, null == r, w.textDirection), { top: o, bottom: a, horizontal: l } } function x(t, e) { e = r.top + (e ? t.top : t.bottom); return { top: e, bottom: e, horizontal: [] } } return } } }; function Nn(t) { var e = t.scrollDOM.getBoundingClientRect(); return { left: (t.textDirection == k.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY } } function Un(t, e, i) { e = g.cursor(e); return { from: Math.max(i.from, t.moveToLineBoundary(e, !1, !0).from), to: Math.min(i.to, t.moveToLineBoundary(e, !0, !0).from), type: li.Text } } var Ln = class { constructor(t, e) { this.view = t, this.layer = e, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = t.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), e.above && this.dom.classList.add("cm-layer-above"), e.class && this.dom.classList.add(e.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(t.state), t.requestMeasure(this.measureReq), e.mount && e.mount(this.dom, t) } update(t) { t.startState.facet(Fn) != t.state.facet(Fn) && this.setOrder(t.state), (this.layer.update(t, this.dom) || t.geometryChanged) && (this.scale(), t.view.requestMeasure(this.measureReq)) } setOrder(t) { let e = 0, i = t.facet(Fn); for (; e < i.length && i[e] != this.layer;)e++; this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - e) } measure() { return this.layer.markers(this.view) } scale() { var { scaleX: t, scaleY: e } = this.view; t == this.scaleX && e == this.scaleY || (this.scaleX = t, this.scaleY = e, this.dom.style.transform = `scale(${1 / t}, ${1 / e})`) } draw(i) { if (i.length != this.drawn.length || i.some((t, e) => (t = t, e = this.drawn[e], !(t.constructor == e.constructor && t.eq(e))))) { let t = this.dom.firstChild, e = 0; for (var r of i) r.update && t && r.constructor && this.drawn[e].constructor && r.update(t, this.drawn[e]) ? (t = t.nextSibling, e++) : this.dom.insertBefore(r.draw(), t); for (; t;) { var n = t.nextSibling; t.remove(), t = n } this.drawn = i } } destroy() { this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove() } }, Fn = d.define(); function Hn(e) { return [a.define(t => new Ln(t, e)), Fn.of(e)] } var Jn = !y.ios, Kn = d.define({ combine(t) { return Bt(t, { cursorBlinkRate: 1200, drawRangeCursor: !0 }, { cursorBlinkRate: (t, e) => Math.min(t, e), drawRangeCursor: (t, e) => t || e }) } }); function ts(t) { return t.startState.facet(Kn) != t.state.facet(Kn) } var es = Hn({ above: !0, markers(t) { var e, i = t.state, r = i.facet(Kn), n = []; for (e of i.selection.ranges) { var s = e == i.selection.main; if (e.empty ? !s || Jn : r.drawRangeCursor) { var o, s = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = e.empty ? e : g.cursor(e.head, e.head > e.anchor ? -1 : 1); for (o of In.forRange(t, s, a)) n.push(o) } } return n }, update(t, e) { t.transactions.some(t => t.selection) && (e.style.animationName = "cm-blink" == e.style.animationName ? "cm-blink2" : "cm-blink"); var i = ts(t); return i && is(t.state, e), t.docChanged || t.selectionSet || i }, mount(t, e) { is(e.state, t) }, class: "cm-cursorLayer" }); function is(t, e) { e.style.animationDuration = t.facet(Kn).cursorBlinkRate + "ms" } var rs = Hn({ above: !1, markers(e) { return e.state.selection.ranges.map(t => t.empty ? [] : In.forRange(e, "cm-selectionBackground", t)).reduce((t, e) => t.concat(e)) }, update(t, e) { return t.docChanged || t.selectionSet || t.viewportChanged || ts(t) }, class: "cm-selectionLayer" }), Ie = { ".cm-line": { "& ::selection": { backgroundColor: "transparent !important" }, "&::selection": { backgroundColor: "transparent !important" } } }, ns = (Jn && (Ie[".cm-line"].caretColor = "transparent !important", Ie[".cm-content"] = { caretColor: "transparent !important" }), vt.highest($.theme(Ie))), ss = c.define({ map(t, e) { return null == t ? null : e.mapPos(t) } }), os = f.define({ create() { return null }, update(t, e) { return null != t && (t = e.changes.mapPos(t)), e.effects.reduce((t, e) => e.is(ss) ? e.value : t, t) } }), as = a.fromClass(class { constructor(t) { this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) } } update(t) { var e, i = t.state.field(os); null == i ? null != this.cursor && (null != (e = this.cursor) && e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(os) != i || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq)) } readPos() { var t, e = this.view, i = e.state.field(os), i = null != i && e.coordsAtPos(i); return i ? (t = e.scrollDOM.getBoundingClientRect(), { left: i.left - t.left + e.scrollDOM.scrollLeft * e.scaleX, top: i.top - t.top + e.scrollDOM.scrollTop * e.scaleY, height: i.bottom - i.top }) : null } drawCursor(t) { var e, i; this.cursor && ({ scaleX: e, scaleY: i } = this.view, t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / i + "px", this.cursor.style.height = t.height / i + "px") : this.cursor.style.left = "-100000px") } destroy() { this.cursor && this.cursor.remove() } setDropPos(t) { this.view.state.field(os) != t && this.view.dispatch({ effects: ss.of(t) }) } }, { eventObservers: { dragover(t) { this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY })) }, dragleave(t) { t.target != this.view.contentDOM && this.view.contentDOM.contains(t.relatedTarget) || this.setDropPos(null) }, dragend() { this.setDropPos(null) }, drop() { this.setDropPos(null) } } }); function ls(r, n, s, o, a) { n.lastIndex = 0; for (let t = r.iterRange(s, o), e = s, i; !t.next().done; e += t.value.length)if (!t.lineBreak) for (; i = n.exec(t.value);)a(e + i.index, i) } var hs = class { constructor(t) { let { regexp: e, decoration: n, decorate: s, boundary: i, maxLength: r = 1e3 } = t; if (!e.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set"); if (this.regexp = e, s) this.addMatch = (t, e, i, r) => s(r, i, i + t[0].length, t, e); else if ("function" == typeof n) this.addMatch = (t, e, i, r) => { e = n(t, e, i); e && r(i, i + t[0].length, e) }; else { if (!n) throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator"); this.addMatch = (t, e, i, r) => r(i, i + t[0].length, n) } this.boundary = i, this.maxLength = r } createDeco(i) { let t = new Lt, r = t.add.bind(t); for (var { from: e, to: n } of ((t, e) => { var i = t.visibleRanges; if (1 == i.length && i[0].from == t.viewport.from && i[0].to == t.viewport.to) return i; var r, n, s = []; for ({ from: r, to: n } of i) r = Math.max(t.state.doc.lineAt(r).from, r - e), n = Math.min(t.state.doc.lineAt(n).to, n + e), s.length && s[s.length - 1].to >= r ? s[s.length - 1].to = n : s.push({ from: r, to: n }); return s })(i, this.maxLength)) ls(i.state.doc, this.regexp, e, n, (t, e) => this.addMatch(e, i, t, r)); return t.finish() } updateDeco(n, t) { let s = 1e9, o = -1; return n.docChanged && n.changes.iterChanges((t, e, i, r) => { r > n.view.viewport.from && i < n.view.viewport.to && (s = Math.min(i, s), o = Math.max(r, o)) }), n.viewportChanged || 1e3 < o - s ? this.createDeco(n.view) : -1 < o ? this.updateRange(n.view, t.map(n.changes), s, o) : t } updateRange(a, l, t, i) { for (var h of a.visibleRanges) { let e = Math.max(h.from, t), o = Math.min(h.to, i); if (o > e) { var c = a.state.doc.lineAt(e), d = c.to < o ? a.state.doc.lineAt(o) : c; let i = Math.max(h.from, c.from), r = Math.min(h.to, d.to); if (this.boundary) { for (; e > c.from; e--)if (this.boundary.test(c.text[e - 1 - c.from])) { i = e; break } for (; o < d.to; o++)if (this.boundary.test(d.text[o - d.from])) { r = o; break } } let n = [], t, s = (t, e, i) => n.push(i.range(t, e)); if (c == d) for (this.regexp.lastIndex = i - c.from; (t = this.regexp.exec(c.text)) && t.index < r - c.from;)this.addMatch(t, a, t.index + c.from, s); else ls(a.state.doc, this.regexp, i, r, (t, e) => this.addMatch(e, a, t, s)); l = l.update({ filterFrom: i, filterTo: r, filter: (t, e) => t < i || e > r, add: n }) } } return l } }, cs = null != /x/.unicode ? "gu" : "g", ds = new RegExp("[\0-\b\n--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\ufeffï¿¹-ï¿¼]", cs), Os = { 0: "null", 7: "bell", 8: "backspace", 10: "newline", 11: "vertical tab", 13: "carriage return", 27: "escape", 8203: "zero width space", 8204: "zero width non-joiner", 8205: "zero width joiner", 8206: "left-to-right mark", 8207: "right-to-left mark", 8232: "line separator", 8237: "left-to-right override", 8238: "right-to-left override", 8294: "left-to-right isolate", 8295: "right-to-left isolate", 8297: "pop directional isolate", 8233: "paragraph separator", 65279: "zero width no-break space", 65532: "object replacement" }, us = null; var fs = d.define({ combine(t) { var e, i, t = Bt(t, { render: null, specialChars: ds, addSpecialChars: null }); return (t.replaceTabs = (null == us && "undefined" != typeof document && document.body && (i = document.body.style, us = null != (null != (e = i.tabSize) ? e : i.MozTabSize)), !us)) && (t.specialChars = new RegExp("\t|" + t.specialChars.source, cs)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, cs)), t } }); function ps(t = {}) { return [fs.of(t), ms = ms || a.fromClass(class { constructor(t) { this.view = t, this.decorations = S.none, this.decorationCache = Object.create(null), this.decorator = this.makeDecorator(t.state.facet(fs)), this.decorations = this.decorator.createDeco(t) } makeDecorator(n) { return new hs({ regexp: n.specialChars, decoration: (t, e, i) => { var r = e.state.doc, t = Q(t[0], 0); return 9 == t ? (r = r.lineAt(i), e = e.state.tabSize, i = oe(r.text, e, i - r.from), S.replace({ widget: new vs((e - i % e) * this.view.defaultCharacterWidth / this.view.scaleX) })) : this.decorationCache[t] || (this.decorationCache[t] = S.replace({ widget: new gs(n, t) })) }, boundary: n.replaceTabs ? void 0 : /[^]/ }) } update(t) { var e = t.state.facet(fs); t.startState.facet(fs) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations) } }, { decorations: t => t.decorations })] } var ms = null; var gs = class extends Ne { constructor(t, e) { super(), this.options = t, this.code = e } eq(t) { return t.code == this.code } toDOM(t) { var e = 32 <= (e = this.code) ? "â€¢" : 10 == e ? "â¤" : String.fromCharCode(9216 + e), t = t.state.phrase("Control character") + " " + (Os[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, t, e); return i || ((i = document.createElement("span")).textContent = e, i.title = t, i.setAttribute("aria-label", t), i.className = "cm-specialChar", i) } ignoreEvent() { return !1 } }, vs = class extends Ne { constructor(t) { super(), this.width = t } eq(t) { return t.width == this.width } toDOM() { var t = document.createElement("span"); return t.textContent = "\t", t.className = "cm-tab", t.style.width = this.width + "px", t } ignoreEvent() { return !1 } }; var ws = S.line({ class: "cm-activeLine" }), bs = a.fromClass(class { constructor(t) { this.decorations = this.getDeco(t) } update(t) { (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view)) } getDeco(t) { let e = -1, i = []; for (var r of t.state.selection.ranges) { r = t.lineBlockAt(r.head); r.from > e && (i.push(ws.range(r.from)), e = r.from) } return S.set(i) } }, { decorations: t => t.decorations }), ys = 2e3; function Ss(t, e) { var i, r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = t.state.doc.lineAt(r), s = r - n.from, o = ys < s ? -1 : s == n.length ? (i = t, e = e.clientX, (o = i.coordsAtPos(i.viewport.from)) ? Math.round(Math.abs((o.left - e) / i.defaultCharacterWidth)) : -1) : oe(n.text, t.state.tabSize, r - n.from); return { line: n.number, col: o, off: s } } function Qs(r, t) { let n = Ss(r, t), s = r.state.selection; return n ? { update(t) { var e; t.docChanged && (e = t.changes.mapPos(t.startState.doc.line(n.line).from), e = t.state.doc.lineAt(e), n = { line: e.number, col: n.col, off: Math.min(n.off, e.length) }, s = s.map(t.changes)) }, get(t, e, i) { var t = Ss(r, t); return t && (t = ((e, t, i) => { var r = Math.min(t.line, i.line), n = Math.max(t.line, i.line), s = []; if (t.off > ys || i.off > ys || t.col < 0 || i.col < 0) { var o = Math.min(t.off, i.off), a = Math.max(t.off, i.off); for (let t = r; t <= n; t++) { var l = e.doc.line(t); l.length <= a && s.push(g.range(l.from + o, l.to + a)) } } else { var h = Math.min(t.col, i.col), c = Math.max(t.col, i.col); for (let t = r; t <= n; t++) { var d, O = e.doc.line(t), u = ae(O.text, h, e.tabSize, !0); u < 0 ? s.push(g.cursor(O.to)) : (d = ae(O.text, c, e.tabSize), s.push(g.range(O.from + u, O.from + d))) } } return s })(r.state, n, t)).length ? i ? g.create(t.concat(s.ranges)) : g.create(t) : s } } : null } var xs = { Alt: [18, t => !!t.altKey], Control: [17, t => !!t.ctrlKey], Shift: [16, t => !!t.shiftKey], Meta: [91, t => !!t.metaKey] }, ks = { style: "cursor: crosshair" }; var $s = "-10000px", Ps = class { constructor(t, e, i) { this.facet = e, this.createTooltipView = i, this.input = t.state.facet(e), this.tooltips = this.input.filter(t => t), this.tooltipViews = this.tooltips.map(i) } update(r, n) { var t, e = r.state.facet(this.facet), s = e.filter(t => t); if (e === this.input) { for (var i of this.tooltipViews) i.update && i.update(r); return !1 } var o, a, l = [], h = n ? [] : null; for (let t = 0; t < s.length; t++) { let e = s[t], i = -1; if (e) { for (let t = 0; t < this.tooltips.length; t++) { var c = this.tooltips[t]; c && c.create == e.create && (i = t) } i < 0 ? (l[t] = this.createTooltipView(e), h && (h[t] = !!e.above)) : (o = l[t] = this.tooltipViews[i], h && (h[t] = n[i]), o.update && o.update(r)) } } for (a of this.tooltipViews) l.indexOf(a) < 0 && (a.dom.remove(), null != (t = a.destroy)) && t.call(a); return n && (h.forEach((t, e) => n[e] = t), n.length = h.length), this.input = e, this.tooltips = s, this.tooltipViews = l, !0 } }; function Zs(t) { t = t.win; return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth } } var Ts = d.define({ combine: t => { var e; return { position: y.ios ? "absolute" : (null == (e = t.find(t => t.position)) ? void 0 : e.position) || "fixed", parent: (null == (e = t.find(t => t.parent)) ? void 0 : e.parent) || null, tooltipSpace: (null == (e = t.find(t => t.tooltipSpace)) ? void 0 : e.tooltipSpace) || Zs } } }), Cs = new WeakMap, Xs = a.fromClass(class { constructor(t) { this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1; var e = t.state.facet(Ts); this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new Ps(t, Rs, t => this.createTooltip(t)), this.intersectionObserver = "function" == typeof IntersectionObserver ? new IntersectionObserver(t => { Date.now() > this.lastTransaction - 50 && 0 < t.length && t[t.length - 1].intersectionRatio < 1 && this.measureSoon() }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure() } createContainer() { this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom } observeIntersection() { if (this.intersectionObserver) { this.intersectionObserver.disconnect(); for (var t of this.manager.tooltipViews) this.intersectionObserver.observe(t.dom) } } measureSoon() { this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => { this.measureTimeout = -1, this.maybeMeasure() }, 50)) } update(t) { t.transactions.length && (this.lastTransaction = Date.now()); var e = this.manager.update(t, this.above); e && this.observeIntersection(); let i = e || t.geometryChanged; e = t.state.facet(Ts); if (e.position != this.position && !this.madeAbsolute) { this.position = e.position; for (var r of this.manager.tooltipViews) r.dom.style.position = this.position; i = !0 } if (e.parent != this.parent) { this.parent && this.container.remove(), this.parent = e.parent, this.createContainer(); for (var n of this.manager.tooltipViews) this.container.appendChild(n.dom); i = !0 } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses); i && this.maybeMeasure() } createTooltip(t) { var e = t.create(this.view); return e.dom.classList.add("cm-tooltip"), t.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow") && ((t = document.createElement("div")).className = "cm-tooltip-arrow", e.dom.appendChild(t)), e.dom.style.position = this.position, e.dom.style.top = $s, e.dom.style.left = "0px", this.container.appendChild(e.dom), e.mount && e.mount(this.view), e } destroy() { var t, e, i; this.view.win.removeEventListener("resize", this.measureSoon); for (i of this.manager.tooltipViews) i.dom.remove(), null != (t = i.destroy) && t.call(i); this.parent && this.container.remove(), null != (e = this.intersectionObserver) && e.disconnect(), clearTimeout(this.measureTimeout) } readMeasure() { var t, e = this.view.dom.getBoundingClientRect(); let i = 1, r = 1, n = !1; return "fixed" == this.position && this.manager.tooltipViews.length && (t = this.manager.tooltipViews[0].dom, y.gecko ? n = t.offsetParent != this.container.ownerDocument.body : t.style.top == $s && "0px" == t.style.left && (t = t.getBoundingClientRect(), n = 1 < Math.abs(t.top + 1e4) || 1 < Math.abs(t.left))), !n && "absolute" != this.position || (this.parent ? (t = this.parent.getBoundingClientRect()).width && t.height && (i = t.width / this.parent.offsetWidth, r = t.height / this.parent.offsetHeight) : { scaleX: i, scaleY: r } = this.view.viewState), { editor: e, parent: this.parent ? this.container.getBoundingClientRect() : e, pos: this.manager.tooltips.map((t, e) => { e = this.manager.tooltipViews[e]; return e.getCoords ? e.getCoords(t.pos) : this.view.coordsAtPos(t.pos) }), size: this.manager.tooltipViews.map(({ dom: t }) => t.getBoundingClientRect()), space: this.view.state.facet(Ts).tooltipSpace(this.view), scaleX: i, scaleY: r, makeAbsolute: n } } writeMeasure(s) { if (s.makeAbsolute) { this.madeAbsolute = !0, this.position = "absolute"; for (var t of this.manager.tooltipViews) t.dom.style.position = "absolute" } var { editor: e, space: o, scaleX: a, scaleY: l } = s, h = []; for (let n = 0; n < this.manager.tooltips.length; n++) { var c = this.manager.tooltips[n], d = this.manager.tooltipViews[n], O = d.dom, u = s.pos[n], f = s.size[n]; if (!u || u.bottom <= Math.max(e.top, o.top) || u.top >= Math.min(e.bottom, o.bottom) || u.right < Math.max(e.left, o.left) - .1 || u.left > Math.min(e.right, o.right) + .1) O.style.top = $s; else { var p = c.arrow ? d.dom.querySelector(".cm-tooltip-arrow") : null, m = p ? 7 : 0; let t = f.right - f.left, e = null != (g = Cs.get(d)) ? g : f.bottom - f.top; var g = d.offset || As, v = this.view.textDirection == k.LTR, w = f.width > o.right - o.left ? v ? o.left : o.right - f.width : v ? Math.min(u.left - (p ? 14 : 0) + g.x, o.right - t) : Math.max(o.left, u.left - t + (p ? 14 : 0) - g.x); let i = this.above[n]; c = ((i = !c.strictSide && (i ? u.top - (f.bottom - f.top) - g.y < o.top : u.bottom + (f.bottom - f.top) + g.y > o.bottom) && i == o.bottom - u.bottom > u.top - o.top ? this.above[n] = !i : i) ? u.top - o.top : o.bottom - u.bottom) - m; if (c < e && !1 !== d.resize) { if (c < this.view.defaultLineHeight) { O.style.top = $s; continue } Cs.set(d, e), O.style.height = (e = c) / l + "px" } else O.style.height && (O.style.height = ""); let r = i ? u.top - e - m - g.y : u.bottom + m + g.y; var b = w + t; if (!0 !== d.overlap) for (var y of h) y.left < b && y.right > w && y.top < r + e && y.bottom > r && (r = i ? y.top - e - 2 - m : y.bottom + m + 2); "absolute" == this.position ? (O.style.top = (r - s.parent.top) / l + "px", O.style.left = (w - s.parent.left) / a + "px") : (O.style.top = r / l + "px", O.style.left = w / a + "px"), p && (f = u.left + (v ? g.x : -g.x) - (w + 14 - 7), p.style.left = f / a + "px"), !0 !== d.overlap && h.push({ left: w, top: r, right: b, bottom: r + e }), O.classList.toggle("cm-tooltip-above", i), O.classList.toggle("cm-tooltip-below", !i), d.positioned && d.positioned(s.space) } } } maybeMeasure() { if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView) && (this.inView = this.view.inView, !this.inView)) for (var t of this.manager.tooltipViews) t.dom.style.top = $s } }, { eventObservers: { scroll() { this.maybeMeasure() } } }), e = $.baseTheme({ ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" }, "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" }, "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" }, "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" }, ".cm-tooltip-arrow": { height: "7px", width: "14px", position: "absolute", zIndex: -1, overflow: "hidden", "&:before, &:after": { content: "''", position: "absolute", width: 0, height: 0, borderLeft: "7px solid transparent", borderRight: "7px solid transparent" }, ".cm-tooltip-above &": { bottom: "-7px", "&:before": { borderTop: "7px solid #bbb" }, "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" } }, ".cm-tooltip-below &": { top: "-7px", "&:before": { borderBottom: "7px solid #bbb" }, "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" } } }, "&dark .cm-tooltip .cm-tooltip-arrow": { "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" }, "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" } } }), As = { x: 0, y: 0 }, Rs = d.define({ enables: [Xs, e] }), Ys = d.define(), Ws = class op { static create(t) { return new op(t) } constructor(t) { this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Ps(t, Ys, t => this.createHostedView(t)) } createHostedView(t) { t = t.create(this.view); return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t } mount(t) { for (var e of this.manager.tooltipViews) e.mount && e.mount(t); this.mounted = !0 } positioned(t) { for (var e of this.manager.tooltipViews) e.positioned && e.positioned(t) } update(t) { this.manager.update(t) } destroy() { var t, e; for (e of this.manager.tooltipViews) null != (t = e.destroy) && t.call(e) } passProp(t) { let e = void 0; for (var i of this.manager.tooltipViews) { i = i[t]; if (void 0 !== i) if (void 0 === e) e = i; else if (e !== i) return } return e } get offset() { return this.passProp("offset") } get getCoords() { return this.passProp("getCoords") } get overlap() { return this.passProp("overlap") } get resize() { return this.passProp("resize") } }, Vs = Rs.compute([Ys], t => { t = t.facet(Ys).filter(t => t); return 0 === t.length ? null : { pos: Math.min(...t.map(t => t.pos)), end: Math.max(...t.map(t => { var e; return null != (e = t.end) ? e : t.pos })), create: Ws.create, above: t[0].above, arrow: t.some(t => t.arrow) } }), Ms = class { constructor(t, e, i, r, n) { this.view = t, this.source = e, this.field = i, this.setHover = r, this.hoverTime = n, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this)) } update() { this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20)) } get active() { return this.view.state.field(this.field) } checkHover() { var t; this.hoverTimeout = -1, this.active || ((t = Date.now() - this.lastMove.time) < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover()) } startHover() { clearTimeout(this.restartTimeout); let { view: r, lastMove: e } = this; var n = r.docView.nearest(e.target); if (n) { let i, t = 1; if (n instanceof Je) i = n.posAtStart; else { if (null == (i = r.posAtCoords(e))) return; n = r.coordsAtPos(i); if (!n || e.y < n.top || e.y > n.bottom || e.x < n.left - r.defaultCharacterWidth || e.x > n.right + r.defaultCharacterWidth) return; var s = r.bidiSpans(r.state.doc.lineAt(i)).find(t => t.from <= i && t.to >= i), s = s && s.dir == k.RTL ? -1 : 1; t = e.x < n.left ? -s : s } n = this.source(r, i, t); if (null != n && n.then) { let e = this.pending = { pos: i }; n.then(t => { this.pending == e && (this.pending = null, t) && r.dispatch({ effects: this.setHover.of(t) }) }, t => Bi(r.state, t, "hover tooltip")) } else n && r.dispatch({ effects: this.setHover.of(n) }) } } get tooltip() { var t = this.view.plugin(Xs), e = t ? t.manager.tooltips.findIndex(t => t.create == Ws.create) : -1; return -1 < e ? t.manager.tooltipViews[e] : null } mousemove(t) { this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime)); var { active: e, tooltip: i } = this; (e && i && !((t, e) => (t = t.getBoundingClientRect(), e.clientX >= t.left - qs && e.clientX <= t.right + qs && e.clientY >= t.top - qs && e.clientY <= t.bottom + qs))(i.dom, t) || this.pending) && (i = (e || this.pending).pos, i == (e = null != (e = null == e ? void 0 : e.end) ? e : i) ? this.view.posAtCoords(this.lastMove) != i : !((t, e, i, r, n) => { var s = t.scrollDOM.getBoundingClientRect(), o = t.documentTop + t.documentPadding.top + t.contentHeight; return !(s.left > r || s.right < r || s.top > n || Math.min(s.bottom, o) < n) && (s = t.posAtCoords({ x: r, y: n }, !1), e <= s) && s <= i })(this.view, i, e, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null) } mouseleave(t) { clearTimeout(this.hoverTimeout), this.hoverTimeout = -1; var e = this.active; e && (e = this.tooltip, e && e.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(e.dom) : this.view.dispatch({ effects: this.setHover.of(null) })) } watchTooltipLeave(e) { let i = t => { e.removeEventListener("mouseleave", i), this.active && !this.view.dom.contains(t.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) }) }; e.addEventListener("mouseleave", i) } destroy() { clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove) } }, qs = 4; function _s(e, s = {}) { let o = c.define(), i = f.define({ create() { return null }, update(t, e) { if (t && (s.hideOnChange && (e.docChanged || e.selection) || s.hideOn && s.hideOn(e, t))) return null; if (t && e.docChanged) { var i = e.changes.mapPos(t.pos, -1, h.TrackDel); if (null == i) return null; var r = Object.assign(Object.create(null), t); r.pos = i, null != t.end && (r.end = e.changes.mapPos(t.end)), t = r } for (var n of e.effects) n.is(o) && (t = n.value), n.is(Es) && (t = null); return t }, provide: t => Ys.from(t) }); return [i, a.define(t => new Ms(t, e, i, o, s.hoverTime || 300)), Vs] } function js(t, e) { t = t.plugin(Xs); return !t || (e = t.manager.tooltips.indexOf(e)) < 0 ? null : t.manager.tooltipViews[e] } var Es = c.define(), Ds = d.define({ combine(t) { let e, i; for (var r of t) e = e || r.topContainer, i = i || r.bottomContainer; return { topContainer: e, bottomContainer: i } } }); function zs(t, e) { t = t.plugin(Bs), e = t ? t.specs.indexOf(e) : -1; return -1 < e ? t.panels[e] : null } var Bs = a.fromClass(class { constructor(e) { this.input = e.state.facet(Ns), this.specs = this.input.filter(t => t), this.panels = this.specs.map(t => t(e)); var t, i = e.state.facet(Ds); this.top = new Gs(e, !0, i.topContainer), this.bottom = new Gs(e, !1, i.bottomContainer), this.top.sync(this.panels.filter(t => t.top)), this.bottom.sync(this.panels.filter(t => !t.top)); for (t of this.panels) t.dom.classList.add("cm-panel"), t.mount && t.mount() } update(i) { var t = i.state.facet(Ds), t = (this.top.container != t.topContainer && (this.top.sync([]), this.top = new Gs(i.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new Gs(i.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses(), i.state.facet(Ns)); if (t != this.input) { var r, e, t = t.filter(t => t), n = [], s = [], o = [], a = []; for (r of t) { let t = this.specs.indexOf(r), e; t < 0 ? (e = r(i.view), a.push(e)) : (e = this.panels[t]).update && e.update(i), n.push(e), (e.top ? s : o).push(e) } this.specs = t, this.panels = n, this.top.sync(s), this.bottom.sync(o); for (e of a) e.dom.classList.add("cm-panel"), e.mount && e.mount() } else for (var l of this.panels) l.update && l.update(i) } destroy() { this.top.sync([]), this.bottom.sync([]) } }, { provide: e => $.scrollMargins.of(t => { t = t.plugin(e); return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() } }) }), Gs = class { constructor(t, e, i) { this.view = t, this.top = e, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses() } sync(t) { for (var e of this.panels) e.destroy && t.indexOf(e) < 0 && e.destroy(); this.panels = t, this.syncDOM() } syncDOM() { if (0 == this.panels.length) this.dom && (this.dom.remove(), this.dom = void 0); else { var e, i; this.dom || (this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0", (e = this.container || this.view.dom).insertBefore(this.dom, this.top ? e.firstChild : null)); let t = this.dom.firstChild; for (i of this.panels) if (i.dom.parentNode == this.dom) { for (; t != i.dom;)t = Is(t); t = t.nextSibling } else this.dom.insertBefore(i.dom, t); for (; t;)t = Is(t) } } scrollMargin() { return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top) } syncClasses() { if (this.container && this.classes != this.view.themeClasses) { for (var t of this.classes.split(" ")) t && this.container.classList.remove(t); for (var e of (this.classes = this.view.themeClasses).split(" ")) e && this.container.classList.add(e) } } }; function Is(t) { var e = t.nextSibling; return t.remove(), e } var Ns = d.define({ enables: Bs }), Ue = class extends Gt { compare(t) { return this == t || this.constructor == t.constructor && this.eq(t) } eq(t) { return !1 } destroy(t) { } }, Us = (Ue.prototype.elementClass = "", Ue.prototype.toDOM = void 0, Ue.prototype.mapMode = h.TrackBefore, Ue.prototype.startSide = Ue.prototype.endSide = -1, d.define()), Ls = { class: "", renderEmptyElements: !(Ue.prototype.point = !0), elementStyle: "", markers: () => w.empty, lineMarker: () => null, widgetMarker: () => null, lineMarkerChange: null, initialSpacer: null, updateSpacer: null, domEventHandlers: {} }, Fs = d.define(); var Hs = d.define({ combine: t => t.some(t => t) }); function Js(t) { var e = [Ks]; return t && !1 === t.fixed && e.push(Hs.of(!0)), e } var Ks = a.fromClass(class { constructor(e) { this.view = e, this.prevViewport = e.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = e.state.facet(Fs).map(t => new ro(e, t)); for (var t of this.gutters) this.dom.appendChild(t.dom); this.fixed = !e.state.facet(Hs), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), e.scrollDOM.insertBefore(this.dom, e.contentDOM) } update(t) { var e, i; this.updateGutters(t) && (i = this.prevViewport, e = t.view.viewport, i = Math.min(i.to, e.to) - Math.max(i.from, e.from), this.syncGutters(i < .8 * (e.to - e.from))), t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Hs) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport } syncGutters(t) { var e = this.dom.nextSibling, i = (t && this.dom.remove(), w.iter(this.view.state.facet(Us), this.view.viewport.from)); let r = []; var n, s, o = this.gutters.map(t => new io(t, this.view.viewport, -this.view.documentPadding.top)); for (n of this.view.viewportLineBlocks) if (r.length && (r = []), Array.isArray(n.type)) { let t = !0; for (var a of n.type) if (a.type == li.Text && t) { eo(i, r, a.from); for (var l of o) l.line(this.view, a, r); t = !1 } else if (a.widget) for (var h of o) h.widget(this.view, a) } else if (n.type == li.Text) { eo(i, r, n.from); for (var c of o) c.line(this.view, n, r) } else if (n.widget) for (var d of o) d.widget(this.view, n); for (s of o) s.finish(); t && this.view.scrollDOM.insertBefore(this.dom, e) } updateGutters(t) { var e = t.startState.facet(Fs), i = t.state.facet(Fs); let r = t.docChanged || t.heightChanged || t.viewportChanged || !w.eq(t.startState.facet(Us), t.state.facet(Us), t.view.viewport.from, t.view.viewport.to); if (e == i) for (var n of this.gutters) n.update(t) && (r = !0); else { r = !0; var s, o, a, l = []; for (s of i) { var h = e.indexOf(s); h < 0 ? l.push(new ro(this.view, s)) : (this.gutters[h].update(t), l.push(this.gutters[h])) } for (o of this.gutters) o.dom.remove(), l.indexOf(o) < 0 && o.destroy(); for (a of l) this.dom.appendChild(a.dom); this.gutters = l } return r } destroy() { for (var t of this.gutters) t.destroy(); this.dom.remove() } }, { provide: i => $.scrollMargins.of(t => { var e = t.plugin(i); return e && 0 != e.gutters.length && e.fixed ? t.textDirection == k.LTR ? { left: e.dom.offsetWidth * t.scaleX } : { right: e.dom.offsetWidth * t.scaleX } : null }) }); function to(t) { return Array.isArray(t) ? t : [t] } function eo(t, e, i) { for (; t.value && t.from <= i;)t.from == i && e.push(t.value), t.next() } var io = class { constructor(t, e, i) { this.gutter = t, this.height = i, this.i = 0, this.cursor = w.iter(t.markers, e.from) } addElement(t, e, i) { var r, n = this.gutter, s = (e.top - this.height) / t.scaleY, o = e.height / t.scaleY; this.i == n.elements.length ? (r = new no(t, o, s, i), n.elements.push(r), n.dom.appendChild(r.dom)) : n.elements[this.i].update(t, o, s, i), this.height = e.bottom, this.i++ } line(t, e, i) { let r = []; eo(this.cursor, r, e.from), i.length && (r = r.concat(i)); i = this.gutter.config.lineMarker(t, e, r), i && r.unshift(i), i = this.gutter; 0 == r.length && !i.config.renderEmptyElements || this.addElement(t, e, r) } widget(t, e) { var i = this.gutter.config.widgetMarker(t, e.widget, e); i && this.addElement(t, e, [i]) } finish() { for (var t = this.gutter; t.elements.length > this.i;) { var e = t.elements.pop(); t.dom.removeChild(e.dom), e.destroy() } } }, ro = class { constructor(s, o) { this.view = s, this.config = o, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""); for (let n in o.domEventHandlers) this.dom.addEventListener(n, t => { let e = t.target, i; if (e != this.dom && this.dom.contains(e)) { for (; e.parentNode != this.dom;)e = e.parentNode; var r = e.getBoundingClientRect(); i = (r.top + r.bottom) / 2 } else i = t.clientY; r = s.lineBlockAtHeight(i - s.documentTop); o.domEventHandlers[n](s, r, t) && t.preventDefault() }); this.markers = to(o.markers(s)), o.initialSpacer && (this.spacer = new no(s, 0, 0, [o.initialSpacer(s)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none") } update(t) { var e = this.markers, i = (this.markers = to(this.config.markers(t.view)), this.spacer && this.config.updateSpacer && (i = this.config.updateSpacer(this.spacer.markers[0], t)) != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [i]), t.view.viewport); return !w.eq(this.markers, e, i.from, i.to) || !!this.config.lineMarkerChange && this.config.lineMarkerChange(t) } destroy() { for (var t of this.elements) t.destroy() } }, no = class { constructor(t, e, i, r) { this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, e, i, r) } update(t, e, i, r) { this.height != e && (this.height = e, this.dom.style.height = e + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), ((e, i) => { if (e.length == i.length) { for (let t = 0; t < e.length; t++)if (!e[t].compare(i[t])) return; return 1 } })(this.markers, r) || this.setMarkers(t, r) } setMarkers(s, o) { let a = "cm-gutterElement", l = this.dom.firstChild; for (let t = 0, n = 0; ;) { let e = n, i = t < o.length ? o[t++] : null, r = !1; if (i) { var h = i.elementClass; h && (a += " " + h); for (let t = n; t < this.markers.length; t++)if (this.markers[t].compare(i)) { e = t, r = !0; break } } else e = this.markers.length; for (; n < e;) { var c = this.markers[n++]; c.toDOM && (c.destroy(l), c = l.nextSibling, l.remove(), l = c) } if (!i) break; i.toDOM && (r ? l = l.nextSibling : this.dom.insertBefore(i.toDOM(s), l)), r && n++ } this.dom.className = a, this.markers = o } destroy() { this.setMarkers(null, []) } }; var so = d.define(), oo = d.define({ combine(t) { return Bt(t, { formatNumber: String, domEventHandlers: {} }, { domEventHandlers(t, e) { var i, s = Object.assign({}, t); for (i in e) { let r = s[i], n = e[i]; s[i] = r ? (t, e, i) => r(t, e, i) || n(t, e, i) : n } return s } }) } }), ao = class extends Ue { constructor(t) { super(), this.number = t } eq(t) { return this.number == t.number } toDOM() { return document.createTextNode(this.number) } }; function lo(t, e) { return t.state.facet(oo).formatNumber(e, t.state) } var ho = Fs.compute([oo], t => ({ class: "cm-lineNumbers", renderEmptyElements: !1, markers(t) { return t.state.facet(so) }, lineMarker(t, e, i) { return i.some(t => t.toDOM) ? null : new ao(lo(t, t.state.doc.lineAt(e.from).number)) }, widgetMarker: () => null, lineMarkerChange: t => t.startState.facet(oo) != t.state.facet(oo), initialSpacer(t) { return new ao(lo(t, co(t.state.doc.lines))) }, updateSpacer(t, e) { e = lo(e.view, co(e.view.state.doc.lines)); return e == t.number ? t : new ao(e) }, domEventHandlers: t.facet(oo).domEventHandlers })); function co(t) { let e = 9; for (; e < t;)e = 10 * e + 9; return e } var Oo = new class extends Ue { constructor() { super(...arguments), this.elementClass = "cm-activeLineGutter" } }, uo = Us.compute(["selection"], t => { let e = [], i = -1; for (var r of t.selection.ranges) { r = t.doc.lineAt(r.head).from; r > i && (i = r, e.push(Oo.range(r))) } return w.of(e) }); var P, fo = 0, po = class { constructor(t, e) { this.from = t, this.to = e } }, z = class { constructor(t = {}) { this.id = fo++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => { throw new Error("This node type doesn't define a deserialize function") }) } add(e) { if (this.perNode) throw new RangeError("Can't add per-node props to node types"); return "function" != typeof e && (e = vo.match(e)), t => { t = e(t); return void 0 === t ? null : [this, t] } } }, mo = (z.closedBy = new z({ deserialize: t => t.split(" ") }), z.openedBy = new z({ deserialize: t => t.split(" ") }), z.group = new z({ deserialize: t => t.split(" ") }), z.isolate = new z({ deserialize: t => { if (t && "rtl" != t && "ltr" != t && "auto" != t) throw new RangeError("Invalid value for isolate: " + t); return t || "auto" } }), z.contextHash = new z({ perNode: !0 }), z.lookAhead = new z({ perNode: !0 }), z.mounted = new z({ perNode: !0 }), class { constructor(t, e, i) { this.tree = t, this.overlay = e, this.parser = i } static get(t) { return t && t.props && t.props[z.mounted.id] } }), go = Object.create(null), vo = class ap { constructor(t, e, i, r = 0) { this.name = t, this.props = e, this.id = i, this.flags = r } static define(t) { var e = t.props && t.props.length ? Object.create(null) : go, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (null == t.name ? 8 : 0), r = new ap(t.name || "", e, t.id, i); if (t.props) for (var n of t.props) if (n = Array.isArray(n) ? n : n(r)) { if (n[0].perNode) throw new RangeError("Can't store a per-node prop on a node type"); e[n[0].id] = n[1] } return r } prop(t) { return this.props[t.id] } get isTop() { return 0 < (1 & this.flags) } get isSkipped() { return 0 < (2 & this.flags) } get isError() { return 0 < (4 & this.flags) } get isAnonymous() { return 0 < (8 & this.flags) } is(t) { var e; return "string" == typeof t ? this.name == t || !!(e = this.prop(z.group)) && -1 < e.indexOf(t) : this.id == t } static match(t) { let n = Object.create(null); for (var e in t) for (var i of e.split(" ")) n[i] = t[e]; return i => { for (let t = i.prop(z.group), e = -1; e < (t ? t.length : 0); e++) { var r = n[e < 0 ? i.name : t[e]]; if (r) return r } } } }, wo = (vo.none = new vo("", Object.create(null), 0, 8), class lp { constructor(e) { this.types = e; for (let t = 0; t < e.length; t++)if (e[t].id != t) throw new RangeError("Node type ids should correspond to array positions when creating a node set") } extend(...e) { var i, r = []; for (i of this.types) { let t = null; for (var n of e) { n = n(i); n && ((t = t || Object.assign({}, i.props))[n[0].id] = n[1]) } r.push(t ? new vo(i.name, t, i.id, i.flags) : i) } return new lp(r) } }), bo = new WeakMap, yo = new WeakMap, B = ((i = P = P || {})[i.ExcludeBuffers = 1] = "ExcludeBuffers", i[i.IncludeAnonymous = 2] = "IncludeAnonymous", i[i.IgnoreMounts = 4] = "IgnoreMounts", i[i.IgnoreOverlays = 8] = "IgnoreOverlays", class hp { constructor(t, e, i, r, n) { if (this.type = t, this.children = e, this.positions = i, this.length = r, this.props = null, n && n.length) { this.props = Object.create(null); for (var [s, o] of n) this.props["number" == typeof s ? s : s.id] = o } } toString() { var t, e = mo.get(this); if (e && !e.overlay) return e.tree.toString(); let i = ""; for (t of this.children) { var r = t.toString(); r && (i && (i += ","), i += r) } return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (i.length ? "(" + i + ")" : "") : i } cursor(t = 0) { return new Ro(this.topNode, t) } cursorAt(t, e = 0, i) { var r = bo.get(this) || this.topNode, r = new Ro(r); return r.moveTo(t, e), bo.set(this, r._tree), r } get topNode() { return new $o(this, 0, 0, null) } resolve(t, e = 0) { t = ko(bo.get(this) || this.topNode, t, e, !1); return bo.set(this, t), t } resolveInner(t, e = 0) { t = ko(yo.get(this) || this.topNode, t, e, !0); return yo.set(this, t), t } resolveStack(t, r = 0) { { var n, s = t, o = r, a, l; let e = this.resolveInner(s, o), i = null; for (let t = e instanceof $o ? e : e.context.parent; t; t = t.parent)t.index < 0 ? (a = t.parent, (i = i || [e]).push(a.resolve(s, o)), t = a) : (a = mo.get(t.tree)) && a.overlay && a.overlay[0].from <= s && a.overlay[a.overlay.length - 1].to >= s && (l = new $o(a.tree, a.overlay[0].from + t.from, -1, t), (i = i || [e]).push(ko(l, s, o, !1))); return i ? Xo(i) : e } } iterate(t) { for (var { enter: e, leave: i, from: r = 0, to: n = this.length } = t, t = t.mode || 0, s = 0 < (t & P.IncludeAnonymous), o = this.cursor(t | P.IncludeAnonymous); ;) { let t = !1; if (o.from <= n && o.to >= r && (!s && o.type.isAnonymous || !1 !== e(o))) { if (o.firstChild()) continue; t = !0 } for (; t && i && (s || !o.type.isAnonymous) && i(o), !o.nextSibling();) { if (!o.parent()) return; t = !0 } } } prop(t) { return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t) } get propValues() { var t = []; if (this.props) for (var e in this.props) t.push([+e, this.props[e]]); return t } balance(t = {}) { return this.children.length <= 8 ? this : Mo(vo.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, e, i) => new hp(this.type, t, e, i, this.propValues), t.makeTree || ((t, e, i) => new hp(vo.none, t, e, i))) } static build(i) { { var r = i; let t, { buffer: e, nodeSet: A, maxBufferLength: R = 1024, reused: Y = [], minRepeatType: W = A.types.length } = r, V = Array.isArray(e) ? new So(e, e.length) : e, M = A.types, q = 0, _ = 0; function j(i, r, t, e, n, s) { for (var o, a, { id: l, start: h, end: c, size: d } = V, O = _; d < 0;) { if (V.next(), -1 == d) return o = Y[l], t.push(o), void e.push(h - i); if (-3 == d) return void (q = l); if (-4 == d) return void (_ = l); throw new RangeError("Unrecognized record size: " + d) } let u = M[l], f, p, m = h - i; if (c - h <= R && (p = ((t, e) => { let i = V.fork(), r = 0, n = 0, s = 0, o = i.end - R, a = { size: 0, start: 0, skip: 0 }; t: for (var l = i.pos - t; i.pos > l;) { var h = i.size; if (i.id == e && 0 <= h) a.size = r, a.start = n, a.skip = s, s += 4, r += 4, i.next(); else { var c = i.pos - h; if (h < 0 || c < l || i.start < o) break; let t = i.id >= W ? 4 : 0; var d = i.start; for (i.next(); i.pos > c;) { if (i.size < 0) { if (-3 != i.size) break t; t += 4 } else i.id >= W && (t += 4); i.next() } n = d, r += h, s += t } } return (e < 0 || r == t) && (a.size = r, a.start = n, a.skip = s), 4 < a.size ? a : void 0 })(V.pos - r, n))) { var g = new Uint16Array(p.size - p.skip); let t = V.pos - p.size, e = g.length; for (; V.pos > t;)e = function e(i, r, n) { let { id: s, start: o, end: a, size: l } = V; V.next(); if (0 <= l && s < W) { let t = n; if (4 < l) { let t = V.pos - (l - 4); for (; V.pos > t;)n = e(i, r, n) } r[--n] = t, r[--n] = a - i, r[--n] = o - i, r[--n] = s } else -3 == l ? q = s : -4 == l && (_ = s); return n }(p.start, g, e); f = new Qo(g, c - p.start, A), m = p.start - i } else { var v = V.pos - d, w = (V.next(), []), b = [], y = l >= W ? l : -1; let t = 0, e = c; for (; V.pos > v;)if (0 <= y && V.id == y && 0 <= V.size) V.end <= e - R && (E(w, b, h, t, V.end, e, y, O), t = w.length, e = V.end), V.next(); else if (2500 < s) { S = void 0; Q = void 0; x = void 0; k = void 0; $ = void 0; P = void 0; Z = void 0; T = void 0; C = void 0; X = void 0; var S = h; var Q = v; var x = w; var k = b; let i = [], t = 0, e = -1; for (; V.pos > Q;) { var { id: $, start: P, end: Z, size: T } = V; if (!(4 < T)) { if (-1 < e && P < e) break; e < 0 && (e = Z - R), i.push($, P, Z), t++ } V.next() } if (t) { var C = new Uint16Array(4 * t), X = i[i.length - 2]; for (let t = i.length - 3, e = 0; 0 <= t; t -= 3)C[e++] = i[t], C[e++] = i[t + 1] - X, C[e++] = i[t + 2] - X, C[e++] = e; x.push(new Qo(C, i[2] - X, A)), k.push(X - S) } } else j(h, v, w, b, y, s + 1); 0 <= y && 0 < t && t < w.length && E(w, b, h, t, h, e, y, O), w.reverse(), b.reverse(), f = -1 < y && 0 < t ? Mo(a = u, w, b, 0, w.length, 0, c - h, r = (t, e, i) => { let r = 0, n = t.length - 1, s, o; if (0 <= n && (s = t[n]) instanceof B) { if (!n && s.type == a && s.length == i) return s; (o = s.prop(z.lookAhead)) && (r = e[n] + s.length + o) } return D(a, t, e, i, r) }, r) : D(u, w, b, c - h, O - c) } t.push(f), e.push(m) } function E(t, e, i, r, n, s, o, a) { for (var l = [], h = []; t.length > r;)l.push(t.pop()), h.push(e.pop() + i - n); t.push(D(A.types[o], l, h, s - n, a - s)), e.push(n - i) } function D(t, e, i, r, n = 0, s) { var o; return q && (o = [z.contextHash, q], s = s ? [o].concat(s) : [o]), 25 < n && (o = [z.lookAhead, n], s = s ? [o].concat(s) : [o]), new B(t, e, i, r, s) } for (var n = [], s = []; 0 < V.pos;)j(r.start || 0, r.bufferStart || 0, n, s, -1, 0); return i = null != (t = r.length) ? t : n.length ? s[0] + n[0].length : 0, new B(M[r.topID], n.reverse(), s.reverse(), i) } } }), So = (B.empty = new B(vo.none, [], [], 0), class cp { constructor(t, e) { this.buffer = t, this.index = e } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } get pos() { return this.index } next() { this.index -= 4 } fork() { return new cp(this.buffer, this.index) } }), Qo = class dp { constructor(t, e, i) { this.buffer = t, this.length = e, this.set = i } get type() { return vo.none } toString() { var e = []; for (let t = 0; t < this.buffer.length;)e.push(this.childString(t)), t = this.buffer[t + 3]; return e.join(",") } childString(t) { var e = this.buffer[t], i = this.buffer[t + 3]; let r = this.set.types[e], n = r.name; if (/\W/.test(n) && !r.isError && (n = JSON.stringify(n)), i == (t += 4)) return n; for (var s = []; t < i;)s.push(this.childString(t)), t = this.buffer[t + 3]; return n + "(" + s.join(",") + ")" } findChild(e, i, r, n, s) { let o = this.buffer, a = -1; for (let t = e; t != i && !(xo(s, n, o[t + 1], o[t + 2]) && (a = t, 0 < r)); t = o[t + 3]); return a } slice(i, r, n) { var s = this.buffer; let o = new Uint16Array(r - i), a = 0; for (let t = i, e = 0; t < r;) { o[e++] = s[t++], o[e++] = s[t++] - n; var l = o[e++] = s[t++] - n; o[e++] = s[t++] - i, a = Math.max(a, l) } return new dp(o, a, this.set) } }; function xo(t, e, i, r) { switch (t) { case -2: return i < e; case -1: return e <= r && i < e; case 0: return i < e && e < r; case 1: return i <= e && e < r; case 2: return e < r; case 4: return 1 } } function ko(i, r, n, t) { for (var s; i.from == i.to || (n < 1 ? i.from >= r : i.from > r) || (-1 < n ? i.to <= r : i.to < r);) { var e = !t && i instanceof $o && i.index < 0 ? null : i.parent; if (!e) return i; i = e } var o = t ? 0 : P.IgnoreOverlays; if (t) for (let t = i, e = t.parent; e; e = (t = e).parent)t instanceof $o && t.index < 0 && (null == (s = e.enter(r, n, o)) ? void 0 : s.from) != t.from && (i = e); for (; ;) { var a = i.enter(r, n, o); if (!a) return i; i = a } } var n = class { cursor(t = 0) { return new Ro(this, t) } getChild(t, e = null, i = null) { t = Po(this, t, e, i); return t.length ? t[0] : null } getChildren(t, e = null, i = null) { return Po(this, t, e, i) } resolve(t, e = 0) { return ko(this, t, e, !1) } resolveInner(t, e = 0) { return ko(this, t, e, !0) } matchContext(t) { return Zo(this, t) } enterUnfinishedNodesBefore(t) { let e = this.childBefore(t), i = this; for (; e;) { var r = e.lastChild; if (!r || r.to != e.to) break; e = r.type.isError && r.from == r.to ? (i = e, r.prevSibling) : r } return i } get node() { return this } get next() { return this.parent } }, $o = class Op extends n { constructor(t, e, i, r) { super(), this._tree = t, this.from = e, this.index = i, this._parent = r } get type() { return this._tree.type } get name() { return this._tree.type.name } get to() { return this.from + this._tree.length } nextChild(i, r, n, s, o = 0) { for (let e = this; ;) { for (var { children: t, positions: a } = e._tree, l = 0 < r ? t.length : -1; i != l; i += r) { var h = t[i], c = a[i] + e.from; if (xo(s, n, c, c + h.length)) if (h instanceof Qo) { if (!(o & P.ExcludeBuffers)) { var d = h.findChild(0, h.buffer.length, r, n - c, s); if (-1 < d) return new Co(new To(e, h, i, c), null, d) } } else if (o & P.IncludeAnonymous || !h.type.isAnonymous || Yo(h)) { let t; return o & P.IgnoreMounts || !(t = mo.get(h)) || t.overlay ? (d = new Op(h, c, i, e), o & P.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(r < 0 ? h.children.length - 1 : 0, r, n, s)) : new Op(t.tree, c, i, e) } } if (o & P.IncludeAnonymous || !e.type.isAnonymous) return null; if (i = 0 <= e.index ? e.index + r : r < 0 ? -1 : e._parent._tree.children.length, !(e = e._parent)) return null } } get firstChild() { return this.nextChild(0, 1, 0, 4) } get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4) } childAfter(t) { return this.nextChild(0, 1, t, 2) } childBefore(t) { return this.nextChild(this._tree.children.length - 1, -1, t, -2) } enter(t, e, i = 0) { let r; if (!(i & P.IgnoreOverlays) && (r = mo.get(this._tree)) && r.overlay) { var n, s, o = t - this.from; for ({ from: n, to: s } of r.overlay) if ((0 < e ? n <= o : n < o) && (e < 0 ? s >= o : s > o)) return new Op(r.tree, r.overlay[0].from + this.from, -1, this) } return this.nextChild(0, 1, t, e, i) } nextSignificantParent() { let t = this; for (; t.type.isAnonymous && t._parent;)t = t._parent; return t } get parent() { return this._parent ? this._parent.nextSignificantParent() : null } get nextSibling() { return this._parent && 0 <= this.index ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null } get prevSibling() { return this._parent && 0 <= this.index ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null } get tree() { return this._tree } toTree() { return this._tree } toString() { return this._tree.toString() } }; function Po(t, e, i, r) { var n = t.cursor(), s = []; if (!n.firstChild()) return s; if (null != i) for (; !n.type.is(i);)if (!n.nextSibling()) return s; for (; ;) { if (null != r && n.type.is(r)) return s; if (n.type.is(e) && s.push(n.node), !n.nextSibling()) return null == r ? s : [] } } function Zo(e, i, r = i.length - 1) { for (let t = e.parent; 0 <= r; t = t.parent) { if (!t) return !1; if (!t.type.isAnonymous) { if (i[r] && i[r] != t.name) return !1; r-- } } return !0 } var To = class { constructor(t, e, i, r) { this.parent = t, this.buffer = e, this.index = i, this.start = r } }, Co = class up extends n { get name() { return this.type.name } get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] } get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] } constructor(t, e, i) { super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]] } child(t, e, i) { var r = this.context.buffer, r = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.context.start, i); return r < 0 ? null : new up(this.context, this, r) } get firstChild() { return this.child(1, 0, 4) } get lastChild() { return this.child(-1, 0, 4) } childAfter(t) { return this.child(1, t, 2) } childBefore(t) { return this.child(-1, t, -2) } enter(t, e, i = 0) { return i & P.ExcludeBuffers || (i = this.context.buffer, (i = i.findChild(this.index + 4, i.buffer[this.index + 3], 0 < e ? 1 : -1, t - this.context.start, e)) < 0) ? null : new up(this.context, this, i) } get parent() { return this._parent || this.context.parent.nextSignificantParent() } externalSibling(t) { return this._parent ? null : this.context.parent.nextChild(this.context.index + t, t, 0, 4) } get nextSibling() { var t = this.context.buffer, e = t.buffer[this.index + 3]; return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new up(this.context, this._parent, e) : this.externalSibling(1) } get prevSibling() { var t = this.context.buffer, e = this._parent ? this._parent.index + 4 : 0; return this.index == e ? this.externalSibling(-1) : new up(this.context, this._parent, t.findChild(e, this.index, -1, 0, 4)) } get tree() { return null } toTree() { var t, e = [], i = [], r = this.context.buffer, n = this.index + 4, s = r.buffer[this.index + 3]; return n < s && (t = r.buffer[this.index + 1], e.push(r.slice(n, s, t)), i.push(0)), new B(this.type, e, i, this.to - this.from) } toString() { return this.context.buffer.childString(this.index) } }; function Xo(e) { if (!e.length) return null; let i = 0, r = e[0]; for (let t = 1; t < e.length; t++) { var n = e[t]; (n.from > r.from || n.to < r.to) && (r = n, i = t) } var t = r instanceof $o && r.index < 0 ? null : r.parent, s = e.slice(); return t ? s[i] = t : s.splice(i, 1), new Ao(s, r) } var Ao = class { constructor(t, e) { this.heads = t, this.node = e } get next() { return Xo(this.heads) } }; var Ro = class { get name() { return this.type.name } constructor(e, t = 0) { if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof $o) this.yieldNode(e); else { this._tree = e.context.parent, this.buffer = e.context; for (let t = e._parent; t; t = t._parent)this.stack.unshift(t.index); this.bufferNode = e, this.yieldBuf(e.index) } } yieldNode(t) { return !!t && (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) } yieldBuf(t, e) { this.index = t; var { start: i, buffer: r } = this.buffer; return this.type = e || r.set.types[r.buffer[t]], this.from = i + r.buffer[t + 1], this.to = i + r.buffer[t + 2], !0 } yield(t) { return !!t && (t instanceof $o ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type))) } toString() { return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString() } enterChild(t, e, i) { var r; return this.buffer ? (r = this.buffer.buffer, !((r = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.buffer.start, i)) < 0) && (this.stack.push(this.index), this.yieldBuf(r))) : this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode)) } firstChild() { return this.enterChild(1, 0, 4) } lastChild() { return this.enterChild(-1, 0, 4) } childAfter(t) { return this.enterChild(1, t, 2) } childBefore(t) { return this.enterChild(-1, t, -2) } enter(t, e, i = this.mode) { return this.buffer ? !(i & P.ExcludeBuffers) && this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i)) } parent() { var t; return this.buffer ? this.stack.length ? this.yieldBuf(this.stack.pop()) : (t = this.mode & P.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent(), this.buffer = null, this.yieldNode(t)) : this.yieldNode(this.mode & P.IncludeAnonymous ? this._tree._parent : this._tree.parent) } sibling(t) { if (!this.buffer) return !!this._tree._parent && this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)); var e = this.buffer.buffer, i = this.stack.length - 1; if (t < 0) { var r = i < 0 ? 0 : this.stack[i] + 4; if (this.index != r) return this.yieldBuf(e.findChild(r, this.index, -1, 0, 4)) } else { r = e.buffer[this.index + 3]; if (r < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3])) return this.yieldBuf(r) } return i < 0 && this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) } nextSibling() { return this.sibling(1) } prevSibling() { return this.sibling(-1) } atLastNode(i) { let r, n, e = this.buffer; if (e) { if (0 < i) { if (this.index < e.buffer.buffer.length) return !1 } else for (let t = 0; t < this.index; t++)if (e.buffer.buffer[t + 3] < this.index) return !1; ({ index: r, parent: n } = e) } else ({ index: r, _parent: n } = this._tree); for (; n; { index: r, _parent: n } = n)if (-1 < r) for (let t = r + i, e = i < 0 ? -1 : n._tree.children.length; t != e; t += i) { var s = n._tree.children[t]; if (this.mode & P.IncludeAnonymous || s instanceof Qo || !s.type.isAnonymous || Yo(s)) return !1 } return !0 } move(t, e) { if (e && this.enterChild(t, 0, 4)) return !0; for (; ;) { if (this.sibling(t)) return !0; if (this.atLastNode(t) || !this.parent()) return !1 } } next(t = !0) { return this.move(1, t) } prev(t = !0) { return this.move(-1, t) } moveTo(t, e = 0) { for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (-1 < e ? this.to <= t : this.to < t)) && this.parent();); for (; this.enterChild(1, t, e);); return this } get node() { if (!this.buffer) return this._tree; let r = this.bufferNode, n = null, s = 0; if (r && r.context == this.buffer) t: for (let e = this.index, i = this.stack.length; 0 <= i;) { for (let t = r; t; t = t._parent)if (t.index == e) { if (e == this.index) return t; n = t, s = i + 1; break t } e = this.stack[--i] } for (let t = s; t < this.stack.length; t++)n = new Co(this.buffer, n, this.stack[t]); return this.bufferNode = new Co(this.buffer, n, this.index) } get tree() { return this.buffer ? null : this._tree._tree } iterate(i, r) { for (let e = 0; ;) { let t = !1; if (this.type.isAnonymous || !1 !== i(this)) { if (this.firstChild()) { e++; continue } this.type.isAnonymous || (t = !0) } for (; t && r && r(this), t = this.type.isAnonymous, !this.nextSibling();) { if (!e) return; this.parent(), e--, t = !0 } } } matchContext(i) { if (!this.buffer) return Zo(this.node, i); var r = this.buffer.buffer, n = r.set.types; for (let t = i.length - 1, e = this.stack.length - 1; 0 <= t; e--) { if (e < 0) return Zo(this.node, i, t); var s = n[r.buffer[this.stack[e]]]; if (!s.isAnonymous) { if (i[t] && i[t] != s.name) return !1; t-- } } return !0 } }; function Yo(t) { return t.children.some(t => t instanceof Qo || !t.type.isAnonymous || Yo(t)) } var Wo = new WeakMap; function Vo(t, e) { if (!t.isAnonymous || e instanceof Qo || e.type != t) return 1; let i = Wo.get(e); if (null == i) { i = 1; for (var r of e.children) { if (r.type != t || !(r instanceof B)) { i = 1; break } i += Vo(t, r) } Wo.set(e, i) } return i } function Mo(d, e, t, i, r, O, n, s, u) { let o = 0; for (let t = i; t < r; t++)o += Vo(d, e[t]); let f = Math.ceil(1.5 * o / 8), p = [], m = []; return function n(s, o, t, a, l) { for (let r = t; r < a;) { let t = r, e = o[r], i = Vo(d, s[r]); for (r++; r < a; r++) { var h = Vo(d, s[r]); if (i + h >= f) break; i += h } if (r == t + 1) { if (i > f) { var c = s[t]; n(c.children, c.positions, 0, c.children.length, o[t] + l); continue } p.push(s[t]) } else c = o[r - 1] + s[r - 1].length - e, p.push(Mo(d, s, o, t, r, e, c, null, u)); m.push(e + l - O) } }(e, t, i, r, 0), (s || u)(p, m, n) } var ze = class { constructor() { this.map = new WeakMap } setBuffer(t, e, i) { let r = this.map.get(t); r || this.map.set(t, r = new Map), r.set(e, i) } getBuffer(t, e) { t = this.map.get(t); return t && t.get(e) } set(t, e) { t instanceof Co ? this.setBuffer(t.context.buffer, t.index, e) : t instanceof $o && this.map.set(t.tree, e) } get(t) { return t instanceof Co ? this.getBuffer(t.context.buffer, t.index) : t instanceof $o ? this.map.get(t.tree) : void 0 } cursorSet(t, e) { t.buffer ? this.setBuffer(t.buffer.buffer, t.index, e) : this.map.set(t.tree, e) } cursorGet(t) { return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree) } }, qo = class fp { constructor(t, e, i, r, n = !1, s = !1) { this.from = t, this.to = e, this.tree = i, this.offset = r, this.open = (n ? 1 : 0) | (s ? 2 : 0) } get openStart() { return 0 < (1 & this.open) } get openEnd() { return 0 < (2 & this.open) } static addTree(t, e = [], i = !1) { var r, n = [new fp(0, t.length, t, 0, !1, i)]; for (r of e) r.to > t.length && n.push(r); return n } static applyChanges(n, t, s = 128) { if (!t.length) return n; var o = []; let a = 1, l = n.length ? n[0] : null; for (let e = 0, i = 0, r = 0; ; e++) { var h, c, d = e < t.length ? t[e] : null, O = d ? d.fromA : 1e9; if (O - i >= s) for (; l && l.from < O;) { let t = l; if ((i >= t.from || O <= t.to || r) && (h = Math.max(t.from, i) - r, c = Math.min(t.to, O) - r, t = c <= h ? null : new fp(h, c, t.tree, t.offset + r, 0 < e, !!d)), t && o.push(t), l.to > O) break; l = a < n.length ? n[a++] : null } if (!d) break; i = d.toA, r = d.toA - d.toB } return o } }, _o = class { startParse(t, e, i) { return "string" == typeof t && (t = new jo(t)), i = i ? i.length ? i.map(t => new po(t.from, t.to)) : [new po(0, 0)] : [new po(0, t.length)], this.createParse(t, e || [], i) } parse(t, e, i) { for (var r = this.startParse(t, e, i); ;) { var n = r.advance(); if (n) return n } } }, jo = class { constructor(t) { this.string = t } get length() { return this.string.length } chunk(t) { return this.string.slice(t) } get lineChunks() { return !1 } read(t, e) { return this.string.slice(t, e) } }; var Eo = class { constructor(t, e, i, r, n) { this.parser = t, this.parse = e, this.overlay = i, this.target = r, this.from = n } }; function Do(t) { if (!t.length || t.some(t => t.from >= t.to)) throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t)) } var zo = class { constructor(t, e, i, r, n, s, o) { this.parser = t, this.predicate = e, this.mounts = i, this.index = r, this.start = n, this.target = s, this.prev = o, this.depth = 0, this.ranges = [] } }, Bo = new z({ perNode: !0 }), Go = class { constructor(t, e, i, r, n) { this.nest = e, this.input = i, this.fragments = r, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t } advance() { if (this.baseParse) { var t = this.baseParse.advance(); if (!t) return null; if (this.baseParse = null, this.baseTree = t, this.startInner(), null != this.stoppedAt) for (var e of this.inner) e.parse.stopAt(this.stoppedAt) } if (this.innerDone == this.inner.length) { let t = this.baseTree; return t = null != this.stoppedAt ? new B(t.type, t.children, t.positions, t.length, t.propValues.concat([[Bo, this.stoppedAt]])) : t } var i, t = this.inner[this.innerDone], r = t.parse.advance(); return r && (this.innerDone++, (i = Object.assign(Object.create(null), t.target.props))[z.mounted.id] = new mo(r, t.overlay, t.parser), t.target.props = i), null } get parsedPos() { if (this.baseParse) return 0; let e = this.input.length; for (let t = this.innerDone; t < this.inner.length; t++)this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos)); return e } stopAt(e) { if (this.stoppedAt = e, this.baseParse) this.baseParse.stopAt(e); else for (let t = this.innerDone; t < this.inner.length; t++)this.inner[t].parse.stopAt(e) } startInner() { var n, s, o, a = new Uo(this.fragments); let l = null, h = null, c = new Ro(new $o(this.baseTree, this.ranges[0].from, 0, null), P.IncludeAnonymous | P.IgnoreMounts); t: for (let i, r; ;) { let t = !0, e; if (null != this.stoppedAt && c.from >= this.stoppedAt) t = !1; else if (a.hasNode(c)) { if (l) { var d = l.mounts.find(t => t.frag.from <= c.from && t.frag.to >= c.to && t.mount.overlay); if (d) for (var O of d.mount.overlay) { let e = O.from + d.pos, i = O.to + d.pos; e >= c.from && i <= c.to && !l.ranges.some(t => t.from < i && t.to > e) && l.ranges.push({ from: e, to: i }) } } t = !1 } else h && (r = ((t, e, i) => { for (var r of t) { if (r.from >= i) break; if (r.to > e) return r.from <= e && r.to >= i ? 2 : 1 } return 0 })(h.ranges, c.from, c.to)) ? t = 2 != r : !c.type.isAnonymous && (i = this.nest(c, this.input)) && (c.from < c.to || !i.overlay) ? (c.tree || (t => { let d = t.node, O = [], e = d.context.buffer; for (; O.push(t.index), t.parent(), !t.tree;); let i = t.tree, r = i.children.indexOf(e), u = i.children[r], f = u.buffer, p = [r]; i.children[r] = function t(e, i, r, n, s, o) { var a = O[o], l = [], h = [], e = (Io(u, e, a, l, h, n), f[a + 1]), c = f[a + 2], c = (p.push(l.length), o ? t(a + 4, f[a + 3], u.set.types[f[a]], e, c - e, o - 1) : d.toTree()); return l.push(c), h.push(e - n), Io(u, f[a + 3], i, l, h, n), new B(r, l, h, s) }(0, f.length, vo.none, 0, u.length, O.length - 1); for (var n of p) { var s = t.tree.children[n], o = t.tree.positions[n]; t.yield(new $o(s, o + t.from, n, t._tree)) } })(c), n = a.findMounts(c.from, i.parser), "function" == typeof i.overlay ? l = new zo(i.parser, i.overlay, n, this.inner.length, c.from, c.tree, l) : ((s = Lo(this.ranges, i.overlay || (c.from < c.to ? [new po(c.from, c.to)] : []))).length && Do(s), !s.length && i.overlay || this.inner.push(new Eo(i.parser, s.length ? i.parser.startParse(this.input, Fo(n, s), s) : i.parser.startParse(""), i.overlay ? i.overlay.map(t => new po(t.from - c.from, t.to - c.from)) : null, c.tree, (s.length ? s[0] : c).from)), i.overlay ? s.length && (h = { ranges: s, depth: 0, prev: h }) : t = !1)) : l && (e = l.predicate(c)) && (e = !0 === e ? new po(c.from, c.to) : e).from < e.to && l.ranges.push(e); if (t && c.firstChild()) l && l.depth++, h && h.depth++; else for (; !c.nextSibling();) { if (!c.parent()) break t; l && !--l.depth && ((o = Lo(this.ranges, l.ranges)).length && (Do(o), this.inner.splice(l.index, 0, new Eo(l.parser, l.parser.startParse(this.input, Fo(l.mounts, o), o), l.ranges.map(t => new po(t.from - l.start, t.to - l.start)), l.target, o[0].from))), l = l.prev), h && !--h.depth && (h = h.prev) } } } }; function Io(t, e, i, r, n, s) { var o; e < i && (o = t.buffer[e + 1], r.push(t.slice(e, i, o)), n.push(o - s)) } var No = class { constructor(t, e) { this.offset = e, this.done = !1, this.cursor = t.cursor(P.IncludeAnonymous | P.IgnoreMounts) } moveTo(t) { for (var e = this.cursor, i = t - this.offset; !this.done && e.from < i;)e.to >= t && e.enter(i, 1, P.IgnoreOverlays | P.ExcludeBuffers) || e.next(!1) || (this.done = !0) } hasNode(e) { if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree) for (let t = this.cursor.tree; ;) { if (t == e.tree) return !0; if (!(t.children.length && 0 == t.positions[0] && t.children[0] instanceof B)) break; t = t.children[0] } return !1 } }, Uo = class { constructor(t) { var e; this.fragments = t, this.curTo = 0, this.fragI = 0, t.length ? (t = this.curFrag = t[0], this.curTo = null != (e = t.tree.prop(Bo)) ? e : t.to, this.inner = new No(t.tree, -t.offset)) : this.curFrag = this.inner = null } hasNode(t) { for (; this.curFrag && t.from >= this.curTo;)this.nextFrag(); return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t) } nextFrag() { var t, e; this.fragI++, this.fragI == this.fragments.length ? this.curFrag = this.inner = null : (e = this.curFrag = this.fragments[this.fragI], this.curTo = null != (t = e.tree.prop(Bo)) ? t : e.to, this.inner = new No(e.tree, -e.offset)) } findMounts(t, i) { var r, n = []; if (this.inner) { this.inner.cursor.moveTo(t, 1); for (let e = this.inner.cursor.node; e; e = e.parent) { var s = null == (r = e.tree) ? void 0 : r.prop(z.mounted); if (s && s.parser == i) for (let t = this.fragI; t < this.fragments.length; t++) { var o = this.fragments[t]; if (o.from >= e.to) break; o.tree == this.curFrag.tree && n.push({ frag: o, pos: e.from - o.offset, mount: s }) } } } return n } }; function Lo(i, r) { let n = null, s = r; for (let t = 1, e = 0; t < i.length; t++)for (var o = i[t - 1].to, a = i[t].from; e < s.length; e++) { var l = s[e]; if (l.from >= a) break; l.to <= o || (n || (s = n = r.slice()), l.from < o ? (n[e] = new po(l.from, o), l.to > a && n.splice(e + 1, 0, new po(a, l.to))) : l.to > a ? n[e--] = new po(a, l.to) : n.splice(e--, 1)) } return s } function Fo(t, n) { var s = []; for (let { pos: e, mount: i, frag: r } of t) { var o = e + (i.overlay ? i.overlay[0].from : 0), a = o + i.tree.length, l = Math.max(r.from, o), h = Math.min(r.to, a); if (i.overlay) { var c = ((t, e, i, r) => { let n = 0, s = 0, o = !1, a = !1, l = -1e9; for (var h = []; ;) { var c, d, O = n == t.length ? 1e9 : o ? t[n].to : t[n].from, u = s == e.length ? 1e9 : a ? e[s].to : e[s].from; if (o != a && (c = Math.max(l, i)) < (d = Math.min(O, u, r)) && h.push(new po(c, d)), 1e9 == (l = Math.min(O, u))) break; O == l && (o ? (o = !1, n++) : o = !0), u == l && (a ? (a = !1, s++) : a = !0) } return h })(n, i.overlay.map(t => new po(t.from + e, t.to + e)), l, h); for (let t = 0, e = l; ; t++) { var d = t == c.length, O = d ? h : c[t].from; if (O > e && s.push(new qo(e, O, i.tree, -o, r.from >= e || r.openStart, r.to <= O || r.openEnd)), d) break; e = c[t].to } } else s.push(new qo(l, h, i.tree, -o, r.from >= o || r.openStart, r.to <= a || r.openEnd)) } return s } var Ho = 0, Jo = class pp { constructor(t, e, i) { this.set = t, this.base = e, this.modified = i, this.id = Ho++ } static define(t) { if (null != t && t.base) throw new Error("Can not derive from a modified tag"); var e = new pp([], null, []); if (e.set.push(e), t) for (var i of t.set) e.set.push(i); return e } static defineModifier() { let e = new ta; return t => -1 < t.modified.indexOf(e) ? t : ta.get(t.base || t, t.modified.concat(e).sort((t, e) => t.id - e.id)) } }, Ko = 0, ta = class mp { constructor() { this.instances = [], this.id = Ko++ } static get(r, n) { if (!n.length) return r; var t = n[0].instances.find(t => { return t.base == r && (e = n, i = t.modified, e.length == i.length) && e.every((t, e) => t == i[e]); var e, i }); if (t) return t; var e, i = [], s = new Jo(i, r, n); for (e of n) e.instances.push(s); var o, a = (r => { var n = [[]]; for (let i = 0; i < r.length; i++)for (let t = 0, e = n.length; t < e; t++)n.push(n[t].concat(r[i])); return n.sort((t, e) => e.length - t.length) })(n); for (o of r.set) if (!o.modified.length) for (var l of a) i.push(mp.get(o, l)); return s } }; function ea(e) { var i, n = Object.create(null); for (i in e) { let t = e[i]; Array.isArray(t) || (t = [t]); for (var s of i.split(" ")) if (s) { let e = [], i = 2, r = s; for (let t = 0; ;) { if ("..." == r && 0 < t && t + 3 == s.length) { i = 1; break } var o = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(r); if (!o) throw new RangeError("Invalid path: " + s); if (e.push("*" == o[0] ? "" : '"' == o[0][0] ? JSON.parse(o[0]) : o[0]), (t += o[0].length) == s.length) break; o = s[t++]; if (t == s.length && "!" == o) { i = 0; break } if ("/" != o) throw new RangeError("Invalid path: " + s); r = s.slice(t) } var a = e.length - 1, l = e[a]; if (!l) throw new RangeError("Invalid path: " + s); a = new ra(t, i, 0 < a ? e.slice(0, a) : null); n[l] = a.sort(n[l]) } } return ia.add(n) } var ia = new z, ra = class { constructor(t, e, i, r) { this.tags = t, this.mode = e, this.context = i, this.next = r } get opaque() { return 0 == this.mode } get inherit() { return 1 == this.mode } sort(t) { return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t) } get depth() { return this.context ? this.context.length : 0 } }; function na(t, e) { let n = Object.create(null); for (var i of t) if (Array.isArray(i.tag)) for (var r of i.tag) n[r.id] = i.class; else n[i.tag.id] = i.class; let { scope: s, all: o = null } = e || {}; return { style: t => { let e = o; for (var i of t) for (var r of i.set) { r = n[r.id]; if (r) { e = e ? e + " " + r : r; break } } return e }, scope: s } } function sa(t, e, i, r = 0, n = t.length) { e = new oa(r, Array.isArray(e) ? e : [e], i); e.highlightRange(t.cursor(), r, n, "", e.highlighters), e.flush(n) } ra.empty = new ra([], 2, null); var oa = class { constructor(t, e, i) { this.at = t, this.highlighters = e, this.span = i, this.class = "" } startSpan(t, e) { e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e) } flush(t) { t > this.at && this.class && this.span(this.at, t, this.class) } highlightRange(n, s, o, a, l) { let { type: e, from: h, to: c } = n; if (!(o <= h || c <= s)) { e.isTop && (l = this.highlighters.filter(t => !t.scope || t.scope(e))); let r = a; var t = (t => { let e = t.type.prop(ia); for (; e && e.context && !t.matchContext(e.context);)e = e.next; return e || null })(n) || ra.empty, i = ((t, e) => { let i = null; for (var r of t) { r = r.style(e); r && (i = i ? i + " " + r : r) } return i })(l, t.tags); if (i && (r && (r += " "), r += i, 1 == t.mode) && (a += (a ? " " : "") + i), this.startSpan(Math.max(s, h), r), !t.opaque) { let i = n.tree && n.tree.prop(z.mounted); if (i && i.overlay) { var d = n.node.enter(i.overlay[0].from + h, 1), O = this.highlighters.filter(t => !t.scope || t.scope(i.tree.type)), u = n.firstChild(); for (let t = 0, e = h; ; t++) { var f = t < i.overlay.length ? i.overlay[t] : null, p = f ? f.from + h : c, m = Math.max(s, e), g = Math.min(o, p); if (m < g && u) for (; n.from < g && (this.highlightRange(n, m, g, a, l), this.startSpan(Math.min(g, n.to), r), !(n.to >= p)) && n.nextSibling();); if (!f || o < p) break; (e = f.to + h) > s && (this.highlightRange(d.cursor(), Math.max(s, f.from + h), Math.min(o, e), "", O), this.startSpan(Math.min(o, e), r)) } u && n.parent() } else if (n.firstChild()) { i && (a = ""); do { if (!(n.to <= s)) { if (o <= n.from) break; this.highlightRange(n, s, o, a, l), this.startSpan(Math.min(o, n.to), r) } } while (n.nextSibling()); n.parent() } } } } }; var r = Jo.define, Le = r(), Be = r(), Ge = r(Be), Ie = r(Be), e = r(), i = r(e), n = r(e), s = r(), aa = r(s), o = r(), l = r(), la = r(), ha = r(la), ca = r(), Z = { comment: Le, lineComment: r(Le), blockComment: r(Le), docComment: r(Le), name: Be, variableName: r(Be), typeName: Ge, tagName: r(Ge), propertyName: Ie, attributeName: r(Ie), className: r(Be), labelName: r(Be), namespace: r(Be), macroName: r(Be), literal: e, string: i, docString: r(i), character: r(i), attributeValue: r(i), number: n, integer: r(n), float: r(n), bool: r(e), regexp: r(e), escape: r(e), color: r(e), url: r(e), keyword: o, self: r(o), null: r(o), atom: r(o), unit: r(o), modifier: r(o), operatorKeyword: r(o), controlKeyword: r(o), definitionKeyword: r(o), moduleKeyword: r(o), operator: l, derefOperator: r(l), arithmeticOperator: r(l), logicOperator: r(l), bitwiseOperator: r(l), compareOperator: r(l), updateOperator: r(l), definitionOperator: r(l), typeOperator: r(l), controlOperator: r(l), punctuation: la, separator: r(la), bracket: ha, angleBracket: r(ha), squareBracket: r(ha), paren: r(ha), brace: r(ha), content: s, heading: aa, heading1: r(aa), heading2: r(aa), heading3: r(aa), heading4: r(aa), heading5: r(aa), heading6: r(aa), contentSeparator: r(s), list: r(s), quote: r(s), emphasis: r(s), strong: r(s), link: r(s), monospace: r(s), strikethrough: r(s), inserted: r(), deleted: r(), changed: r(), invalid: r(), meta: ca, documentMeta: r(ca), annotation: r(ca), processingInstruction: r(ca), definition: Jo.defineModifier(), constant: Jo.defineModifier(), function: Jo.defineModifier(), standard: Jo.defineModifier(), local: Jo.defineModifier(), special: Jo.defineModifier() }, da = (na([{ tag: Z.link, class: "tok-link" }, { tag: Z.heading, class: "tok-heading" }, { tag: Z.emphasis, class: "tok-emphasis" }, { tag: Z.strong, class: "tok-strong" }, { tag: Z.keyword, class: "tok-keyword" }, { tag: Z.atom, class: "tok-atom" }, { tag: Z.bool, class: "tok-bool" }, { tag: Z.url, class: "tok-url" }, { tag: Z.labelName, class: "tok-labelName" }, { tag: Z.inserted, class: "tok-inserted" }, { tag: Z.deleted, class: "tok-deleted" }, { tag: Z.literal, class: "tok-literal" }, { tag: Z.string, class: "tok-string" }, { tag: Z.number, class: "tok-number" }, { tag: [Z.regexp, Z.escape, Z.special(Z.string)], class: "tok-string2" }, { tag: Z.variableName, class: "tok-variableName" }, { tag: Z.local(Z.variableName), class: "tok-variableName tok-local" }, { tag: Z.definition(Z.variableName), class: "tok-variableName tok-definition" }, { tag: Z.special(Z.variableName), class: "tok-variableName2" }, { tag: Z.definition(Z.propertyName), class: "tok-propertyName tok-definition" }, { tag: Z.typeName, class: "tok-typeName" }, { tag: Z.namespace, class: "tok-namespace" }, { tag: Z.className, class: "tok-className" }, { tag: Z.macroName, class: "tok-macroName" }, { tag: Z.propertyName, class: "tok-propertyName" }, { tag: Z.operator, class: "tok-operator" }, { tag: Z.comment, class: "tok-comment" }, { tag: Z.meta, class: "tok-meta" }, { tag: Z.invalid, class: "tok-invalid" }, { tag: Z.punctuation, class: "tok-punctuation" }]), new z); function Oa(e) { return d.define({ combine: e ? t => t.concat(e) : void 0 }) } var ua = new z, fa = class { constructor(t, e, i = [], r = "") { this.data = t, this.name = r, v.prototype.hasOwnProperty("tree") || Object.defineProperty(v.prototype, "tree", { get() { return T(this) } }), this.parser = e, this.extension = [xa.of(this), v.languageData.of((t, e, i) => { var r = pa(t, e, i), n = r.type.prop(da); if (!n) return []; var s = t.facet(n), n = r.type.prop(ua); if (n) { var o, a, l = r.resolve(e - r.from, i); for (o of n) if (o.test(l, t)) return a = t.facet(o.facet), "replace" == o.type ? a : a.concat(s) } return s })].concat(i) } isActiveAt(t, e, i = -1) { return pa(t, e, i).type.prop(da) == this.data } findRegions(t) { var e = t.facet(xa); if ((null == e ? void 0 : e.data) == this.data) return [{ from: 0, to: t.doc.length }]; if (!e || !e.allowsNesting) return []; let o = [], a = (e, i) => { if (e.prop(da) == this.data) o.push({ from: i, to: i + e.length }); else { var t = e.prop(z.mounted); if (t) { if (t.tree.prop(da) == this.data) { if (t.overlay) for (var r of t.overlay) o.push({ from: r.from + i, to: r.to + i }); else o.push({ from: i, to: i + e.length }); return } if (t.overlay) { var n = o.length; if (a(t.tree, t.overlay[0].from + i), o.length > n) return } } for (let t = 0; t < e.children.length; t++) { var s = e.children[t]; s instanceof B && a(s, e.positions[t] + i) } } }; return a(T(t), 0), o } get allowsNesting() { return !0 } }; function pa(t, e, i) { let r = t.facet(xa), n = T(t).topNode; if (!r || r.allowsNesting) for (let t = n; t; t = t.enter(e, i, P.ExcludeBuffers))t.type.isTop && (n = t); return n } fa.setState = c.define(); Le = class gp extends fa { constructor(t, e, i) { super(t, e, [], i), this.parser = e } static define(t) { let e = Oa(t.languageData); return new gp(e, t.parser.configure({ props: [da.add(t => t.isTop ? e : void 0)] }), t.name) } configure(t, e) { return new gp(this.data, this.parser.configure(t), e || this.name) } get allowsNesting() { return this.parser.hasWrappers() } }; function T(t) { t = t.field(fa.state, !1); return t ? t.tree : B.empty } var ma = class { constructor(t) { this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter() } get length() { return this.doc.length } syncTo(t) { return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length } chunk(t) { return this.syncTo(t), this.string } get lineChunks() { return !0 } read(t, e) { var i = this.cursorPos - this.string.length; return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i) } }, ga = null, va = class vp { constructor(t, e, i = [], r, n, s, o, a) { this.parser = t, this.state = e, this.fragments = i, this.tree = r, this.treeLen = n, this.viewport = s, this.skipped = o, this.scheduleOn = a, this.parse = null, this.tempSkipped = [] } static create(t, e, i) { return new vp(t, e, [], B.empty, 0, i, [], null) } startParse() { return this.parser.startParse(new ma(this.state.doc), this.fragments) } work(i, r) { return null != r && r >= this.state.doc.length && (r = void 0), this.tree != B.empty && this.isDone(null != r ? r : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => { var t; if ("number" == typeof i) { let t = Date.now() + i; i = () => Date.now() > t } for (this.parse || (this.parse = this.startParse()), null != r && (null == this.parse.stoppedAt || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ;) { var e = this.parse.advance(); if (e) { if (this.fragments = this.withoutTempSkipped(qo.addTree(e, this.fragments, null != this.parse.stoppedAt)), this.treeLen = null != (t = this.parse.stoppedAt) ? t : this.state.doc.length, this.tree = e, this.parse = null, !(this.treeLen < (null != r ? r : this.state.doc.length))) return !0; this.parse = this.startParse() } if (i()) return !1 } }) } takeTree() { let t, e; this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((null == this.parse.stoppedAt || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => { for (; !(e = this.parse.advance());); }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(qo.addTree(this.tree, this.fragments, !0)), this.parse = null) } withContext(t) { var e = ga; ga = this; try { return t() } finally { ga = e } } withoutTempSkipped(t) { for (var e; e = this.tempSkipped.pop();)t = wa(t, e.from, e.to); return t } changes(t, e) { let { fragments: i, tree: r, treeLen: s, viewport: o, skipped: a } = this; if (this.takeTree(), !t.empty) { let n = []; if (t.iterChangedRanges((t, e, i, r) => n.push({ fromA: t, toA: e, fromB: i, toB: r })), i = qo.applyChanges(i, n), r = B.empty, s = 0, o = { from: t.mapPos(o.from, -1), to: t.mapPos(o.to, 1) }, this.skipped.length) { a = []; for (var l of this.skipped) { var h = t.mapPos(l.from, 1), l = t.mapPos(l.to, -1); h < l && a.push({ from: h, to: l }) } } } return new vp(this.parser, e, i, r, s, o, a, this.scheduleOn) } updateViewport(e) { if (this.viewport.from == e.from && this.viewport.to == e.to) return !1; this.viewport = e; var t = this.skipped.length; for (let t = 0; t < this.skipped.length; t++) { var { from: i, to: r } = this.skipped[t]; i < e.to && r > e.from && (this.fragments = wa(this.fragments, i, r), this.skipped.splice(t--, 1)) } return !(this.skipped.length >= t || (this.reset(), 0)) } reset() { this.parse && (this.takeTree(), this.parse = null) } skipUntilInView(t, e) { this.skipped.push({ from: t, to: e }) } static getSkippingParser(s) { return new class extends _o { createParse(t, e, i) { let r = i[0].from, n = i[i.length - 1].to; return { parsedPos: r, advance() { var t = ga; if (t) { for (var e of i) t.tempSkipped.push(e); s && (t.scheduleOn = t.scheduleOn ? Promise.all([t.scheduleOn, s]) : s) } return this.parsedPos = n, new B(vo.none, [], [], n - r) }, stoppedAt: null, stopAt() { } } } } } isDone(t) { t = Math.min(t, this.state.doc.length); var e = this.fragments; return this.treeLen >= t && e.length && 0 == e[0].from && e[0].to >= t } static get() { return ga } }; function wa(t, e, i) { return qo.applyChanges(t, [{ fromA: e, toA: i, fromB: e, toB: i }]) } var ba = class wp { constructor(t) { this.context = t, this.tree = t.tree } apply(t) { var e; return t.docChanged || this.tree != this.context.tree ? (e = this.context.changes(t.changes, t.state), t = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to), e.work(20, t) || e.takeTree(), new wp(e)) : this } static init(t) { var e = Math.min(3e3, t.doc.length), t = va.create(t.facet(xa).parser, t, { from: 0, to: e }); return t.work(20, e) || t.takeTree(), new wp(t) } }, ya = (fa.state = f.define({ create: ba.init, update(t, e) { for (var i of e.effects) if (i.is(fa.setState)) return i.value; return e.startState.facet(xa) != e.state.facet(xa) ? ba.init(e.state) : t.apply(e) } }), t => { let e = setTimeout(() => t(), 500); return () => clearTimeout(e) }), Sa = ("undefined" != typeof requestIdleCallback && (ya = t => { let e = -1, i = setTimeout(() => { e = requestIdleCallback(t, { timeout: 400 }) }, 100); return () => e < 0 ? clearTimeout(i) : cancelIdleCallback(e) }), "undefined" != typeof navigator && null != (Ge = navigator.scheduling) && Ge.isInputPending ? () => navigator.scheduling.isInputPending() : null), Qa = a.fromClass(class { constructor(t) { this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork() } update(t) { var e = this.view.state.field(fa.state).context; (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e) } scheduleWork() { var t, e; this.working || (t = this.view.state, (e = t.field(fa.state)).tree == e.context.tree && e.context.isDone(t.doc.length)) || (this.working = ya(this.work)) } work(e) { this.working = null; var i = Date.now(); if (this.chunkEnd < i && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = i + 3e4, this.chunkBudget = 3e3), !(this.chunkBudget <= 0)) { var { state: r, viewport: { to: n } } = this.view, s = r.field(fa.state); if (s.tree != s.context.tree || !s.context.isDone(n + 1e5)) { let t = Date.now() + Math.min(this.chunkBudget, 100, e && !Sa ? Math.max(25, e.timeRemaining() - 5) : 1e9); e = s.context.treeLen < n && r.doc.length > n + 1e3, r = s.context.work(() => Sa && Sa() || Date.now() > t, n + (e ? 0 : 1e5)); this.chunkBudget -= Date.now() - i, (r || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: fa.setState.of(new ba(s.context)) })), 0 < this.chunkBudget && (!r || e) && this.scheduleWork(), this.checkAsyncSchedule(s.context) } } } checkAsyncSchedule(t) { t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch(t => Bi(this.view.state, t)).then(() => this.workScheduled--), t.scheduleOn = null) } destroy() { this.working && this.working() } isWorking() { return !!(this.working || 0 < this.workScheduled) } }, { eventHandlers: { focus() { this.scheduleWork() } } }), xa = d.define({ combine(t) { return t.length ? t[0] : null }, enables: e => [fa.state, Qa, $.contentAttributes.compute([e], t => { t = t.facet(e); return t && t.name ? { "data-language": t.name } : {} })] }), ka = class { constructor(t, e = []) { this.language = t, this.support = e, this.extension = [t, e] } }, $a = d.define(), Pa = d.define({ combine: t => { if (!t.length) return "  "; let e = t[0]; if (!e || /\S/.test(e) || Array.from(e).some(t => t != e[0])) throw new Error("Invalid indent unit: " + JSON.stringify(t[0])); return e } }); function Za(t) { var e = t.facet(Pa); return 9 == e.charCodeAt(0) ? t.tabSize * e.length : e.length } function Ta(t, e) { let i = "", r = t.tabSize, n = t.facet(Pa)[0]; if ("\t" == n) { for (; r <= e;)i += "\t", e -= r; n = " " } for (let t = 0; t < e; t++)i += n; return i } function Ca(t, r) { for (var e of (t = t instanceof v ? new Xa(t) : t).state.facet($a)) { e = e(t, r); if (void 0 !== e) return e } var n = T(t.state); if (n.length >= r) { var s = t, o = r; let e = n.resolveStack(o), i = e.node.enterUnfinishedNodesBefore(o); if (i != e.node) { var a = []; for (let t = i; t != e.node; t = t.parent)a.push(t); for (let t = a.length - 1; 0 <= t; t--)e = { node: a[t], next: e } } return Ra(e, s, o) } return null } var Xa = class { constructor(t, e = {}) { this.state = t, this.options = e, this.unit = Za(t) } lineAt(t, e = 1) { var i = this.state.doc.lineAt(t), { simulateBreak: r, simulateDoubleBreak: n } = this.options; return null != r && r >= i.from && r <= i.to ? n && r == t ? { text: "", from: t } : (e < 0 ? r < t : r <= t) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i } textAfterPos(t, e = 1) { var i; return this.options.simulateDoubleBreak && t == this.options.simulateBreak ? "" : ({ text: e, from: i } = this.lineAt(t, e), e.slice(t - i, Math.min(e.length, t + 100 - i))) } column(t, e = 1) { var { text: e, from: i } = this.lineAt(t, e); let r = this.countColumn(e, t - i); t = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1; return -1 < t && (r += t - this.countColumn(e, e.search(/\S|$/))), r } countColumn(t, e = t.length) { return oe(t, this.state.tabSize, e) } lineIndent(t, e = 1) { var { text: t, from: e } = this.lineAt(t, e), i = this.options.overrideIndentation; if (i) { i = i(e); if (-1 < i) return i } return this.countColumn(t, t.search(/\S|$/)) } get simulatedBreak() { return this.options.simulateBreak || null } }, Aa = new z; function Ra(e, i, r) { for (let t = e; t; t = t.next) { var n = (t => { var e = t.type.prop(Aa); if (e) return e; let i = t.firstChild, r; if (i && (r = i.type.prop(z.closedBy))) { let e = t.lastChild, i = e && -1 < r.indexOf(e.name); return t => Ma(t, !0, 1, void 0, i && ((t = t).pos != t.options.simulateBreak || !t.options.simulateDoubleBreak) ? e.from : void 0) } return null == t.parent ? Ya : null })(t.node); if (n) return n(Wa.create(i, r, t)) } return 0 } function Ya() { return 0 } var Wa = class bp extends Xa { constructor(t, e, i) { super(t.state, t.options), this.base = t, this.pos = e, this.context = i } get node() { return this.context.node } static create(t, e, i) { return new bp(t, e, i) } get textAfter() { return this.textAfterPos(this.pos) } get baseIndent() { return this.baseIndentFor(this.node) } baseIndentFor(e) { let i = this.state.doc.lineAt(e.from); for (; ;) { let t = e.resolve(i.from); for (; t.parent && t.parent.from == t.from;)t = t.parent; if (((e, i) => { for (let t = i; t; t = t.parent)if (e == t) return 1 })(t, e)) break; i = this.state.doc.lineAt(t.from) } return this.lineIndent(i.from) } continue() { return Ra(this.context.next, this.base, this.pos) } }; function Va({ closing: e, align: i = !0, units: r = 1 }) { return t => Ma(t, i, r, e) } function Ma(t, e, i, r, n) { var s = t.textAfter, o = s.match(/^\s*/)[0].length, s = r && s.slice(o, o + r.length) == r || n == t.pos + o, r = e ? (t => { var e = t.node, i = e.childAfter(e.from), r = e.lastChild; if (!i) return null; var n = t.options.simulateBreak, t = t.state.doc.lineAt(i.from), s = null == n || n <= t.from ? t.to : Math.min(t.to, n); for (let t = i.to; ;) { var o = e.childAfter(t); if (!o || o == r) return null; if (!o.type.isSkipped) return o.from < s ? i : null; t = o.to } })(t) : null; return r ? s ? t.column(r.from) : t.column(r.to) : t.baseIndent + (s ? 0 : t.unit * i) } function qa({ except: i, units: r = 1 } = {}) { return t => { var e = i && i.test(t.textAfter); return t.baseIndent + (e ? 0 : r * t.unit) } } var _a = d.define(), ja = new z; function Ea(t) { var e = t.firstChild, i = t.lastChild; return e && e.to < i.from ? { from: e.to, to: i.type.isError ? t.to : i.from } : null } function Da(t, i, r) { for (var e of t.facet(_a)) { e = e(t, i, r); if (e) return e } { var n = t, s = i, o = r, a, l = T(n); if (l.length < o) return null; let e = null; for (let t = l.resolveStack(o, 1); t; t = t.next) { var h = t.node; if (!(h.to <= o || h.from > o)) { if (e && h.from < s) break; var c, d = h.type.prop(ja); d && (h.to < l.length - 50 || l.length == n.doc.length || (a = void 0, !(a = (c = h).lastChild)) || a.to != c.to || !a.type.isError) && (c = d(h, n)) && c.from <= o && c.from >= s && c.to > o && (e = c) } } return e } } function za(t, e) { var i = e.mapPos(t.from, 1), e = e.mapPos(t.to, -1); return e <= i ? void 0 : { from: i, to: e } } var Ba = c.define({ map: za }), Ga = c.define({ map: za }); function Ia(t) { var i = []; for (let { head: e } of t.state.selection.ranges) i.some(t => t.from <= e && t.to >= e) || i.push(t.lineBlockAt(e)); return i } var Na = f.define({ create() { return S.none }, update(t, e) { t = t.map(e.changes); for (let i of e.effects) { var r; i.is(Ba) && !((t, i, r) => { let n = !1; return t.between(i, i, (t, e) => { t == i && e == r && (n = !0) }), n })(t, i.value.from, i.value.to) ? (r = e.state.facet(Ka).preparePlaceholder, r = r ? S.replace({ widget: new rl(r(e.state, i.value)) }) : il, t = t.update({ add: [r.range(i.value.from, i.value.to)] })) : i.is(Ga) && (t = t.update({ filter: (t, e) => i.value.from != t || i.value.to != e, filterFrom: i.value.from, filterTo: i.value.to })) } if (e.selection) { let i = !1, r = e.selection.main.head; t.between(r, r, (t, e) => { t < r && e > r && (i = !0) }), i && (t = t.update({ filterFrom: r, filterTo: r, filter: (t, e) => e <= r || t >= r })) } return t }, provide: t => $.decorations.from(t), toJSON(t, e) { let i = []; return t.between(0, e.doc.length, (t, e) => { i.push(t, e) }), i }, fromJSON(e) { if (!Array.isArray(e) || e.length % 2) throw new RangeError("Invalid JSON for fold state"); var i = []; for (let t = 0; t < e.length;) { var r = e[t++], n = e[t++]; if ("number" != typeof r || "number" != typeof n) throw new RangeError("Invalid JSON for fold state"); i.push(il.range(r, n)) } return S.set(i, !0) } }); function Ua(t, e, i) { let r, n = null; return null != (r = t.field(Na, !1)) && r.between(e, i, (t, e) => { (!n || n.from > t) && (n = { from: t, to: e }) }), n } function La(t, e) { return t.field(Na, !1) ? e : e.concat(c.appendConfig.of(tl())) } function Fa(t, e, i = !0) { var r = t.state.doc.lineAt(e.from).number, e = t.state.doc.lineAt(e.to).number; return $.announce.of(`${t.state.phrase(i ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${e}.`) } var Ha = [{ key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: t => { for (var e of Ia(t)) { e = Da(t.state, e.from, e.to); if (e) return t.dispatch({ effects: La(t.state, [Ba.of(e), Fa(t, e)]) }), !0 } return !1 } }, { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: t => { if (!t.state.field(Na, !1)) return !1; var e, i = []; for (e of Ia(t)) { var r = Ua(t.state, e.from, e.to); r && i.push(Ga.of(r), Fa(t, r, !1)) } return i.length && t.dispatch({ effects: i }), 0 < i.length } }, { key: "Ctrl-Alt-[", run: e => { var i = e.state, r = []; for (let t = 0; t < i.doc.length;) { var n = e.lineBlockAt(t), s = Da(i, n.from, n.to); s && r.push(Ba.of(s)), t = (s ? e.lineBlockAt(s.to) : n).to + 1 } return r.length && e.dispatch({ effects: La(e.state, r) }), !!r.length } }, { key: "Ctrl-Alt-]", run: t => { var e = t.state.field(Na, !1); if (!e || !e.size) return !1; let i = []; return e.between(0, t.state.doc.length, (t, e) => { i.push(Ga.of({ from: t, to: e })) }), t.dispatch({ effects: i }), !0 } }], Ja = { placeholderDOM: null, preparePlaceholder: null, placeholderText: "â€¦" }, Ka = d.define({ combine(t) { return Bt(t, Ja) } }); function tl(t) { var e = [Na, al]; return t && e.push(Ka.of(t)), e } function el(i, t) { var e = i.state, r = e.facet(Ka), n = t => { var e = i.lineBlockAt(i.posAtDOM(t.target)), e = Ua(i.state, e.from, e.to); e && i.dispatch({ effects: Ga.of(e) }), t.preventDefault() }; return r.placeholderDOM ? r.placeholderDOM(i, n, t) : ((t = document.createElement("span")).textContent = r.placeholderText, t.setAttribute("aria-label", e.phrase("folded code")), t.title = e.phrase("unfold"), t.className = "cm-foldPlaceholder", t.onclick = n, t) } var il = S.replace({ widget: new class extends Ne { toDOM(t) { return el(t, null) } } }), rl = class extends Ne { constructor(t) { super(), this.value = t } eq(t) { return this.value == t.value } toDOM(t) { return el(t, this.value) } }, nl = { openText: "âŒ„", closedText: "â€º", markerDOM: null, domEventHandlers: {}, foldingChanged: () => !1 }, sl = class extends Ue { constructor(t, e) { super(), this.config = t, this.open = e } eq(t) { return this.config == t.config && this.open == t.open } toDOM(t) { var e; return this.config.markerDOM ? this.config.markerDOM(this.open) : ((e = document.createElement("span")).textContent = this.open ? this.config.openText : this.config.closedText, e.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), e) } }; function ol(t = {}) { let e = Object.assign(Object.assign({}, nl), t), n = new sl(e, !0), s = new sl(e, !1), i = a.fromClass(class { constructor(t) { this.from = t.viewport.from, this.markers = this.buildMarkers(t) } update(t) { (t.docChanged || t.viewportChanged || t.startState.facet(xa) != t.state.facet(xa) || t.startState.field(Na, !1) != t.state.field(Na, !1) || T(t.startState) != T(t.state) || e.foldingChanged(t)) && (this.markers = this.buildMarkers(t.view)) } buildMarkers(t) { var e, i = new Lt; for (e of t.viewportLineBlocks) { var r = Ua(t.state, e.from, e.to) ? s : Da(t.state, e.from, e.to) ? n : null; r && i.add(e.from, e.from, r) } return i.finish() } }), r = e.domEventHandlers; return [i, (t = { class: "cm-foldGutter", markers(t) { return (null == (t = t.plugin(i)) ? void 0 : t.markers) || w.empty }, initialSpacer() { return new sl(e, !1) }, domEventHandlers: Object.assign(Object.assign({}, r), { click: (t, e, i) => !((!r.click || !r.click(t, e, i)) && ((i = Ua(t.state, e.from, e.to)) ? (t.dispatch({ effects: Ga.of(i) }), 0) : !(i = Da(t.state, e.from, e.to)) || (t.dispatch({ effects: Ba.of(i) }), 0))) }) }, [Js(), Fs.of(Object.assign(Object.assign({}, Ls), t))]), tl()] } var al = $.baseTheme({ ".cm-foldPlaceholder": { backgroundColor: "#eee", border: "1px solid #ddd", color: "#888", borderRadius: ".2em", margin: "0 1px", padding: "0 1px", cursor: "pointer" }, ".cm-foldGutter span": { padding: "0 1px", cursor: "pointer" } }), ll = class yp { constructor(t, e) { this.specs = t; let i; function r(t) { var e = Oe.newName(); return (i = i || Object.create(null))["." + e] = t, e } var n = "string" == typeof e.all ? e.all : e.all ? r(e.all) : void 0; let s = e.scope; this.scope = s instanceof fa ? t => t.prop(da) == s.data : s ? t => t == s : void 0, this.style = na(t.map(t => ({ tag: t.tag, class: t.class || r(Object.assign({}, t, { tag: null })) })), { all: n }).style, this.module = i ? new Oe(i) : null, this.themeType = e.themeType } static define(t, e) { return new yp(t, e || {}) } }, hl = d.define(), cl = d.define({ combine(t) { return t.length ? [t[0]] : null } }); function dl(t) { var e = t.facet(hl); return e.length ? e : t.facet(cl) } function Ol(e, t) { let i = [ul], r; return e instanceof ll && (e.module && i.push($.styleModule.of(e.module)), r = e.themeType), null != t && t.fallback ? i.push(cl.of(e)) : r ? i.push(hl.computeN([$.darkTheme], t => t.facet($.darkTheme) == ("dark" == r) ? [e] : [])) : i.push(hl.of(e)), i } var ul = vt.high(a.fromClass(class { constructor(t) { this.markCache = Object.create(null), this.tree = T(t.state), this.decorations = this.buildDeco(t, dl(t.state)) } update(t) { var e = T(t.state), i = dl(t.state), r = i != dl(t.startState); e.length < t.view.viewport.to && !r && e.type == this.tree.type ? this.decorations = this.decorations.map(t.changes) : (e != this.tree || t.viewportChanged || r) && (this.tree = e, this.decorations = this.buildDeco(t.view, i)) } buildDeco(t, e) { if (!e || !this.tree.length) return S.none; let r = new Lt; for (var { from: i, to: n } of t.visibleRanges) sa(this.tree, e, (t, e, i) => { r.add(t, e, this.markCache[i] || (this.markCache[i] = S.mark({ class: i }))) }, i, n); return r.finish() } }, { decorations: t => t.decorations })), fl = ll.define([{ tag: Z.meta, color: "#404740" }, { tag: Z.link, textDecoration: "underline" }, { tag: Z.heading, textDecoration: "underline", fontWeight: "bold" }, { tag: Z.emphasis, fontStyle: "italic" }, { tag: Z.strong, fontWeight: "bold" }, { tag: Z.strikethrough, textDecoration: "line-through" }, { tag: Z.keyword, color: "#708" }, { tag: [Z.atom, Z.bool, Z.url, Z.contentSeparator, Z.labelName], color: "#219" }, { tag: [Z.literal, Z.inserted], color: "#164" }, { tag: [Z.string, Z.deleted], color: "#a11" }, { tag: [Z.regexp, Z.escape, Z.special(Z.string)], color: "#e40" }, { tag: Z.definition(Z.variableName), color: "#00f" }, { tag: Z.local(Z.variableName), color: "#30a" }, { tag: [Z.typeName, Z.namespace], color: "#085" }, { tag: Z.className, color: "#167" }, { tag: [Z.special(Z.variableName), Z.macroName], color: "#256" }, { tag: Z.definition(Z.propertyName), color: "#00c" }, { tag: Z.comment, color: "#940" }, { tag: Z.invalid, color: "#f00" }]), Ie = $.baseTheme({ "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" }, "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" } }), pl = 1e4, ml = "()[]{}", gl = d.define({ combine(t) { return Bt(t, { afterCursor: !0, brackets: ml, maxScanDistance: pl, renderMatch: bl }) } }), vl = S.mark({ class: "cm-matchingBracket" }), wl = S.mark({ class: "cm-nonmatchingBracket" }); function bl(t) { var e = [], i = t.matched ? vl : wl; return e.push(i.range(t.start.from, t.start.to)), t.end && e.push(i.range(t.end.from, t.end.to)), e } var yl = [f.define({ create() { return S.none }, update(t, e) { if (!e.docChanged && !e.selection) return t; let i = []; var r, n, s = e.state.facet(gl); for (r of e.state.selection.ranges) r.empty && (n = kl(e.state, r.head, -1, s) || 0 < r.head && kl(e.state, r.head - 1, 1, s) || s.afterCursor && (kl(e.state, r.head, 1, s) || r.head < e.state.doc.length && kl(e.state, r.head + 1, -1, s))) && (i = i.concat(s.renderMatch(n, e.state))); return S.set(i, !0) }, provide: t => $.decorations.from(t) }), Ie]; var Sl = new z; function Ql(t, e, i) { var r = t.prop(e < 0 ? z.openedBy : z.closedBy); if (r) return r; if (1 == t.name.length) { r = i.indexOf(t.name); if (-1 < r && r % 2 == (e < 0 ? 1 : 0)) return [i[r + e]] } return null } function xl(t) { var e = t.type.prop(Sl); return e ? e(t.node) : t } function kl(t, s, o, n = {}) { var a = n.maxScanDistance || pl, l = n.brackets || ml, n = T(t), h = n.resolveInner(s, o); for (let n = h; n; n = n.parent) { var c = Ql(n.type, o, l); if (c && n.from < n.to) { var d, O = xl(n); if (O && (0 < o ? s >= O.from && s < O.to : s > O.from && s <= O.to)) { var u = o; var f = n; var p = c; var m = l; let t = f.parent, e = { from: O.from, to: O.to }, i = 0, r = null == t ? void 0 : t.cursor(); if (r && (u < 0 ? r.childBefore(f.from) : r.childAfter(f.to))) do { if (u < 0 ? r.to <= f.from : r.from >= f.to) { if (0 == i && -1 < p.indexOf(r.type.name) && r.from < r.to) return d = xl(r), { start: e, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 }; if (Ql(r.type, u, m)) i++; else if (Ql(r.type, -u, m)) { if (0 == i) return d = xl(r), { start: e, end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0, matched: !1 }; i-- } } } while (u < 0 ? r.prevSibling() : r.nextSibling()); return { start: e, matched: !1 }; return } } } { var g = s, v = o, w = n, b = h.type, y = a, S = l, n = v < 0 ? t.sliceDoc(g - 1, g) : t.sliceDoc(g, g + 1), Q = S.indexOf(n); if (Q < 0 || Q % 2 == 0 != 0 < v) return null; let i = { from: v < 0 ? g - 1 : g, to: 0 < v ? g + 1 : g }, e = t.doc.iterRange(g, 0 < v ? t.doc.length : 0), r = 0; for (let t = 0; !e.next().done && t <= y;) { var x = e.value, k = (v < 0 && (t += x.length), g + t * v); for (let t = 0 < v ? 0 : x.length - 1, e = 0 < v ? x.length : -1; t != e; t += v) { var $ = S.indexOf(x[t]); if (!($ < 0 || w.resolveInner(k + t, 1).type != b)) if ($ % 2 == 0 == 0 < v) r++; else { if (1 == r) return { start: i, end: { from: k + t, to: k + t + 1 }, matched: $ >> 1 == Q >> 1 }; r-- } } 0 < v && (t += x.length) } return e.done ? { start: i, matched: !1 } : null } } var $l, Pl, Zl = Object.create(null), Tl = [vo.none], Cl = [], Xl = Object.create(null), Al = Object.create(null); for ([$l, Pl] of [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]]) Al[$l] = Yl(Zl, Pl); function Rl(t, e) { -1 < Cl.indexOf(t) || (Cl.push(t), console.warn(e)) } function Yl(e, t) { var i, r, n = []; for (i of t.split(" ")) { let t = []; for (var s of i.split(".")) { var o = e[s] || Z[s]; o ? "function" == typeof o ? t.length ? t = t.map(o) : Rl(s, `Modifier ${s} used at start of tag`) : t.length ? Rl(s, `Tag ${s} used as modifier`) : t = Array.isArray(o) ? o : [o] : Rl(s, "Unknown highlighting tag " + s) } for (var a of t) n.push(a) } return n.length ? (r = (t = t.replace(/ /g, "_")) + " " + n.map(t => t.id), (Xl[r] || (r = Xl[r] = vo.define({ id: Tl.length, name: t, props: [ea({ [t]: n })] }), Tl.push(r), r)).id) : 0 } k.RTL, k.LTR; function Wl(r, n) { return ({ state: t, dispatch: e }) => { var i; return !t.readOnly && !!(i = r(n, t)) && (e(t.update(i)), !0) } } var Vl = Wl(El, 0), Be = Wl(jl, 0), Ml = Wl((t, e) => jl(t, e, (t => { var e = []; for (r of t.selection.ranges) { var i = t.doc.lineAt(r.from), r = r.to <= i.to ? i : t.doc.lineAt(r.to), n = e.length - 1; 0 <= n && e[n].to > i.from ? e[n].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to }) } return e })(e)), 0); function ql(t, e) { t = t.languageDataAt("commentTokens", e); return t.length ? t[0] : {} } var _l = 50; function jl(t, O, e = O.selection.ranges) { let u = e.map(t => ql(O, t.from).block); if (u.every(t => t)) { let i = e.map((i, r) => { { var [r, { open: i, close: n }, s, o] = [O, u[r], i.from, i.to], a = r.sliceDoc(s - _l, s), l = r.sliceDoc(o, o + _l), h = /\s*$/.exec(a)[0].length, c = /^\s*/.exec(l)[0].length, d = a.length - h; if (a.slice(d - i.length, d) == i && l.slice(c, c + n.length) == n) return { open: { pos: s - h, margin: h && 1 }, close: { pos: o + c, margin: c && 1 } }; let t, e; return o - s <= 2 * _l ? t = e = r.sliceDoc(s, o) : (t = r.sliceDoc(s, s + _l), e = r.sliceDoc(o - _l, o)), a = /^\s*/.exec(t)[0].length, d = /\s*$/.exec(e)[0].length, l = e.length - d - n.length, t.slice(a, a + i.length) == i && e.slice(l, l + n.length) == n ? { open: { pos: s + a + i.length, margin: /\s/.test(t.charAt(a + i.length)) ? 1 : 0 }, close: { pos: o - d - n.length, margin: /\s/.test(e.charAt(l - 1)) ? 1 : 0 } } : null } }); if (2 != t && !i.every(t => t)) return { changes: O.changes(e.map((t, e) => i[e] ? [] : [{ from: t.from, insert: u[e].open + " " }, { from: t.to, insert: " " + u[e].close }])) }; if (1 != t && i.some(t => t)) { var r, n, s, o = []; for (let t = 0, e; t < i.length; t++)(e = i[t]) && (r = u[t], { open: n, close: s } = e, o.push({ from: n.pos - r.open.length, to: n.pos + n.margin }, { from: s.pos - s.margin, to: s.pos + r.close.length })); return { changes: o } } } return null } function El(t, r, e = r.selection.ranges) { var n, s, o = []; let a = -1; for ({ from: n, to: s } of e) { let e = o.length, i = 1e9; var l = ql(r, n).line; if (l) { for (let t = n; t <= s;) { var h, c, d, O = r.doc.lineAt(t); O.from > a && (n == s || s > O.from) && (a = O.from, c = (h = /^\s*/.exec(O.text)[0].length) == O.length, d = O.text.slice(h, h + l.length) == l ? h : -1, h < O.text.length && h < i && (i = h), o.push({ line: O, comment: d, token: l, indent: h, empty: c, single: !1 })), t = O.to + 1 } if (i < 1e9) for (let t = e; t < o.length; t++)o[t].indent < o[t].line.text.length && (o[t].indent = i); o.length == e + 1 && (o[e].single = !0) } } if (2 != t && o.some(t => t.comment < 0 && (!t.empty || t.single))) { var i, u, f, p, m, g = []; for ({ line: i, token: u, indent: f, empty: p, single: m } of o) !m && p || g.push({ from: i.from + f, insert: u + " " }); e = r.changes(g); return { changes: e, selection: r.selection.map(e, 1) } } if (1 != t && o.some(t => 0 <= t.comment)) { var v, w, b, y = []; for ({ line: v, comment: w, token: b } of o) if (0 <= w) { let t = v.from + w, e = t + b.length; " " == v.text[e - v.from] && e++, y.push({ from: t, to: e }) } return { changes: y } } return null } var Dl = At.define(), zl = At.define(), Bl = d.define(), Gl = d.define({ combine(t) { return Bt(t, { minDepth: 100, newGroupDelay: 500, joinToEvent: (t, e) => e }, { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (i, r) => (t, e) => i(t, e) || r(t, e) }) } }), Il = f.define({ create() { return nh.empty }, update(e, i) { var r = i.state.facet(Gl), n = i.annotation(Dl); if (n) { var s = Fl.fromTransaction(i, n.selection), o = n.side; let t = 0 == o ? e.undone : e.done; return t = s ? Hl(t, t.length, r.minDepth, s) : eh(t, i.startState.selection), new nh(0 == o ? n.rest : t, 0 == o ? t : n.rest) } var t, s = i.annotation(zl); return "full" != s && "before" != s || (e = e.isolate()), !1 === i.annotation(Wt.addToHistory) ? i.changes.empty ? e : e.addMapping(i.changes.desc) : (o = Fl.fromTransaction(i), n = i.annotation(Wt.time), t = i.annotation(Wt.userEvent), o ? e = e.addChanges(o, n, t, r, i) : i.selection && (e = e.addSelection(i.startState.selection, n, t, r.newGroupDelay)), "full" != s && "after" != s ? e : e.isolate()) }, toJSON(t) { return { done: t.done.map(t => t.toJSON()), undone: t.undone.map(t => t.toJSON()) } }, fromJSON(t) { return new nh(t.done.map(Fl.fromJSON), t.undone.map(Fl.fromJSON)) } }); function Nl(r, n) { return function({ state: t, dispatch: e }) { var i; return !(!n && t.readOnly || !(i = t.field(Il, !1)) || !(i = i.pop(r, t, n)) || (e(i), 0)) } } var Ul = Nl(0, !1), Ll = Nl(1, !1), i = Nl(0, !0), n = Nl(1, !0), Fl = class Sp { constructor(t, e, i, r, n) { this.changes = t, this.effects = e, this.mapped = i, this.startSelection = r, this.selectionsAfter = n } setSelAfter(t) { return new Sp(this.changes, this.effects, this.mapped, this.startSelection, t) } toJSON() { var t; return { changes: null == (t = this.changes) ? void 0 : t.toJSON(), mapped: null == (t = this.mapped) ? void 0 : t.toJSON(), startSelection: null == (t = this.startSelection) ? void 0 : t.toJSON(), selectionsAfter: this.selectionsAfter.map(t => t.toJSON()) } } static fromJSON(t) { return new Sp(t.changes && it.fromJSON(t.changes), [], t.mapped && et.fromJSON(t.mapped), t.startSelection && g.fromJSON(t.startSelection), t.selectionsAfter.map(g.fromJSON)) } static fromTransaction(t, e) { let i = Kl; for (var r of t.startState.facet(Bl)) { r = r(t); r.length && (i = i.concat(r)) } return !i.length && t.changes.empty ? null : new Sp(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, Kl) } static selection(t) { return new Sp(void 0, Kl, void 0, void 0, t) } }; function Hl(t, e, i, r) { t = t.slice(i + 20 < e + 1 ? e - i - 1 : 0, e); return t.push(r), t } function Jl(t, e) { return t.length ? e.length ? t.concat(e) : t : e } var Kl = [], th = 200; function eh(t, e) { var i, r; return t.length ? (r = (i = t[t.length - 1]).selectionsAfter.slice(Math.max(0, i.selectionsAfter.length - th))).length && r[r.length - 1].eq(e) ? t : (r.push(e), Hl(t, t.length - 1, 1e9, i.setSelAfter(r))) : [Fl.selection([e])] } function ih(t, e) { if (!t.length) return t; let i = t.length, r = Kl; for (; i;) { var n, s = ((t, e, i) => { var r, n, s; return i = Jl(t.selectionsAfter.length ? t.selectionsAfter.map(t => t.map(e)) : Kl, i), t.changes ? (r = t.changes.map(e), n = e.mapDesc(t.changes, !0), s = t.mapped ? t.mapped.composeDesc(n) : n, new Fl(r, c.mapEffects(t.effects, e), s, t.startSelection.map(n), i)) : Fl.selection(i) })(t[i - 1], e, r); if (s.changes && !s.changes.empty || s.effects.length) return (n = t.slice(0, i))[i - 1] = s, n; e = s.mapped, i--, r = s.selectionsAfter } return r.length ? [Fl.selection(r)] : Kl } var rh = /^(input\.type|delete)($|\.)/, nh = class Qp { constructor(t, e, i = 0, r = void 0) { this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = r } isolate() { return this.prevTime ? new Qp(this.done, this.undone) : this } addChanges(t, e, i, r, n) { let s = this.done, o = s[s.length - 1]; return s = o && o.changes && !o.changes.empty && t.changes && (!i || rh.test(i)) && (!o.selectionsAfter.length && e - this.prevTime < r.newGroupDelay && r.joinToEvent(n, ((t, e) => { let o = [], a = !1; return t.iterChangedRanges((t, e) => o.push(t, e)), e.iterChangedRanges((t, e, i, r) => { for (let t = 0; t < o.length;) { var n = o[t++], s = o[t++]; n <= r && i <= s && (a = !0) } }), a })(o.changes, t.changes)) || "input.type.compose" == i) ? Hl(s, s.length - 1, r.minDepth, new Fl(t.changes.compose(o.changes), Jl(t.effects, o.effects), o.mapped, o.startSelection, Kl)) : Hl(s, s.length, r.minDepth, t), new Qp(s, Kl, e, i) } addSelection(t, e, i, r) { var n, s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Kl; return 0 < s.length && e - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && (r = s[s.length - 1], n = t, r.ranges.length == n.ranges.length) && 0 === r.ranges.filter((t, e) => t.empty != n.ranges[e].empty).length ? this : new Qp(eh(this.done, t), this.undone, e, i) } addMapping(t) { return new Qp(ih(this.done, t), ih(this.undone, t), this.prevTime, this.prevUserEvent) } pop(e, i, t) { var r, n, s = 0 == e ? this.done : this.undone; if (0 != s.length) { var o = s[s.length - 1], a = o.selectionsAfter[0] || i.selection; if (t && o.selectionsAfter.length) return i.update({ selection: o.selectionsAfter[o.selectionsAfter.length - 1], annotations: Dl.of({ side: e, rest: (r = (t = s)[t.length - 1], (n = t.slice())[t.length - 1] = r.setSelAfter(r.selectionsAfter.slice(0, r.selectionsAfter.length - 1)), n), selection: a }), userEvent: 0 == e ? "select.undo" : "select.redo", scrollIntoView: !0 }); if (o.changes) { let t = 1 == s.length ? Kl : s.slice(0, s.length - 1); return o.mapped && (t = ih(t, o.mapped)), i.update({ changes: o.changes, selection: o.startSelection, effects: o.effects, annotations: Dl.of({ side: e, rest: t, selection: a }), filter: !1, userEvent: 0 == e ? "undo" : "redo", scrollIntoView: !0 }) } } return null } }, sh = (nh.empty = new nh(Kl, Kl), [{ key: "Mod-z", run: Ul, preventDefault: !0 }, { key: "Mod-y", mac: "Mod-Shift-z", run: Ll, preventDefault: !0 }, { linux: "Ctrl-Shift-z", run: Ll, preventDefault: !0 }, { key: "Mod-u", run: i, preventDefault: !0 }, { key: "Alt-u", mac: "Mod-Shift-u", run: n, preventDefault: !0 }]); function oh(t, e) { return g.create(t.ranges.map(e), t.mainIndex) } function ah(t, e) { return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" }) } function lh({ state: t, dispatch: e }, i) { i = oh(t.selection, i); return !i.eq(t.selection, !0) && (e(ah(t, i)), !0) } function hh(t, e) { return g.cursor(e ? t.to : t.from) } function ch(e, i) { return lh(e, t => t.empty ? e.moveByChar(t, i) : hh(t, i)) } function C(t) { return t.textDirectionAt(t.state.selection.main.head) == k.LTR } e = t => ch(t, !C(t)), o = t => ch(t, C(t)); function dh(e, i) { return lh(e, t => t.empty ? e.moveByGroup(t, i) : hh(t, i)) } function Oh(e, i, r) { let n = T(e).resolveInner(i.head); var s, o, a, l = r ? z.closedBy : z.openedBy; for (let t = i.head; ;) { var h = r ? n.childAfter(t) : n.childBefore(t); if (!h) break; s = e, a = l, (o = h).type.prop(a) || (a = o.to - o.from) && (2 < a || /[^\s,.;:]/.test(s.sliceDoc(o.from, o.to))) || o.firstChild ? n = h : t = r ? h.to : h.from } let t = n.type.prop(l), c, d; return d = t && (c = r ? kl(e, n.from, 1) : kl(e, n.to, -1)) && c.matched ? r ? c.end.to : c.end.from : r ? n.to : n.from, g.cursor(d, r ? -1 : 1) } function uh(i, r) { return lh(i, t => { var e; return t.empty ? (e = i.moveVertically(t, r)).head != t.head ? e : i.moveToLineBoundary(t, r) : hh(t, r) }) } l = t => uh(t, !1), la = t => uh(t, !0); function fh(t) { var e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2; let i = 0, r = 0, n; if (e) { for (var s of t.state.facet($.scrollMargins)) { s = s(t); null != s && s.top && (i = Math.max(null == s ? void 0 : s.top, i)), null != s && s.bottom && (r = Math.max(null == s ? void 0 : s.bottom, r)) } n = t.scrollDOM.clientHeight - i - r } else n = (t.dom.ownerDocument.defaultView || window).innerHeight; return { marginTop: i, marginBottom: r, selfScroll: e, height: Math.max(t.defaultLineHeight, n - 5) } } function ph(e, i) { let r = fh(e); var t, n, s, o = e.state, a = oh(o.selection, t => t.empty ? e.moveVertically(t, i, r.height) : hh(t, i)); if (a.eq(o.selection)) return !1; let l; return r.selfScroll && (t = e.coordsAtPos(o.selection.main.head), n = (s = e.scrollDOM.getBoundingClientRect()).top + r.marginTop, s = s.bottom - r.marginBottom, t) && t.top > n && t.bottom < s && (l = $.scrollIntoView(a.main.head, { y: "start", yMargin: t.top - n })), e.dispatch(ah(o, a), { effects: l }), !0 } ha = t => ph(t, !1), aa = t => ph(t, !0); function mh(t, e, i) { let r = t.lineBlockAt(e.head), n = t.moveToLineBoundary(e, i); return n.head == e.head && n.head != (i ? r.to : r.from) && (n = t.moveToLineBoundary(e, i, !1)), n = !i && n.head == r.from && r.length && (i = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length) && e.head != r.from + i ? g.cursor(r.from + i) : n } function gh(t, i) { var e = oh(t.state.selection, t => { var e = i(t); return g.range(t.anchor, e.head, e.goalColumn, e.bidiLevel || void 0) }); return !e.eq(t.state.selection) && (t.dispatch(ah(t.state, e)), !0) } function vh(e, i) { return gh(e, t => e.moveByChar(t, i)) } s = t => vh(t, !C(t)), r = t => vh(t, C(t)); function wh(e, i) { return gh(e, t => e.moveByGroup(t, i)) } function bh(e, i) { return gh(e, t => e.moveVertically(t, i)) } ca = t => bh(t, !1), Ge = t => bh(t, !0); function yh(e, i) { return gh(e, t => e.moveVertically(t, i, fh(e).height)) } var Ue = t => yh(t, !1), Ie = t => yh(t, !0), i = ({ state: t, dispatch: e }) => (e(ah(t, { anchor: 0 })), !0), n = ({ state: t, dispatch: e }) => (e(ah(t, { anchor: t.doc.length })), !0), Sh = ({ state: t, dispatch: e }) => (e(ah(t, { anchor: t.selection.main.anchor, head: 0 })), !0), Qh = ({ state: t, dispatch: e }) => (e(ah(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0); function xh(n, s) { if (n.state.readOnly) return !1; let o = "delete.selection", t = n.state; var e = t.changeByRange(e => { let { from: i, to: r } = e; if (i == r) { let t = s(e); t < i ? (o = "delete.backward", t = kh(n, t, !1)) : t > i && (o = "delete.forward", t = kh(n, t, !0)), i = Math.min(i, t), r = Math.max(r, t) } else i = kh(n, i, !1), r = kh(n, r, !0); return i == r ? { range: e } : { changes: { from: i, to: r }, range: g.cursor(i, i < e.head ? -1 : 1) } }); return !e.changes.empty && (n.dispatch(t.update(e, { scrollIntoView: !0, userEvent: o, effects: "delete.selection" == o ? $.announce.of(t.phrase("Selection deleted")) : void 0 })), !0) } function kh(e, i, r) { if (e instanceof $) for (var t of e.state.facet($.atomicRanges).map(t => t(e))) t.between(i, i, (t, e) => { t < i && i < e && (i = r ? e : t) }); return i } var $h = (a, l) => xh(a, t => { let e = t.from, i = a.state, r = i.doc.lineAt(e), n, s; if (!l && e > r.from && e < r.from + 200 && !/[^ \t]/.test(n = r.text.slice(0, e - r.from))) { if ("\t" == n[n.length - 1]) return e - 1; var o = oe(n, i.tabSize) % Za(i) || Za(i); for (let t = 0; t < o && " " == n[n.length - 1 - t]; t++)e--; s = e } else (s = O(r.text, e - r.from, l, l) + r.from) == e && r.number != (l ? i.doc.lines : 1) ? s += l ? 1 : -1 : !l && /[\ufe00-\ufe0f]/.test(r.text.slice(s - r.from, e - r.from)) && (s = O(r.text, s - r.from, !1, !1) + r.from); return s }), Ph = t => $h(t, !1), Zh = t => $h(t, !0), Th = (t, h) => xh(t, e => { let i = e.head, r = t.state, n = r.doc.lineAt(i); var s = r.charCategorizer(i); for (let t = null; ;) { if (i == (h ? n.to : n.from)) { i == e.head && n.number != (h ? r.doc.lines : 1) && (i += h ? 1 : -1); break } var o = O(n.text, i - n.from, h) + n.from, a = n.text.slice(Math.min(i, o) - n.from, Math.max(i, o) - n.from), l = s(a); if (null != t && l != t) break; " " == a && i == e.head || (t = l), i = o } return i }), Ch = t => Th(t, !1); function Xh(i) { let r = [], n = -1; for (var s of i.selection.ranges) { let t = i.doc.lineAt(s.from), e = i.doc.lineAt(s.to); var o; s.empty || s.to != e.from || (e = i.doc.lineAt(s.to - 1)), n >= t.number ? ((o = r[r.length - 1]).to = e.to, o.ranges.push(s)) : r.push({ from: t.from, to: e.to, ranges: [s] }), n = e.number + 1 } return r } function Ah(t, e, i) { if (t.readOnly) return !1; var r, n = [], s = []; for (r of Xh(t)) if (i ? r.to != t.doc.length : 0 != r.from) { var o = t.doc.lineAt(i ? r.to + 1 : r.from - 1), a = o.length + 1; if (i) { n.push({ from: r.to, to: o.to }, { from: r.from, insert: o.text + t.lineBreak }); for (var l of r.ranges) s.push(g.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a))) } else { n.push({ from: o.from, to: r.from }, { from: r.to, insert: t.lineBreak + o.text }); for (var h of r.ranges) s.push(g.range(h.anchor - a, h.head - a)) } } return !!n.length && (e(t.update({ changes: n, scrollIntoView: !0, selection: g.create(s, t.selection.mainIndex), userEvent: "move.line" })), !0) } function Rh(t, e, i) { if (t.readOnly) return !1; var r, n = []; for (r of Xh(t)) n.push(i ? { from: r.from, insert: t.doc.slice(r.from, r.to) + t.lineBreak } : { from: r.to, insert: t.lineBreak + t.doc.slice(r.from, r.to) }); return e(t.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0 } function Yh(l) { return ({ state: a, dispatch: t }) => { var e; return !a.readOnly && (e = a.changeByRange(t => { let { from: e, to: i } = t, r = a.doc.lineAt(e); var t = !l && e == i && ((t, e) => { if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1))) return { from: e, to: e }; var i = T(t).resolveInner(e); let r = i.childBefore(e), n = i.childAfter(e), s; return r && n && r.to <= e && n.from >= e && (s = r.type.prop(z.closedBy)) && -1 < s.indexOf(n.name) && t.doc.lineAt(r.to).from == t.doc.lineAt(n.from).from && !/\S/.test(t.sliceDoc(r.to, n.from)) ? { from: r.to, to: n.from } : null })(a, e), n = (l && (e = i = (i <= r.to ? r : a.doc.lineAt(i)).to), new Xa(a, { simulateBreak: e, simulateDoubleBreak: !!t })); let s = Ca(n, e); for (null == s && (s = oe(/^\s*/.exec(a.doc.lineAt(e).text)[0], a.tabSize)); i < r.to && /\s/.test(r.text[i - r.from]);)i++; t ? { from: e, to: i } = t : e > r.from && e < r.from + 100 && !/\S/.test(r.text.slice(0, e)) && (e = r.from); var o = ["", Ta(a, s)]; return t && o.push(Ta(a, n.lineIndent(r.from, -1))), { changes: { from: e, to: i, insert: m.of(o) }, range: g.cursor(e + 1 + o[1].length) } }), t(a.update(e, { scrollIntoView: !0, userEvent: "input" })), !0) } } function Wh(n, s) { let o = -1; return n.changeByRange(e => { var i = []; for (let t = e.from; t <= e.to;) { var r = n.doc.lineAt(t); r.number > o && (e.empty || e.to > r.from) && (s(r, i, e), o = r.number), t = r.to + 1 } var t = n.changes(i); return { changes: i, range: g.range(t.mapPos(e.anchor, 1), t.mapPos(e.head, 1)) } }) } var Vh = ({ state: i, dispatch: t }) => !i.readOnly && (t(i.update(Wh(i, (t, e) => { e.push({ from: t.from, insert: i.facet(Pa) }) }), { userEvent: "input.indent" })), !0), Mh = ({ state: o, dispatch: t }) => !o.readOnly && (t(o.update(Wh(o, (i, r) => { var n = /^\s*/.exec(i.text)[0]; if (n) { let t = oe(n, o.tabSize), e = 0; for (var s = Ta(o, Math.max(0, t - Za(o))); e < n.length && e < s.length && n.charCodeAt(e) == s.charCodeAt(e);)e++; r.push({ from: i.from + e, to: i.from + n.length, insert: s.slice(e) }) } }), { userEvent: "delete.dedent" })), !0), qh = [{ key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: e => lh(e, t => Oh(e.state, t, !C(e))), shift: e => gh(e, t => Oh(e.state, t, !C(e))) }, { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: e => lh(e, t => Oh(e.state, t, C(e))), shift: e => gh(e, t => Oh(e.state, t, C(e))) }, { key: "Alt-ArrowUp", run: ({ state: t, dispatch: e }) => Ah(t, e, !1) }, { key: "Shift-Alt-ArrowUp", run: ({ state: t, dispatch: e }) => Rh(t, e, !1) }, { key: "Alt-ArrowDown", run: ({ state: t, dispatch: e }) => Ah(t, e, !0) }, { key: "Shift-Alt-ArrowDown", run: ({ state: t, dispatch: e }) => Rh(t, e, !0) }, { key: "Escape", run: ({ state: t, dispatch: e }) => { let i = t.selection, r = null; return 1 < i.ranges.length ? r = g.create([i.main]) : i.main.empty || (r = g.create([g.cursor(i.main.head)])), !!r && (e(ah(t, r)), !0) } }, { key: "Mod-Enter", run: Yh(!0) }, { key: "Alt-l", mac: "Ctrl-l", run: ({ state: i, dispatch: t }) => { var e = Xh(i).map(({ from: t, to: e }) => g.range(t, Math.min(e + 1, i.doc.length))); return t(i.update({ selection: g.create(e), userEvent: "select" })), !0 } }, { key: "Mod-i", run: ({ state: n, dispatch: t }) => { var e = oh(n.selection, e => { var i; for (let t = T(n).resolveStack(e.from, 1); t; t = t.next) { var r = t.node; if ((r.from < e.from && r.to >= e.to || r.to > e.to && r.from <= e.from) && null != (i = r.parent) && i.parent) return g.range(r.to, r.from) } return e }); return t(ah(n, e)), !0 }, preventDefault: !0 }, { key: "Mod-[", run: Mh }, { key: "Mod-]", run: Vh }, { key: "Mod-Alt-\\", run: ({ state: o, dispatch: t }) => { if (o.readOnly) return !1; let a = Object.create(null), l = new Xa(o, { overrideIndentation: t => { t = a[t]; return null == t ? -1 : t } }); var e = Wh(o, (t, e, i) => { let r = Ca(l, t.from); var n, s; null != r && (/\S/.test(t.text) || (r = 0), (n = /^\s*/.exec(t.text)[0]) != (s = Ta(o, r)) || i.from < t.from + n.length) && (a[t.from] = r, e.push({ from: t.from, to: t.from + n.length, insert: s })) }); return e.changes.empty || t(o.update(e, { userEvent: "indent" })), !0 } }, { key: "Shift-Mod-k", run: e => { if (e.state.readOnly) return !1; let i = e.state, t = i.changes(Xh(i).map(({ from: t, to: e }) => (0 < t ? t-- : e < i.doc.length && e++, { from: t, to: e }))); var r = oh(i.selection, t => e.moveVertically(t, !0)).map(t); return e.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0 } }, { key: "Shift-Mod-\\", run: ({ state: e, dispatch: r }) => { { var n = e, s = (e = r, !1); let i = !1, t = oh(n.selection, t => { var e = kl(n, t.head, -1) || kl(n, t.head, 1) || 0 < t.head && kl(n, t.head - 1, 1) || t.head < n.doc.length && kl(n, t.head + 1, -1); if (!e || !e.end) return t; i = !0; e = e.start.from == t.head ? e.end.to : e.end.from; return s ? g.range(t.anchor, e) : g.cursor(e) }); return !!i && (e(ah(n, t)), !0) } } }, { key: "Mod-/", run: t => { var e = t.state, e = e.doc.lineAt(e.selection.main.from), e = ql(t.state, e.from); return e.line ? Vl(t) : !!e.block && Ml(t) } }, { key: "Alt-A", run: Be }].concat([{ key: "ArrowLeft", run: e, shift: s, preventDefault: !0 }, { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: t => dh(t, !C(t)), shift: t => wh(t, !C(t)), preventDefault: !0 }, { mac: "Cmd-ArrowLeft", run: e => lh(e, t => mh(e, t, !C(e))), shift: e => gh(e, t => mh(e, t, !C(e))), preventDefault: !0 }, { key: "ArrowRight", run: o, shift: r, preventDefault: !0 }, { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: t => dh(t, C(t)), shift: t => wh(t, C(t)), preventDefault: !0 }, { mac: "Cmd-ArrowRight", run: e => lh(e, t => mh(e, t, C(e))), shift: e => gh(e, t => mh(e, t, C(e))), preventDefault: !0 }, { key: "ArrowUp", run: l, shift: ca, preventDefault: !0 }, { mac: "Cmd-ArrowUp", run: i, shift: Sh }, { mac: "Ctrl-ArrowUp", run: ha, shift: Ue }, { key: "ArrowDown", run: la, shift: Ge, preventDefault: !0 }, { mac: "Cmd-ArrowDown", run: n, shift: Qh }, { mac: "Ctrl-ArrowDown", run: aa, shift: Ie }, { key: "PageUp", run: ha, shift: Ue }, { key: "PageDown", run: aa, shift: Ie }, { key: "Home", run: e => lh(e, t => mh(e, t, !1)), shift: e => gh(e, t => mh(e, t, !1)), preventDefault: !0 }, { key: "Mod-Home", run: i, shift: Sh }, { key: "End", run: e => lh(e, t => mh(e, t, !0)), shift: e => gh(e, t => mh(e, t, !0)), preventDefault: !0 }, { key: "Mod-End", run: n, shift: Qh }, { key: "Enter", run: Yh(!1) }, { key: "Mod-a", run: ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0) }, { key: "Backspace", run: Ph, shift: Ph }, { key: "Delete", run: Zh }, { key: "Mod-Backspace", mac: "Alt-Backspace", run: Ch }, { key: "Mod-Delete", mac: "Alt-Delete", run: t => Th(t, !0) }, { mac: "Mod-Backspace", run: i => xh(i, t => { var e = i.moveToLineBoundary(t, !1).head; return t.head > e ? e : Math.max(0, t.head - 1) }) }, { mac: "Mod-Delete", run: i => xh(i, t => { var e = i.moveToLineBoundary(t, !0).head; return t.head < e ? e : Math.min(i.state.doc.length, t.head + 1) }) }].concat([{ key: "Ctrl-b", run: e, shift: s, preventDefault: !0 }, { key: "Ctrl-f", run: o, shift: r }, { key: "Ctrl-p", run: l, shift: ca }, { key: "Ctrl-n", run: la, shift: Ge }, { key: "Ctrl-a", run: e => lh(e, t => g.cursor(e.lineBlockAt(t.head).from, 1)), shift: e => gh(e, t => g.cursor(e.lineBlockAt(t.head).from)) }, { key: "Ctrl-e", run: e => lh(e, t => g.cursor(e.lineBlockAt(t.head).to, -1)), shift: e => gh(e, t => g.cursor(e.lineBlockAt(t.head).to)) }, { key: "Ctrl-d", run: Zh }, { key: "Ctrl-h", run: Ph }, { key: "Ctrl-k", run: i => xh(i, t => { var e = i.lineBlockAt(t.head).to; return t.head < e ? e : Math.min(i.state.doc.length, t.head + 1) }) }, { key: "Ctrl-Alt-h", run: Ch }, { key: "Ctrl-o", run: ({ state: t, dispatch: e }) => { var i; return !t.readOnly && (i = t.changeByRange(t => ({ changes: { from: t.from, to: t.to, insert: m.of(["", ""]) }, range: g.cursor(t.from) })), e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0) } }, { key: "Ctrl-t", run: ({ state: n, dispatch: t }) => { var e; return !n.readOnly && !(e = n.changeByRange(t => { var e, i, r; return t.empty && 0 != t.from && t.from != n.doc.length ? { changes: { from: i = (e = t.from) == (r = n.doc.lineAt(e)).from ? e - 1 : O(r.text, e - r.from, !1) + r.from, to: r = e == r.to ? e + 1 : O(r.text, e - r.from, !0) + r.from, insert: n.doc.slice(e, r).append(n.doc.slice(i, e)) }, range: g.cursor(r) } : { range: t } })).changes.empty && (t(n.update(e, { scrollIntoView: !0, userEvent: "move.character" })), !0) } }, { key: "Ctrl-v", run: aa }].map(t => ({ mac: t.key, run: t.run, shift: t.shift })))), _h = { key: "Tab", run: Vh, shift: Mh }; function X(t, e) { var i, r = t, n = ("string" == typeof r && (r = document.createElement(r)), 1), s = e; if (s && "object" == typeof s && null == s.nodeType && !Array.isArray(s)) { for (var o in s) Object.prototype.hasOwnProperty.call(s, o) && ("string" == typeof (i = s[o]) ? r.setAttribute(o, i) : null != i && (r[o] = i)); n++ } for (; n < arguments.length; n++)!function t(e, i) { if ("string" == typeof i) e.appendChild(document.createTextNode(i)); else if (null != i) if (null != i.nodeType) e.appendChild(i); else { if (!Array.isArray(i)) throw new RangeError("Unsupported child node: " + i); for (var r = 0; r < i.length; r++)t(e, i[r]) } }(r, arguments[n]); return r } var jh = "function" == typeof String.prototype.normalize ? t => t.normalize("NFKD") : t => t, Eh = class { constructor(t, e, i = 0, r = t.length, n, s) { this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = t.iterRange(i, r), this.bufferStart = i, this.normalize = n ? t => n(jh(t)) : jh, this.query = this.normalize(e) } peek() { if (this.bufferPos == this.buffer.length) { if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done) return -1; this.bufferPos = 0, this.buffer = this.iter.value } return Q(this.buffer, this.bufferPos) } next() { for (; this.matches.length;)this.matches.pop(); return this.nextOverlapping() } nextOverlapping() { for (; ;) { var t = this.peek(); if (t < 0) return this.done = !0, this; var i = J(t), r = this.bufferStart + this.bufferPos, n = (this.bufferPos += K(t), this.normalize(i)); for (let t = 0, e = r; ; t++) { var s = n.charCodeAt(t), o = this.match(s, e); if (t == n.length - 1) { if (o) return this.value = o, this; break } e == r && t < i.length && i.charCodeAt(t) == s && e++ } } } match(r, n) { let s = null; for (let i = 0; i < this.matches.length; i += 2) { let t = this.matches[i], e = !1; this.query.charCodeAt(t) == r && (t == this.query.length - 1 ? s = { from: this.matches[i + 1], to: n + 1 } : (this.matches[i]++, e = !0)), e || (this.matches.splice(i, 2), i -= 2) } return this.query.charCodeAt(0) == r && (1 == this.query.length ? s = { from: n, to: n + 1 } : this.matches.push(1, n)), s = s && this.test && !this.test(s.from, s.to, this.buffer, this.bufferStart) ? null : s } }, Dh = ("undefined" != typeof Symbol && (Eh.prototype[Symbol.iterator] = function() { return this }), { from: -1, to: -1, match: /.*/.exec("") }), zh = "gm" + (null == /x/.unicode ? "" : "u"), Bh = class { constructor(t, e, i, r = 0, n = t.length) { if (this.text = t, this.to = n, this.curLine = "", this.done = !1, this.value = Dh, /\\[sWDnr]|\n|\r|\[\^/.test(e)) return new Nh(t, e, i, r, n); this.re = new RegExp(e, zh + (null != i && i.ignoreCase ? "i" : "")), this.test = null == i ? void 0 : i.test, this.iter = t.iter(); n = t.lineAt(r); this.curLineStart = n.from, this.matchPos = Uh(t, r), this.getLine(this.curLineStart) } getLine(t) { this.iter.next(t), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next()) } nextLine() { this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0) } next() { for (let t = this.matchPos - this.curLineStart; ;) { this.re.lastIndex = t; var e = this.matchPos <= this.to && this.re.exec(this.curLine); if (e) { var i = this.curLineStart + e.index, r = i + e[0].length; if (this.matchPos = Uh(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, e))) return this.value = { from: i, to: r, match: e }, this; t = this.matchPos - this.curLineStart } else { if (!(this.curLineStart + this.curLine.length < this.to)) return this.done = !0, this; this.nextLine(), t = 0 } } } }, Gh = new WeakMap, Ih = class xp { constructor(t, e) { this.from = t, this.text = e } get to() { return this.from + this.text.length } static get(t, e, i) { var r, n = Gh.get(t); if (!n || n.from >= i || n.to <= e) return r = new xp(e, t.sliceString(e, i)), Gh.set(t, r), r; if (n.from == e && n.to == i) return n; let { text: s, from: o } = n; return o > e && (s = t.sliceString(e, o) + s, o = e), n.to < i && (s += t.sliceString(n.to, i)), Gh.set(t, new xp(o, s)), new xp(e, s.slice(e - o, i - o)) } }, Nh = class { constructor(t, e, i, r, n) { this.text = t, this.to = n, this.done = !1, this.value = Dh, this.matchPos = Uh(t, r), this.re = new RegExp(e, zh + (null != i && i.ignoreCase ? "i" : "")), this.test = null == i ? void 0 : i.test, this.flat = Ih.get(t, r, this.chunkEnd(r + 5e3)) } chunkEnd(t) { return (t >= this.to ? this : this.text.lineAt(t)).to } next() { for (; ;) { var e = this.re.lastIndex = this.matchPos - this.flat.from; let t = this.re.exec(this.flat.text); if (t && !t[0] && t.index == e && (this.re.lastIndex = 1 + e, t = this.re.exec(this.flat.text)), t) { var e = this.flat.from + t.index, i = e + t[0].length; if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(e, i, t))) return this.value = { from: e, to: i, match: t }, this.matchPos = Uh(this.text, i + (e == i ? 1 : 0)), this } if (this.flat.to == this.to) return this.done = !0, this; this.flat = Ih.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + 2 * this.flat.text.length)) } } }; function Uh(i, r) { if (!(r >= i.length)) { let t = i.lineAt(r), e; for (; r < t.to && 56320 <= (e = t.text.charCodeAt(r - t.from)) && e < 57344;)r++ } return r } function Lh(a) { let e = X("input", { class: "cm-textfield", name: "line", value: String(a.state.doc.lineAt(a.state.selection.main.head).number) }); function i() { var i = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value); if (i) { var r = a.state, n = r.doc.lineAt(r.selection.main.head), [, i, t, s, o] = i, s = s ? +s.slice(1) : 0; let e = t ? +t : n.number; if (t && o) { let t = e / 100; i && (t = t * ("-" == i ? -1 : 1) + n.number / r.doc.lines), e = Math.round(r.doc.lines * t) } else t && i && (e = e * ("-" == i ? -1 : 1) + n.number); o = r.doc.line(Math.max(1, Math.min(r.doc.lines, e))), t = g.cursor(o.from + Math.max(0, Math.min(s, o.length))); a.dispatch({ effects: [Fh.of(!1), $.scrollIntoView(t.from, { y: "center" })], selection: t }), a.focus() } } return { dom: X("form", { class: "cm-gotoLine", onkeydown: t => { 27 == t.keyCode ? (t.preventDefault(), a.dispatch({ effects: Fh.of(!1) }), a.focus()) : 13 == t.keyCode && (t.preventDefault(), i()) }, onsubmit: t => { t.preventDefault(), i() } }, X("label", a.state.phrase("Go to line"), ": ", e), " ", X("button", { class: "cm-button", type: "submit" }, a.state.phrase("go"))) } } "undefined" != typeof Symbol && (Bh.prototype[Symbol.iterator] = Nh.prototype[Symbol.iterator] = function() { return this }); var Fh = c.define(), Hh = f.define({ create() { return !0 }, update(t, e) { for (var i of e.effects) i.is(Fh) && (t = i.value); return t }, provide: t => Ns.from(t, t => t ? Lh : null) }), Jh = $.baseTheme({ ".cm-panel.cm-gotoLine": { padding: "2px 6px 4px", "& label": { fontSize: "80%" } } }), Kh = { highlightWordAroundCursor: !1, minSelectionLength: 1, maxMatches: 100, wholeWords: !1 }, tc = d.define({ combine(t) { return Bt(t, Kh, { highlightWordAroundCursor: (t, e) => t || e, minSelectionLength: Math.min, maxMatches: Math.min }) } }); var ec = S.mark({ class: "cm-selectionMatch" }), ic = S.mark({ class: "cm-selectionMatch cm-selectionMatch-main" }); function rc(t, e, i, r) { return !(0 != i && t(e.sliceDoc(i - 1, i)) == p.Word || r != e.doc.length && t(e.sliceDoc(r, r + 1)) == p.Word) } var nc = a.fromClass(class { constructor(t) { this.decorations = this.getDeco(t) } update(t) { (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view)) } getDeco(t) { var e, i, r, n = t.state.facet(tc), s = t.state, o = s.selection; if (1 < o.ranges.length) return S.none; let a = o.main, l, h = null; if (a.empty) { if (!n.highlightWordAroundCursor) return S.none; var o = s.wordAt(a.head); if (!o) return S.none; h = s.charCategorizer(a.head), l = s.sliceDoc(o.from, o.to) } else { o = a.to - a.from; if (o < n.minSelectionLength || 200 < o) return S.none; if (n.wholeWords) { if (l = s.sliceDoc(a.from, a.to), !rc(h = s.charCategorizer(a.head), s, a.from, a.to) || (o = h, e = s, i = a.from, r = a.to, o(e.sliceDoc(i, i + 1)) != p.Word) || o(e.sliceDoc(r - 1, r)) != p.Word) return S.none } else if (!(l = s.sliceDoc(a.from, a.to).trim())) return S.none } var c, d = []; for (c of t.visibleRanges) for (var O = new Eh(s.doc, l, c.from, c.to); !O.next().done;) { var { from: u, to: f } = O.value; if ((!h || rc(h, s, u, f)) && (a.empty && u <= a.from && f >= a.to ? d.push(ic.range(u, f)) : (u >= a.to || f <= a.from) && d.push(ec.range(u, f)), d.length > n.maxMatches)) return S.none } return S.set(d) } }, { decorations: t => t.decorations }), sc = $.baseTheme({ ".cm-selectionMatch": { backgroundColor: "#99ff7780" }, ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" } }); var oc = d.define({ combine(t) { return Bt(t, { top: !1, caseSensitive: !1, literal: !1, regexp: !1, wholeWord: !1, createPanel: t => new Rc(t), scrollToMatch: t => $.scrollIntoView(t) }) } }), ac = class { constructor(t) { this.search = t.search, this.caseSensitive = !!t.caseSensitive, this.literal = !!t.literal, this.regexp = !!t.regexp, this.replace = t.replace || "", this.valid = !!this.search && (!this.regexp || (t => { try { return new RegExp(t, zh), !0 } catch (t) { return !1 } })(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!t.wholeWord } unquote(t) { return this.literal ? t : t.replace(/\\([nrt\\])/g, (t, e) => "n" == e ? "\n" : "r" == e ? "\r" : "t" == e ? "\t" : "\\") } eq(t) { return this.search == t.search && this.replace == t.replace && this.caseSensitive == t.caseSensitive && this.regexp == t.regexp && this.wholeWord == t.wholeWord } create() { return new (this.regexp ? uc : hc)(this) } getCursor(t, e = 0, i) { t = t.doc ? t : v.create({ doc: t }); return null == i && (i = t.doc.length), (this.regexp ? cc : lc)(this, t, e, i) } }, Be = class { constructor(t) { this.spec = t } }; function lc(t, e, i, r) { return new Eh(e.doc, t.unquoted, i, r, t.caseSensitive ? void 0 : t => t.toLowerCase(), t.wholeWord ? (n = e.doc, s = e.charCategorizer(e.selection.main.head), (t, e, i, r) => ((t < r || r + i.length < e) && (r = Math.max(0, t - 2), i = n.sliceString(r, Math.min(n.length, e + 2))), !(s(dc(i, t - r)) == p.Word && s(Oc(i, t - r)) == p.Word || s(Oc(i, e - r)) == p.Word && s(dc(i, e - r)) == p.Word))) : void 0); var n, s } var hc = class extends Be { constructor(t) { super(t) } nextMatch(t, e, i) { let r = lc(this.spec, t, i, t.doc.length).nextOverlapping(); return (r = r.done ? lc(this.spec, t, 0, e).nextOverlapping() : r).done ? null : r.value } prevMatchInRange(r, n, t) { for (let i = t; ;) { var s = Math.max(n, i - 1e4 - this.spec.unquoted.length); let t = lc(this.spec, r, s, i), e = null; for (; !t.nextOverlapping().done;)e = t.value; if (e) return e; if (s == n) return null; i -= 1e4 } } prevMatch(t, e, i) { return this.prevMatchInRange(t, 0, e) || this.prevMatchInRange(t, i, t.doc.length) } getReplacement(t) { return this.spec.unquote(this.spec.replace) } matchAll(t, e) { for (var i = lc(this.spec, t, 0, t.doc.length), r = []; !i.next().done;) { if (e <= r.length) return null; r.push(i.value) } return r } highlight(t, e, i, r) { for (var n = lc(this.spec, t, Math.max(0, e - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, t.doc.length)); !n.next().done;)r(n.value.from, n.value.to) } }; function cc(t, e, i, r) { return new Bh(e.doc, t.search, { ignoreCase: !t.caseSensitive, test: t.wholeWord ? (n = e.charCategorizer(e.selection.main.head), (t, e, i) => !i[0].length || (n(dc(i.input, i.index)) != p.Word || n(Oc(i.input, i.index)) != p.Word) && (n(Oc(i.input, i.index + i[0].length)) != p.Word || n(dc(i.input, i.index + i[0].length)) != p.Word)) : void 0 }, i, r); var n } function dc(t, e) { return t.slice(O(t, e, !1), e) } function Oc(t, e) { return t.slice(e, O(t, e)) } var uc = class extends Be { nextMatch(t, e, i) { let r = cc(this.spec, t, i, t.doc.length).next(); return (r = r.done ? cc(this.spec, t, 0, e).next() : r).done ? null : r.value } prevMatchInRange(r, n, s) { for (let i = 1; ; i++) { var o = Math.max(n, s - 1e4 * i); let t = cc(this.spec, r, o, s), e = null; for (; !t.next().done;)e = t.value; if (e && (o == n || e.from > o + 10)) return e; if (o == n) return null } } prevMatch(t, e, i) { return this.prevMatchInRange(t, 0, e) || this.prevMatchInRange(t, i, t.doc.length) } getReplacement(i) { return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (t, e) => "$" == e ? "$" : "&" == e ? i.match[0] : "0" != e && +e < i.match.length ? i.match[e] : t) } matchAll(t, e) { for (var i = cc(this.spec, t, 0, t.doc.length), r = []; !i.next().done;) { if (e <= r.length) return null; r.push(i.value) } return r } highlight(t, e, i, r) { for (var n = cc(this.spec, t, Math.max(0, e - 250), Math.min(i + 250, t.doc.length)); !n.next().done;)r(n.value.from, n.value.to) } }, fc = c.define(), pc = c.define(), mc = f.define({ create(t) { return new gc(Pc(t).create(), null) }, update(t, e) { for (var i of e.effects) i.is(fc) ? t = new gc(i.value.create(), t.panel) : i.is(pc) && (t = new gc(t.query, i.value ? $c : null)); return t }, provide: t => Ns.from(t, t => t.panel) }), gc = class { constructor(t, e) { this.query = t, this.panel = e } }, vc = S.mark({ class: "cm-searchMatch" }), wc = S.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), ha = a.fromClass(class { constructor(t) { this.view = t, this.decorations = this.highlight(t.state.field(mc)) } update(t) { var e = t.state.field(mc); (e != t.startState.field(mc) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e)) } highlight({ query: s, panel: t }) { if (!t || !s.spec.valid) return S.none; let o = this.view, a = new Lt; for (let i = 0, r = o.visibleRanges, n = r.length; i < n; i++) { let { from: t, to: e } = r[i]; for (; i < n - 1 && e > r[i + 1].from - 500;)e = r[++i].to; s.highlight(o.state, t, e, (e, i) => { var t = o.state.selection.ranges.some(t => t.from == e && t.to == i); a.add(e, i, t ? wc : vc) }) } return a.finish() } }, { decorations: t => t.decorations }); function bc(i) { return t => { var e = t.state.field(mc, !1); return e && e.query.spec.valid ? i(t, e) : Cc(t) } } var yc = bc((t, { query: e }) => { var i, r = t.state.selection.main.to, e = e.nextMatch(t.state, r, r); return !!e && (r = g.single(e.from, e.to), i = t.state.facet(oc), t.dispatch({ selection: r, effects: [Mc(t, e), i.scrollToMatch(r.main, t)], userEvent: "select.search" }), Tc(t), !0) }), Sc = bc((t, { query: e }) => { var i = t.state, r = i.selection.main.from, e = e.prevMatch(i, r, r); return !!e && (i = g.single(e.from, e.to), r = t.state.facet(oc), t.dispatch({ selection: i, effects: [Mc(t, e), r.scrollToMatch(i.main, t)], userEvent: "select.search" }), Tc(t), !0) }), Qc = bc((t, { query: e }) => { e = e.matchAll(t.state, 1e3); return !(!e || !e.length || (t.dispatch({ selection: g.create(e.map(t => g.range(t.from, t.to))), userEvent: "select.search.matches" }), 0)) }), xc = bc((t, { query: e }) => { var i = t.state, { from: r, to: n } = i.selection.main; if (i.readOnly) return !1; let s = e.nextMatch(i, r, r); if (!s) return !1; let o = [], a, l; var h = []; return s.from == r && s.to == n && (l = i.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: l }), s = e.nextMatch(i, s.from, s.to), h.push($.announce.of(i.phrase("replaced match on line $", i.doc.lineAt(r).number) + "."))), s && (n = 0 == o.length || o[0].from >= s.to ? 0 : s.to - s.from - l.length, a = g.single(s.from - n, s.to - n), h.push(Mc(t, s)), h.push(i.facet(oc).scrollToMatch(a.main, t))), t.dispatch({ changes: o, selection: a, effects: h, userEvent: "input.replace" }), !0 }), kc = bc((t, { query: r }) => { var e, i; return !t.state.readOnly && !!(e = r.matchAll(t.state, 1e9).map(t => { var { from: e, to: i } = t; return { from: e, to: i, insert: r.getReplacement(t) } })).length && (i = t.state.phrase("replaced $ matches", e.length) + ".", t.dispatch({ changes: e, effects: $.announce.of(i), userEvent: "input.replace.all" }), !0) }); function $c(t) { return t.state.facet(oc).createPanel(t) } function Pc(t, e) { var i, r = t.selection.main, r = r.empty || r.to > r.from + 100 ? "" : t.sliceDoc(r.from, r.to); return e && !r ? e : (t = t.facet(oc), new ac({ search: (null != (i = null == e ? void 0 : e.literal) ? i : t.literal) ? r : r.replace(/\n/g, "\\n"), caseSensitive: null != (i = null == e ? void 0 : e.caseSensitive) ? i : t.caseSensitive, literal: null != (r = null == e ? void 0 : e.literal) ? r : t.literal, regexp: null != (i = null == e ? void 0 : e.regexp) ? i : t.regexp, wholeWord: null != (r = null == e ? void 0 : e.wholeWord) ? r : t.wholeWord })) } function Zc(t) { t = zs(t, $c); return t && t.dom.querySelector("[main-field]") } function Tc(t) { var e = Zc(t); e && e == t.root.activeElement && e.select() } var Cc = t => { var e, i, r = t.state.field(mc, !1); return r && r.panel ? (e = Zc(t)) && e != t.root.activeElement && ((i = Pc(t.state, r.query.spec)).valid && t.dispatch({ effects: fc.of(i) }), e.focus(), e.select()) : t.dispatch({ effects: [pc.of(!0), r ? fc.of(Pc(t.state, r.query.spec)) : c.appendConfig.of(qc)] }), !0 }, Xc = t => { var e = t.state.field(mc, !1); return !(!e || !e.panel || ((e = zs(t, $c)) && e.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: pc.of(!1) }), 0)) }, Ac = [{ key: "Mod-f", run: Cc, scope: "editor search-panel" }, { key: "F3", run: yc, shift: Sc, scope: "editor search-panel", preventDefault: !0 }, { key: "Mod-g", run: yc, shift: Sc, scope: "editor search-panel", preventDefault: !0 }, { key: "Escape", run: Xc, scope: "editor search-panel" }, { key: "Mod-Shift-l", run: ({ state: t, dispatch: e }) => { var i = t.selection; if (1 < i.ranges.length || i.main.empty) return !1; var { from: r, to: i } = i.main; let n = [], s = 0; for (var o = new Eh(t.doc, t.sliceDoc(r, i)); !o.next().done;) { if (1e3 < n.length) return !1; o.value.from == r && (s = n.length), n.push(g.range(o.value.from, o.value.to)) } return e(t.update({ selection: g.create(n, s), userEvent: "select.search.matches" })), !0 } }, { key: "Mod-Alt-g", run: t => { let e = zs(t, Lh); var i; return e || (i = [Fh.of(!0)], null == t.state.field(Hh, !1) && i.push(c.appendConfig.of([Hh, Jh])), t.dispatch({ effects: i }), e = zs(t, Lh)), e && e.dom.querySelector("input").select(), !0 } }, { key: "Mod-d", run: ({ state: e, dispatch: t }) => { var i, r, n, s, o = e.selection.ranges; if (o.some(t => t.from === t.to)) return { state: i, dispatch: r } = [{ state: e, dispatch: t }][0], s = i.selection, !(n = g.create(s.ranges.map(t => i.wordAt(t.head) || g.cursor(t.head)), s.mainIndex)).eq(s) && (r(i.update({ selection: n })), !0); let a = e.sliceDoc(o[0].from, o[0].to); return !e.selection.ranges.some(t => e.sliceDoc(t.from, t.to) != a) && !!(s = ((i, r) => { var { main: t, ranges: n } = i.selection, e = i.wordAt(t.head), s = e && e.from == t.from && e.to == t.to; for (let t = !1, e = new Eh(i.doc, r, n[n.length - 1].to); ;)if (e.next(), e.done) { if (t) return null; e = new Eh(i.doc, r, 0, Math.max(0, n[n.length - 1].from - 1)), t = !0 } else if (!t || !n.some(t => t.from == e.value.from)) { if (s) { var o = i.wordAt(e.value.from); if (!o || o.from != e.value.from || o.to != e.value.to) continue } return e.value } })(e, a)) && (t(e.update({ selection: e.selection.addRange(g.range(s.from, s.to), !1), effects: $.scrollIntoView(s.to) })), !0) }, preventDefault: !0 }], Rc = class { constructor(t) { this.view = t; var e = this.query = t.state.field(mc).query.spec; function i(t, e, i) { return X("button", { class: "cm-button", name: t, onclick: e, type: "button" }, i) } this.commit = this.commit.bind(this), this.searchField = X("input", { value: e.search, placeholder: Yc(t, "Find"), "aria-label": Yc(t, "Find"), class: "cm-textfield", name: "search", form: "", "main-field": "true", onchange: this.commit, onkeyup: this.commit }), this.replaceField = X("input", { value: e.replace, placeholder: Yc(t, "Replace"), "aria-label": Yc(t, "Replace"), class: "cm-textfield", name: "replace", form: "", onchange: this.commit, onkeyup: this.commit }), this.caseField = X("input", { type: "checkbox", name: "case", form: "", checked: e.caseSensitive, onchange: this.commit }), this.reField = X("input", { type: "checkbox", name: "re", form: "", checked: e.regexp, onchange: this.commit }), this.wordField = X("input", { type: "checkbox", name: "word", form: "", checked: e.wholeWord, onchange: this.commit }), this.dom = X("div", { onkeydown: t => this.keydown(t), class: "cm-search" }, [this.searchField, i("next", () => yc(t), [Yc(t, "next")]), i("prev", () => Sc(t), [Yc(t, "previous")]), i("select", () => Qc(t), [Yc(t, "all")]), X("label", null, [this.caseField, Yc(t, "match case")]), X("label", null, [this.reField, Yc(t, "regexp")]), X("label", null, [this.wordField, Yc(t, "by word")]), ...t.state.readOnly ? [] : [X("br"), this.replaceField, i("replace", () => xc(t), [Yc(t, "replace")]), i("replaceAll", () => kc(t), [Yc(t, "replace all")])], X("button", { name: "close", onclick: () => Xc(t), "aria-label": Yc(t, "close"), type: "button" }, ["Ã—"])]) } commit() { var t = new ac({ search: this.searchField.value, caseSensitive: this.caseField.checked, regexp: this.reField.checked, wholeWord: this.wordField.checked, replace: this.replaceField.value }); t.eq(this.query) || (this.query = t, this.view.dispatch({ effects: fc.of(t) })) } keydown(t) { var e, i, r; e = this.view, i = t, r = "search-panel", Gn(Dn(e.state), i, e, r) ? t.preventDefault() : 13 == t.keyCode && t.target == this.searchField ? (t.preventDefault(), (t.shiftKey ? Sc : yc)(this.view)) : 13 == t.keyCode && t.target == this.replaceField && (t.preventDefault(), xc(this.view)) } update(t) { for (var e of t.transactions) for (var i of e.effects) i.is(fc) && !i.value.eq(this.query) && this.setQuery(i.value) } setQuery(t) { this.query = t, this.searchField.value = t.search, this.replaceField.value = t.replace, this.caseField.checked = t.caseSensitive, this.reField.checked = t.regexp, this.wordField.checked = t.wholeWord } mount() { this.searchField.select() } get pos() { return 80 } get top() { return this.view.state.facet(oc).top } }; function Yc(t, e) { return t.state.phrase(e) } var Wc = 30, Vc = /[\s\.,:;?!]/; function Mc(t, { from: e, to: i }) { var r = t.state.doc.lineAt(e), n = t.state.doc.lineAt(i).to, e = Math.max(r.from, e - Wc), i = Math.min(n, i + Wc); let s = t.state.sliceDoc(e, i); if (e != r.from) for (let t = 0; t < Wc; t++)if (!Vc.test(s[t + 1]) && Vc.test(s[t])) { s = s.slice(t); break } if (i != n) for (let t = s.length - 1; t > s.length - Wc; t--)if (!Vc.test(s[t - 1]) && Vc.test(s[t])) { s = s.slice(0, t); break } return $.announce.of(`${t.state.phrase("current match")}. ${s} ${t.state.phrase("on line")} ${r.number}.`) } var Ue = $.baseTheme({ ".cm-panel.cm-search": { padding: "2px 6px 4px", position: "relative", "& [name=close]": { position: "absolute", top: "0", right: "4px", backgroundColor: "inherit", border: "none", font: "inherit", padding: 0, margin: 0 }, "& input, & button, & label": { margin: ".2em .6em .2em 0" }, "& input[type=checkbox]": { marginRight: ".2em" }, "& label": { fontSize: "80%", whiteSpace: "pre" } }, "&light .cm-searchMatch": { backgroundColor: "#ffff0054" }, "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" }, "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" }, "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" } }), qc = [mc, vt.low(ha), Ue], _c = class { constructor(t, e, i) { this.state = t, this.pos = e, this.explicit = i, this.abortListeners = [] } tokenBefore(t) { let e = T(this.state).resolveInner(this.pos, -1); for (; e && t.indexOf(e.name) < 0;)e = e.parent; return e ? { from: e.from, to: this.pos, text: this.state.sliceDoc(e.from, this.pos), type: e.type } : null } matchBefore(t) { var e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), e = e.text.slice(i - e.from, this.pos - e.from), t = e.search(Bc(t, !1)); return t < 0 ? null : { from: i + t, to: this.pos, text: e.slice(t) } } get aborted() { return null == this.abortListeners } addEventListener(t, e) { "abort" == t && this.abortListeners && this.abortListeners.push(e) } }; function jc(t) { let e = Object.keys(t).join(""); t = /\w/.test(e); return `[${t ? "\\w" : ""}${(e = t ? e.replace(/\w/g, "") : e).replace(/[^\w\s]/g, "\\$&")}]` } function Ec(t) { let i = t.map(t => "string" == typeof t ? { label: t } : t), [r, n] = i.every(t => /^\w+$/.test(t.label)) ? [/\w*$/, /\w+$/] : (t => { var e, i = Object.create(null), r = Object.create(null); for ({ label: e } of t) { i[e[0]] = !0; for (let t = 1; t < e.length; t++)r[e[t]] = !0 } return t = jc(i) + jc(r) + "*$", [new RegExp("^" + t), new RegExp(t)] })(i); return t => { var e = t.matchBefore(n); return e || t.explicit ? { from: e ? e.from : t.pos, options: i, validFor: r } : null } } var Dc = class { constructor(t, e, i, r) { this.completion = t, this.source = e, this.match = i, this.score = r } }; function zc(t) { return t.selection.main.from } function Bc(t, e) { var i = t.source, e = e && "^" != i[0], r = "$" != i[i.length - 1]; return e || r ? new RegExp(`${e ? "^" : ""}(?:${i})` + (r ? "$" : ""), null != (e = t.flags) ? e : t.ignoreCase ? "i" : "") : t } var Gc = At.define(); var Ic = new WeakMap; function Nc(t) { if (!Array.isArray(t)) return t; let e = Ic.get(t); return e || Ic.set(t, e = Ec(t)), e } var Uc = c.define(), Lc = c.define(), Fc = class { constructor(e) { this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = []; for (let t = 0; t < e.length;) { var i = Q(e, t), r = K(i), i = (this.chars.push(i), e.slice(t, t + r)), n = i.toUpperCase(); this.folded.push(Q(n == i ? i.toLowerCase() : n, 0)), t += r } this.astral = e.length != this.chars.length } ret(t, e) { return this.score = t, this.matched = e, !0 } match(r) { if (0 == this.pattern.length) return this.ret(-100, []); if (r.length < this.pattern.length) return !1; var { chars: n, folded: s, any: i, precise: o, byWord: a } = this; if (1 == n.length) { var e = Q(r, 0), l = K(e); let t = l == r.length ? 0 : -100; if (e != n[0]) { if (e != s[0]) return !1; t += -200 } return this.ret(t, [0, l]) } var h = r.indexOf(this.pattern); if (0 == h) return this.ret(r.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]); let c = n.length, d = 0; if (h < 0) { for (let t = 0, e = Math.min(r.length, 200); t < e && d < c;) { var O = Q(r, t); O != n[d] && O != s[d] || (i[d++] = t), t += K(O) } if (d < c) return !1 } let u = 0, f = 0, p = !1, m = 0, g = -1, v = -1, w = /[a-z]/.test(r), b = !0; for (let t = 0, e = Math.min(r.length, 200), i = 0; t < e && f < c;) { var y = Q(r, t); h < 0 && (u < c && y == n[u] && (o[u++] = t), m < c) && (y == n[m] || y == s[m] ? (0 == m && (g = t), v = t + 1, m++) : m = 0); var S = y < 255 ? 48 <= y && y <= 57 || 97 <= y && y <= 122 ? 2 : 65 <= y && y <= 90 ? 1 : 0 : (S = J(y)) != S.toLowerCase() ? 1 : S != S.toUpperCase() ? 2 : 0; (!t || 1 == S && w || 0 == i && 0 != S) && (n[f] == y || s[f] == y && (p = !0) ? a[f++] = t : a.length && (b = !1)), i = S, t += K(y) } return f == c && 0 == a[0] && b ? this.result((p ? -200 : 0) - 100, a, r) : m == c && 0 == g ? this.ret(-200 - r.length + (v == r.length ? 0 : -100), [0, v]) : -1 < h ? this.ret(-700 - r.length, [h, h + this.pattern.length]) : m == c ? this.ret(-900 - r.length, [g, v]) : f == c ? this.result((p ? -200 : 0) - 100 - 700 + (b ? 0 : -1100), a, r) : 2 != n.length && this.result((i[0] ? -700 : 0) - 200 - 1100, i, r) } result(t, e, i) { let r = [], n = 0; for (var s of e) { var o = s + (this.astral ? K(Q(i, s)) : 1); n && r[n - 1] == s ? r[n - 1] = o : (r[n++] = s, r[n++] = o) } return this.ret(t - i.length, r) } }, A = d.define({ combine(t) { return Bt(t, { activateOnTyping: !0, selectOnOpen: !0, override: null, closeOnBlur: !0, maxRenderedOptions: 100, defaultKeymap: !0, tooltipClass: () => "", optionClass: () => "", aboveCursor: !1, icons: !0, addToOptions: [], positionInfo: Jc, compareCompletions: (t, e) => t.label.localeCompare(e.label), interactionDelay: 75, updateSyncTime: 100 }, { defaultKeymap: (t, e) => t && e, closeOnBlur: (t, e) => t && e, icons: (t, e) => t && e, tooltipClass: (e, i) => t => Hc(e(t), i(t)), optionClass: (e, i) => t => Hc(e(t), i(t)), addToOptions: (t, e) => t.concat(e) }) } }); function Hc(t, e) { return t ? e ? t + " " + e : t : e } function Jc(t, e, i, r, n, s) { let o = t.textDirection == k.RTL, a = o, l = !1, h = "top", c, d; var t = e.left - n.left, O = n.right - e.right, u = r.right - r.left, r = r.bottom - r.top, t = (a && t < Math.min(u, O) ? a = !1 : !a && O < Math.min(u, t) && (a = !0), u <= (a ? t : O) ? (c = Math.max(n.top, Math.min(i.top, n.bottom - r)) - e.top, d = Math.min(400, a ? t : O)) : (l = !0, d = Math.min(400, (o ? e.right : n.right - e.left) - 30), u = n.bottom - e.bottom, c = r <= u || u > e.top ? i.bottom - e.top : (h = "bottom", e.bottom - i.top)), (e.bottom - e.top) / s.offsetHeight); return { style: `${h}: ${c / t}px; max-width: ${d / ((e.right - e.left) / s.offsetWidth)}px`, class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right") } } function Kc(t, e, i) { var r; return t <= i ? { from: 0, to: t } : (e = e < 0 ? 0 : e) <= t >> 1 ? { from: (r = Math.floor(e / i)) * i, to: (r + 1) * i } : { from: t - ((r = Math.floor((t - e) / i)) + 1) * i, to: t - r * i } } var td = class { constructor(n, t, e) { this.view = n, this.stateField = t, this.applyCompletion = e, this.info = null, this.infoDestroy = null, this.placeInfoReq = { read: () => this.measureInfo(), write: t => this.placeInfo(t), key: this }, this.space = null, this.currentClass = ""; var i, r, e = n.state.field(t), { options: s, selected: o } = e.open, a = n.state.facet(A); this.optionContent = (r = (i = a).addToOptions.slice(), i.icons && r.push({ render(t) { var e = document.createElement("div"); return e.classList.add("cm-completionIcon"), t.type && e.classList.add(...t.type.split(/\s+/g).map(t => "cm-completionIcon-" + t)), e.setAttribute("aria-hidden", "true"), e }, position: 20 }), r.push({ render(t, e, i, r) { var n = document.createElement("span"); n.className = "cm-completionLabel"; let s = t.displayLabel || t.label, o = 0; for (let t = 0; t < r.length;) { var a = r[t++], l = r[t++], h = (a > o && n.appendChild(document.createTextNode(s.slice(o, a))), n.appendChild(document.createElement("span"))); h.appendChild(document.createTextNode(s.slice(a, l))), h.className = "cm-completionMatchedText", o = l } return o < s.length && n.appendChild(document.createTextNode(s.slice(o))), n }, position: 50 }, { render(t) { var e; return t.detail ? ((e = document.createElement("span")).className = "cm-completionDetail", e.textContent = t.detail, e) : null }, position: 80 }), r.sort((t, e) => t.position - e.position).map(t => t.render)), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Kc(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(n.state), this.dom.addEventListener("mousedown", i => { var r = n.state.field(t).open.options; for (let t = i.target, e; t && t != this.dom; t = t.parentNode)if ("LI" == t.nodeName && (e = /-(\d+)$/.exec(t.id)) && +e[1] < r.length) return this.applyCompletion(n, r[+e[1]]), void i.preventDefault() }), this.dom.addEventListener("focusout", t => { var e = n.state.field(this.stateField, !1); e && e.tooltip && n.state.facet(A).closeOnBlur && t.relatedTarget != n.contentDOM && n.dispatch({ effects: Lc.of(null) }) }), this.showOptions(s, e.id) } mount() { this.updateSel() } showOptions(t, e) { this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => { this.info && this.view.requestMeasure(this.placeInfoReq) }) } update(t) { var e, i, r, n = t.state.field(this.stateField), s = t.startState.field(this.stateField); this.updateTooltipClass(t.state), n != s && ({ options: e, selected: i, disabled: r } = n.open, s.open && s.open.options == e || (this.range = Kc(e.length, i, t.state.facet(A).maxRenderedOptions), this.showOptions(e, n.id)), this.updateSel(), r != (null == (i = s.open) ? void 0 : i.disabled)) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!r) } updateTooltipClass(t) { t = this.tooltipClass(t); if (t != this.currentClass) { for (var e of this.currentClass.split(" ")) e && this.dom.classList.remove(e); for (var i of t.split(" ")) i && this.dom.classList.add(i); this.currentClass = t } } positioned(t) { this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq) } updateSel() { let i = this.view.state.field(this.stateField), t = i.open; if ((-1 < t.selected && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Kc(t.options.length, t.selected, this.view.state.facet(A).maxRenderedOptions), this.showOptions(t.options, i.id)), this.updateSelectedOption(t.selected)) { this.destroyInfo(); let e = t.options[t.selected].completion; var r = e.info; r && (r = "string" == typeof r ? document.createTextNode(r) : r(e)) && ("then" in r ? r.then(t => { t && this.view.state.field(this.stateField, !1) == i && this.addInfoPane(t, e) }).catch(t => Bi(this.view.state, t, "completion info")) : this.addInfoPane(r, e)) } } addInfoPane(t, e) { this.destroyInfo(); var i, r = this.info = document.createElement("div"); r.className = "cm-tooltip cm-completionInfo", null != t.nodeType ? (r.appendChild(t), this.infoDestroy = null) : ({ dom: t, destroy: i } = t, r.appendChild(t), this.infoDestroy = i || null), this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq) } updateSelectedOption(i) { let r = null; for (let t = this.list.firstChild, e = this.range.from; t; t = t.nextSibling, e++)"LI" == t.nodeName && t.id ? e == i ? t.hasAttribute("aria-selected") || (t.setAttribute("aria-selected", "true"), r = t) : t.hasAttribute("aria-selected") && t.removeAttribute("aria-selected") : e--; var t, e, n, s; return r && (t = this.list, e = r, n = t.getBoundingClientRect(), e = e.getBoundingClientRect(), s = n.height / t.offsetHeight, e.top < n.top ? t.scrollTop -= (n.top - e.top) / s : e.bottom > n.bottom && (t.scrollTop += (e.bottom - n.bottom) / s)), r } measureInfo() { var t = this.dom.querySelector("[aria-selected]"); if (!t || !this.info) return null; var e, i = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), t = t.getBoundingClientRect(); let n = this.space; return n || (e = this.dom.ownerDocument.defaultView || window, n = { left: 0, top: 0, right: e.innerWidth, bottom: e.innerHeight }), t.top > Math.min(n.bottom, i.bottom) - 10 || t.bottom < Math.max(n.top, i.top) + 10 ? null : this.view.state.facet(A).positionInfo(this.view, i, t, r, n, this.dom) } placeInfo(t) { this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px") } createListBox(e, i, r) { var n = document.createElement("ul"); n.id = i, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions")); let s = null; for (let t = r.from; t < r.to; t++) { var o, a, { completion: l, match: h } = e[t], c = l.section, d = (c && (o = "string" == typeof c ? c : c.name) != s && (t > r.from || 0 == r.from) && (s = o, "string" != typeof c && c.header ? n.appendChild(c.header(c)) : n.appendChild(document.createElement("completion-section")).textContent = o), n.appendChild(document.createElement("li"))), c = (d.id = i + "-" + t, d.setAttribute("role", "option"), this.optionClass(l)); c && (d.className = c); for (a of this.optionContent) { var O = a(l, this.view.state, this.view, h); O && d.appendChild(O) } } return r.from && n.classList.add("cm-completionListIncompleteTop"), r.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n } destroyInfo() { this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null) } destroy() { this.destroyInfo() } }; function ed(e, i) { return t => new td(t, e, i) } function id(t) { return 100 * (t.boost || 0) + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0) } var rd = class kp { constructor(t, e, i, r, n, s) { this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = r, this.selected = n, this.disabled = s } setSelected(t, e) { return t == this.selected || t >= this.options.length ? this : new kp(this.options, od(e, t), this.tooltip, this.timestamp, t, this.disabled) } static build(t, e, i, r, n) { var s = ((t, e) => { let i = [], r = null; var n, s, o, a, l = t => { i.push(t); t = t.completion.section; if (t) { r = r || []; let e = "string" == typeof t ? t : t.name; r.some(t => t.name == e) || r.push("string" == typeof t ? { name: e } : t) } }; for (n of t) if (n.hasResult()) { var h = n.result.getMatch; if (!1 === n.result.filter) for (var c of n.result.options) l(new Dc(c, n.source, h ? h(c) : [], 1e9 - i.length)); else { var d, O, u = new Fc(e.sliceDoc(n.from, n.to)); for (d of n.result.options) u.match(d.label) && (O = d.displayLabel ? h ? h(d, u.matched) : [] : u.matched, l(new Dc(d, n.source, O, u.score + (d.boost || 0)))) } } if (r) { let t = Object.create(null), e = 0; for (o of r.sort((t, e) => { var i; return (null != (i = t.rank) ? i : 1e9) - (null != (i = e.rank) ? i : 1e9) || (t.name < e.name ? -1 : 1) })) e -= 1e5, t[o.name] = e; for (a of i) { var f = a.completion.section; f && (a.score += t["string" == typeof f ? f : f.name]) } } let p = [], m = null, g = e.facet(A).compareCompletions; for (s of i.sort((t, e) => e.score - t.score || g(t.completion, e.completion))) { var v = s.completion; !m || m.label != v.label || m.detail != v.detail || null != m.type && null != v.type && m.type != v.type || m.apply != v.apply || m.boost != v.boost ? p.push(s) : id(s.completion) > id(m) && (p[p.length - 1] = s), m = s.completion } return p })(t, e); if (!s.length) return r && t.some(t => 1 == t.state) ? new kp(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0) : null; let o = e.facet(A).selectOnOpen ? 0 : -1; if (r && r.selected != o && -1 != r.selected) { var a = r.options[r.selected].completion; for (let t = 0; t < s.length; t++)if (s[t].completion == a) { o = t; break } } return new kp(s, od(i, o), { pos: t.reduce((t, e) => e.hasResult() ? Math.min(t, e.from) : t, 1e8), create: pd, above: n.aboveCursor }, r ? r.timestamp : Date.now(), o, !1) } map(t) { return new kp(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled) } }, nd = class $p { constructor(t, e, i) { this.active = t, this.id = e, this.open = i } static start() { return new $p(ad, "cm-ac-" + Math.floor(2e6 * Math.random()).toString(36), null) } update(i) { let t = i.state, r = t.facet(A); var e; let n = (r.override || t.languageDataAt("autocomplete", zc(t)).map(Nc)).map(e => (this.active.find(t => t.source == e) || new hd(e, this.active.some(t => 0 != t.state) ? 1 : 0)).update(i, r)), s = (n.length == this.active.length && n.every((t, e) => t == this.active[e]) && (n = this.active), this.open); s && i.docChanged && (s = s.map(i.changes)), i.selection || n.some(t => t.hasResult() && i.changes.touchesRange(t.from, t.to)) || !((i, r) => { if (i == r) return 1; for (let t = 0, e = 0; ;) { for (; t < i.length && !i[t].hasResult;)t++; for (; e < r.length && !r[e].hasResult;)e++; var n = t == i.length, s = e == r.length; if (n || s) return n == s; if (i[t++].result != r[e++].result) return } })(n, this.active) ? s = rd.build(n, t, this.id, s, r) : s && s.disabled && !n.some(t => 1 == t.state) && (s = null), !s && n.every(t => 1 != t.state) && n.some(t => t.hasResult()) && (n = n.map(t => t.hasResult() ? new hd(t.source, 0) : t)); for (e of i.effects) e.is(Od) && (s = s && s.setSelected(e.value, this.id)); return n == this.active && s == this.open ? this : new $p(n, this.id, s) } get tooltip() { return this.open ? this.open.tooltip : null } get attrs() { return this.open ? this.open.attrs : sd } }; var sd = { "aria-autocomplete": "list" }; function od(t, e) { var i = { "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-controls": t }; return -1 < e && (i["aria-activedescendant"] = t + "-" + e), i } var ad = []; function ld(t) { return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null } var hd = class Pp { constructor(t, e, i = -1) { this.source = t, this.state = e, this.explicitPos = i } hasResult() { return !1 } update(t, e) { let i = ld(t), r = this; i ? r = r.handleUserEvent(t, i, e) : t.docChanged ? r = r.handleChange(t) : t.selection && 0 != r.state && (r = new Pp(r.source, 0)); for (var n of t.effects) if (n.is(Uc)) r = new Pp(r.source, 1, n.value ? zc(t.state) : -1); else if (n.is(Lc)) r = new Pp(r.source, 0); else if (n.is(dd)) for (var s of n.value) s.source == r.source && (r = s); return r } handleUserEvent(t, e, i) { return "delete" != e && i.activateOnTyping ? new Pp(this.source, 1) : this.map(t.changes) } handleChange(t) { return t.changes.touchesRange(zc(t.startState)) ? new Pp(this.source, 0) : this.map(t.changes) } map(t) { return t.empty || this.explicitPos < 0 ? this : new Pp(this.source, this.state, t.mapPos(this.explicitPos)) } }, cd = class Zp extends hd { constructor(t, e, i, r, n) { super(t, 2, e), this.result = i, this.from = r, this.to = n } hasResult() { return !0 } handleUserEvent(t, e, i) { var r = t.changes.mapPos(this.from), n = t.changes.mapPos(this.to, 1), s = zc(t.state); if ((this.explicitPos < 0 ? s <= r : s < this.from) || n < s || "delete" == e && zc(t.startState) == this.from) return new hd(this.source, "input" == e && i.activateOnTyping ? 1 : 0); let o = this.explicitPos < 0 ? -1 : t.changes.mapPos(this.explicitPos), a; return ((t, e, i, r) => { var n; if (t) return n = e.sliceDoc(i, r), "function" == typeof t ? t(n, i, r, e) : Bc(t, !0).test(n) })(this.result.validFor, t.state, r, n) ? new Zp(this.source, o, this.result, r, n) : this.result.update && (a = this.result.update(this.result, r, n, new _c(t.state, s, 0 <= o))) ? new Zp(this.source, o, a, a.from, null != (e = a.to) ? e : zc(t.state)) : new hd(this.source, 1, o) } handleChange(t) { return t.changes.touchesRange(this.from, this.to) ? new hd(this.source, 0) : this.map(t.changes) } map(t) { return t.empty ? this : new Zp(this.source, this.explicitPos < 0 ? -1 : t.mapPos(this.explicitPos), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) } }; var dd = c.define({ map(t, e) { return t.map(t => t.map(e)) } }), Od = c.define(), ud = f.define({ create() { return nd.start() }, update(t, e) { return t.update(e) }, provide: t => [Rs.from(t, t => t.tooltip), $.contentAttributes.from(t, t => t.attrs)] }); function fd(t, e) { var i = e.completion.apply || e.completion.label, r = t.state.field(ud).active.find(t => t.source == e.source); return r instanceof cd && ("string" == typeof i ? t.dispatch(Object.assign(Object.assign({}, ((e, i, r, n) => { let s = e.selection.main, o = r - s.from, a = n - s.from; return Object.assign(Object.assign({}, e.changeByRange(t => t != s && r != n && e.sliceDoc(t.from + o, t.from + a) != e.sliceDoc(r, n) ? { range: t } : { changes: { from: t.from + o, to: n == s.from ? t.to : t.from + a, insert: i }, range: g.cursor(t.from + o + i.length) })), { scrollIntoView: !0, userEvent: "input.complete" }) })(t.state, i, r.from, r.to)), { annotations: Gc.of(e.completion) })) : i(t, e.completion, r.from, r.to), !0) } var pd = ed(ud, fd); function md(o, a = "option") { return t => { var e = t.state.field(ud, !1); if (!e || !e.open || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(A).interactionDelay) return !1; let i = 1, r; "page" == a && (r = js(t, e.open.tooltip)) && (i = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1)); var n = e.open.options.length; let s = -1 < e.open.selected ? e.open.selected + i * (o ? 1 : -1) : o ? 0 : n - 1; return s < 0 ? s = "page" == a ? 0 : n - 1 : s >= n && (s = "page" == a ? n - 1 : 0), t.dispatch({ effects: Od.of(s) }), !0 } } var gd = class { constructor(t, e) { this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0 } }, vd = a.fromClass(class { constructor(t) { this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0; for (var e of t.state.field(ud).active) 1 == e.state && this.startQuery(e) } update(e) { var t = e.state.field(ud); if (e.selectionSet || e.docChanged || e.startState.field(ud) != t) { var i = e.transactions.some(t => (t.selection || t.docChanged) && !ld(t)); for (let t = 0; t < this.running.length; t++) { var r = this.running[t]; if (i || 50 < r.updates.length + e.transactions.length && 1e3 < Date.now() - r.time) { for (var n of r.context.abortListeners) try { n() } catch (t) { Bi(this.view.state, t) } r.context.abortListeners = null, this.running.splice(t--, 1) } else r.updates.push(...e.transactions) } if (-1 < this.debounceUpdate && clearTimeout(this.debounceUpdate), this.debounceUpdate = t.active.some(e => 1 == e.state && !this.running.some(t => t.active.source == e.source)) ? setTimeout(() => this.startUpdate(), 50) : -1, 0 != this.composing) for (var s of e.transactions) "input" == ld(s) ? this.composing = 2 : 2 == this.composing && s.selection && (this.composing = 3) } } startUpdate() { this.debounceUpdate = -1; var t = this.view.state; for (let e of t.field(ud).active) 1 != e.state || this.running.some(t => t.active.source == e.source) || this.startQuery(e) } startQuery(t) { var e = this.view.state, i = zc(e), e = new _c(e, i, t.explicitPos == i); let r = new gd(t, e); this.running.push(r), Promise.resolve(t.source(e)).then(t => { r.context.aborted || (r.done = t || null, this.scheduleAccept()) }, t => { this.view.dispatch({ effects: Lc.of(null) }), Bi(this.view.state, t) }) } scheduleAccept() { this.running.every(t => void 0 !== t.done) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(A).updateSyncTime)) } accept() { -1 < this.debounceAccept && clearTimeout(this.debounceAccept), this.debounceAccept = -1; var i = [], r = this.view.state.facet(A); for (let t = 0; t < this.running.length; t++) { let e = this.running[t]; if (void 0 !== e.done) { if (this.running.splice(t--, 1), e.done) { let t = new cd(e.active.source, e.active.explicitPos, e.done, e.done.from, null != (s = e.done.to) ? s : zc(e.updates.length ? e.updates[0].startState : this.view.state)); for (var n of e.updates) t = t.update(n, r); if (t.hasResult()) { i.push(t); continue } } var s = this.view.state.field(ud).active.find(t => t.source == e.active.source); if (s && 1 == s.state) if (null == e.done) { let t = new hd(e.active.source, 0); for (var o of e.updates) t = t.update(o, r); 1 != t.state && i.push(t) } else this.startQuery(s) } } i.length && this.view.dispatch({ effects: dd.of(i) }) } }, { eventHandlers: { blur(t) { var e = this.view.state.field(ud, !1); e && e.tooltip && this.view.state.facet(A).closeOnBlur && ((e = e.open && js(this.view, e.open.tooltip)) && e.dom.contains(t.relatedTarget) || this.view.dispatch({ effects: Lc.of(null) })) }, compositionstart() { this.composing = 1 }, compositionend() { 3 == this.composing && setTimeout(() => this.view.dispatch({ effects: Uc.of(!1) }), 20), this.composing = 0 } } }), wd = $.baseTheme({ ".cm-tooltip.cm-tooltip-autocomplete": { "& > ul": { fontFamily: "monospace", whiteSpace: "nowrap", overflow: "hidden auto", maxWidth_fallback: "700px", maxWidth: "min(700px, 95vw)", minWidth: "250px", maxHeight: "10em", height: "100%", listStyle: "none", margin: 0, padding: 0, "& > li, & > completion-section": { padding: "1px 3px", lineHeight: 1.2 }, "& > li": { overflowX: "hidden", textOverflow: "ellipsis", cursor: "pointer" }, "& > completion-section": { display: "list-item", borderBottom: "1px solid silver", paddingLeft: "0.5em", opacity: .7 } } }, "&light .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#17c", color: "white" }, "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" }, "&dark .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#347", color: "white" }, "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" }, ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": { content: '"Â·Â·Â·"', opacity: .5, display: "block", textAlign: "center" }, ".cm-tooltip.cm-completionInfo": { position: "absolute", padding: "3px 9px", width: "max-content", maxWidth: "400px", boxSizing: "border-box" }, ".cm-completionInfo.cm-completionInfo-left": { right: "100%" }, ".cm-completionInfo.cm-completionInfo-right": { left: "100%" }, ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" }, ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" }, "&light .cm-snippetField": { backgroundColor: "#00000022" }, "&dark .cm-snippetField": { backgroundColor: "#ffffff22" }, ".cm-snippetFieldPosition": { verticalAlign: "text-top", width: 0, height: "1.15em", display: "inline-block", margin: "0 -0.7px -.7em", borderLeft: "1.4px dotted #888" }, ".cm-completionMatchedText": { textDecoration: "underline" }, ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" }, ".cm-completionIcon": { fontSize: "90%", width: ".8em", display: "inline-block", textAlign: "center", paddingRight: ".6em", opacity: "0.6", boxSizing: "content-box" }, ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "'Æ’'" } }, ".cm-completionIcon-class": { "&:after": { content: "'â—‹'" } }, ".cm-completionIcon-interface": { "&:after": { content: "'â—Œ'" } }, ".cm-completionIcon-variable": { "&:after": { content: "'ð‘¥'" } }, ".cm-completionIcon-constant": { "&:after": { content: "'ð¶'" } }, ".cm-completionIcon-type": { "&:after": { content: "'ð‘¡'" } }, ".cm-completionIcon-enum": { "&:after": { content: "'âˆª'" } }, ".cm-completionIcon-property": { "&:after": { content: "'â–¡'" } }, ".cm-completionIcon-keyword": { "&:after": { content: "'ðŸ”‘ï¸Ž'" } }, ".cm-completionIcon-namespace": { "&:after": { content: "'â–¢'" } }, ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } } }), bd = class { constructor(t, e, i, r) { this.field = t, this.line = e, this.from = i, this.to = r } }, yd = class Tp { constructor(t, e, i) { this.field = t, this.from = e, this.to = i } map(t) { var e = t.mapPos(this.from, -1, h.TrackDel), t = t.mapPos(this.to, 1, h.TrackDel); return null == e || null == t ? null : new Tp(this.field, e, t) } }, Sd = class Cp { constructor(t, e) { this.lines = t, this.fieldPositions = e } instantiate(r, t) { let e = [], n = [t]; var s, i = r.doc.lineAt(t), o = /^\s*/.exec(i.text)[0]; for (s of this.lines) { if (e.length) { let e = o, i = /^\t*/.exec(s)[0].length; for (let t = 0; t < i; t++)e += r.facet(Pa); n.push(t + e.length - i), s = e + s.slice(i) } e.push(s), t += s.length + 1 } i = this.fieldPositions.map(t => new yd(t.field, n[t.line] + t.from, n[t.line] + t.to)); return { text: e, ranges: i } } static parse(t) { var n, s, e, o = [], a = [], l = []; for (s of t.split(/\r\n?|\n/)) { for (; n = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(s);) { let e = n[1] ? +n[1] : null, i = n[2] || n[3] || "", r = -1; for (let t = 0; t < o.length; t++)(null != e ? o[t].seq == e : i && o[t].name == i) && (r = t); if (r < 0) { let t = 0; for (; t < o.length && (null == e || null != o[t].seq && o[t].seq < e);)t++; o.splice(t, 0, { seq: e, name: i }), r = t; for (var h of l) h.field >= r && h.field++ } l.push(new bd(r, a.length, n.index, n.index + i.length)), s = s.slice(0, n.index) + i + s.slice(n.index + n[0].length) } for (; e = /\\([{}])/.exec(s);) { s = s.slice(0, e.index) + e[1] + s.slice(e.index + e[0].length); for (var i of l) i.line == a.length && i.from > e.index && (i.from--, i.to--) } a.push(s) } return new Cp(a, l) } }, Qd = S.widget({ widget: new class extends Ne { toDOM() { var t = document.createElement("span"); return t.className = "cm-snippetFieldPosition", t } ignoreEvent() { return !1 } } }), xd = S.mark({ class: "cm-snippetField" }), kd = class Xp { constructor(t, e) { this.ranges = t, this.active = e, this.deco = S.set(t.map(t => (t.from == t.to ? Qd : xd).range(t.from, t.to))) } map(t) { var e, i = []; for (e of this.ranges) { var r = e.map(t); if (!r) return null; i.push(r) } return new Xp(i, this.active) } selectionInsideField(t) { return t.ranges.every(e => this.ranges.some(t => t.field == this.active && t.from <= e.from && t.to >= e.to)) } }, $d = c.define({ map(t, e) { return t && t.map(e) } }), Pd = c.define(), Zd = f.define({ create() { return null }, update(t, e) { for (var i of e.effects) { if (i.is($d)) return i.value; if (i.is(Pd) && t) return new kd(t.ranges, i.value) } return t = (t = t && e.docChanged ? t.map(e.changes) : t) && e.selection && !t.selectionInsideField(e.selection) ? null : t }, provide: t => $.decorations.from(t, t => t ? t.deco : S.none) }); function Td(t, e) { return g.create(t.filter(t => t.field == e).map(t => g.range(t.from, t.to))) } function Cd(s) { return ({ state: t, dispatch: e }) => { var i = t.field(Zd, !1); if (!i || s < 0 && 0 == i.active) return !1; let r = i.active + s, n = 0 < s && !i.ranges.some(t => t.field == r + s); return e(t.update({ selection: Td(i.ranges, r), effects: $d.of(n ? null : new kd(i.ranges, r)), scrollIntoView: !0 })), !0 } } var Xd = [{ key: "Tab", run: Cd(1), shift: Cd(-1) }, { key: "Escape", run: ({ state: t, dispatch: e }) => !!t.field(Zd, !1) && (e(t.update({ effects: $d.of(null) })), !0) }], Ad = d.define({ combine(t) { return t.length ? t[0] : Xd } }), Rd = vt.highest(jn.compute([Ad], t => t.facet(Ad))); function Yd(t, e) { return Object.assign(Object.assign({}, e), { apply: (t => { let o = Sd.parse(t); return (t, e, i, r) => { var { text: n, ranges: s } = o.instantiate(t.state, i), i = { changes: { from: i, to: r, insert: m.of(n) }, scrollIntoView: !0, annotations: e ? Gc.of(e) : void 0 }; s.length && (i.selection = Td(s, 0)), 1 < s.length && (r = new kd(s, 0), n = i.effects = [$d.of(r)], void 0 === t.state.field(Zd, !1)) && n.push(c.appendConfig.of([Zd, Rd, Wd, wd])), t.dispatch(t.state.update(i)) } })(t) }) } var Wd = $.domEventHandlers({ mousedown(t, e) { let i = e.state.field(Zd, !1), r; if (!i || null == (r = e.posAtCoords({ x: t.clientX, y: t.clientY }))) return !1; let n = i.ranges.find(t => t.from <= r && t.to >= r); return !(!n || n.field == i.active || (e.dispatch({ selection: Td(i.ranges, n.field), effects: $d.of(i.ranges.some(t => t.field > n.field) ? new kd(i.ranges, n.field) : null), scrollIntoView: !0 }), 0)) } }), Vd = { brackets: ["(", "[", "{", "'", '"'], before: ")]}:;>", stringPrefixes: [] }, Md = c.define({ map(t, e) { e = e.mapPos(t, -1, h.TrackAfter); return null == e ? void 0 : e } }), qd = new class extends Gt { }, _d = (qd.startSide = 1, qd.endSide = -1, f.define({ create() { return w.empty }, update(t, i) { if (t = t.map(i.changes), i.selection) { let e = i.state.doc.lineAt(i.selection.main.head); t = t.update({ filter: t => t >= e.from && t <= e.to }) } for (var e of i.effects) e.is(Md) && (t = t.update({ add: [qd.range(e.value, e.value + 1)] })); return t } })); var jd = "()[]{}<>"; function Ed(e) { for (let t = 0; t < jd.length; t += 2)if (jd.charCodeAt(t) == e) return jd.charAt(t + 1); return J(e < 128 ? e : e + 1) } function Dd(t, e) { return t.languageDataAt("closeBrackets", e)[0] || Vd } var zd = "object" == typeof navigator && /Android\b/.test(navigator.userAgent), Bd = $.inputHandler.of((t, e, i, r) => { var n; return !((zd ? t.composing : t.compositionStarted) || t.state.readOnly || (n = t.state.selection.main, 2 < r.length) || 2 == r.length && 1 == K(Q(r, 0)) || e != n.from || i != n.to || !(e = ((t, e) => { var i, r = Dd(t, t.selection.main.head), n = r.brackets || Vd.brackets; for (i of n) { var s = Ed(Q(i, 0)); if (e == i) return s == i ? ((s, o, a, t) => { let l = t.stringPrefixes || Vd.stringPrefixes, h = null, e = s.changeByRange(t => { if (!t.empty) return { changes: [{ insert: o, from: t.from }, { insert: o, from: t.to }], effects: Md.of(t.to + o.length), range: g.range(t.anchor + o.length, t.head + o.length) }; let e = t.head, i = Nd(s.doc, e), r; if (i == o) { if (Ud(s, e)) return { changes: { insert: o + o, from: e }, effects: Md.of(e + o.length), range: g.cursor(e + o.length) }; var n; if (Id(s, e)) return { changes: { from: e, to: e + (n = a && s.sliceDoc(e, e + 3 * o.length) == o + o + o ? o + o + o : o).length, insert: n }, range: g.cursor(e + n.length) } } else { if (a && s.sliceDoc(e - 2 * o.length, e) == o + o && -1 < (r = Ld(s, e - 2 * o.length, l)) && Ud(s, r)) return { changes: { insert: o + o + o + o, from: e }, effects: Md.of(e + o.length), range: g.cursor(e + o.length) }; if (s.charCategorizer(e)(i) != p.Word && -1 < Ld(s, e, l) && !((e, i, r, n) => { let s = T(e).resolveInner(i, -1), o = n.reduce((t, e) => Math.max(t, e.length), 0); for (let t = 0; t < 5; t++) { var a = e.sliceDoc(s.from, Math.min(s.to, s.from + r.length + o)), l = a.indexOf(r); if (!l || -1 < l && -1 < n.indexOf(a.slice(0, l))) { let t = s.firstChild; for (; t && t.from == s.from && t.to - t.from > r.length + l;) { if (e.sliceDoc(t.to - r.length, t.to) == r) return; t = t.firstChild } return 1 } a = s.to == i && s.parent; if (!a) break; s = a } })(s, e, o, l)) return { changes: { insert: o + o, from: e }, effects: Md.of(e + o.length), range: g.cursor(e + o.length) } } return { range: h = t } }); return h ? null : s.update(e, { scrollIntoView: !0, userEvent: "input.type" }) })(t, i, -1 < n.indexOf(i + i + i), r) : ((i, r, n, s) => { let o = null, t = i.changeByRange(t => { var e; return t.empty ? !(e = Nd(i.doc, t.head)) || /\s/.test(e) || -1 < s.indexOf(e) ? { changes: { insert: r + n, from: t.head }, effects: Md.of(t.head + r.length), range: g.cursor(t.head + r.length) } : { range: o = t } : { changes: [{ insert: r, from: t.from }, { insert: n, from: t.to }], effects: Md.of(t.to + r.length), range: g.range(t.anchor + r.length, t.head + r.length) } }); return o ? null : i.update(t, { scrollIntoView: !0, userEvent: "input.type" }) })(t, i, s, r.before || Vd.before); if (e == s && Id(t, t.selection.main.from)) return ((e, i) => { let r = null, t = e.changeByRange(t => t.empty && Nd(e.doc, t.head) == i ? { changes: { from: t.head, to: t.head + i.length, insert: i }, range: g.cursor(t.head + i.length) } : r = { range: t }); return r ? null : e.update(t, { scrollIntoView: !0, userEvent: "input.type" }) })(t, (i, s)) } return null })(t.state, r)) || (t.dispatch(e), 0)) }), Gd = [{ key: "Backspace", run: ({ state: r, dispatch: t }) => { if (r.readOnly) return !1; let n = Dd(r, r.selection.main.head).brackets || Vd.brackets, s = null, e = r.changeByRange(t => { if (t.empty) { var e, i = ((t, e) => K(Q(t = t.sliceString(e - 2, e), 0)) == t.length ? t : t.slice(1))(r.doc, t.head); for (e of n) if (e == i && Nd(r.doc, t.head) == Ed(Q(e, 0))) return { changes: { from: t.head - e.length, to: t.head + e.length }, range: g.cursor(t.head - e.length) } } return { range: s = t } }); return s || t(r.update(e, { scrollIntoView: !0, userEvent: "delete.backward" })), !s } }]; function Id(t, e) { let i = !1; return t.field(_d).between(0, t.doc.length, t => { t == e && (i = !0) }), i } function Nd(t, e) { t = t.sliceString(e, e + 2); return t.slice(0, K(Q(t, 0))) } function Ud(t, e) { t = T(t).resolveInner(e + 1); return t.parent && t.from == e } function Ld(t, e, i) { var r, n = t.charCategorizer(e); if (n(t.sliceDoc(e - 1, e)) != p.Word) return e; for (r of i) { var s = e - r.length; if (t.sliceDoc(s, e) == r && n(t.sliceDoc(s - 1, s)) != p.Word) return s } return -1 } var Fd = [{ key: "Ctrl-Space", run: t => !!t.state.field(ud, !1) && (t.dispatch({ effects: Uc.of(!0) }), !0) }, { key: "Escape", run: t => { var e = t.state.field(ud, !1); return !(!e || !e.active.some(t => 0 != t.state) || (t.dispatch({ effects: Lc.of(null) }), 0)) } }, { key: "ArrowDown", run: md(!0) }, { key: "ArrowUp", run: md(!1) }, { key: "PageDown", run: md(!0, "page") }, { key: "PageUp", run: md(!1, "page") }, { key: "Enter", run: t => { var e = t.state.field(ud, !1); return !(t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(A).interactionDelay) && fd(t, e.open.options[e.open.selected]) } }], Hd = vt.highest(jn.computeN([A], t => t.facet(A).defaultKeymap ? [Fd] : [])), Jd = class { constructor(t, e, i) { this.from = t, this.to = e, this.diagnostic = i } }, Kd = class Ap { constructor(t, e, i) { this.diagnostics = t, this.panel = e, this.selected = i } static init(t, e, i) { let r = t; t = i.facet(hO).markerFilter, t && (r = t(r)), t = S.set(r.map(t => t.from == t.to || t.from == t.to - 1 && i.doc.lineAt(t.from).to == t.from ? S.widget({ widget: new OO(t), diagnostic: t }).range(t.from) : S.mark({ attributes: { class: "cm-lintRange cm-lintRange-" + t.severity + (t.markClass ? " " + t.markClass : "") }, diagnostic: t }).range(t.from, t.to)), !0); return new Ap(t, e, tO(t)) } }; function tO(t, r = null, e = 0) { let n = null; return t.between(e, 1e9, (t, e, { spec: i }) => { if (!r || i.diagnostic == r) return n = new Jd(t, e, i.diagnostic), !1 }), n } var eO = c.define(), iO = c.define(), rO = c.define(), nO = f.define({ create() { return new Kd(S.none, null, null) }, update(i, r) { if (r.docChanged) { let t = i.diagnostics.map(r.changes), e = null; var n; i.selected && (n = r.changes.mapPos(i.selected.from, 1), e = tO(t, i.selected.diagnostic, n) || tO(t, null, n)), i = new Kd(t, i.panel, e) } for (var t of r.effects) t.is(eO) ? i = Kd.init(t.value, i.panel, r.state) : t.is(iO) ? i = new Kd(i.diagnostics, t.value ? fO.open : null, i.selected) : t.is(rO) && (i = new Kd(i.diagnostics, i.panel, t.value)); return i }, provide: t => [Ns.from(t, t => t.panel), $.decorations.from(t, t => t.diagnostics)] }), sO = S.mark({ class: "cm-lintRange cm-lintRange-active" }); function oO(t, r, n) { var e = t.state.field(nO).diagnostics; let s = [], o = 2e8, a = 0; e.between(r - (n < 0 ? 1 : 0), r + (0 < n ? 1 : 0), (t, e, { spec: i }) => { t <= r && r <= e && (t == e || (t < r || 0 < n) && (r < e || n < 0)) && (s.push(i.diagnostic), o = Math.min(t, o), a = Math.max(e, a)) }); e = t.state.facet(hO).tooltipFilter; return (s = e ? e(s) : s).length ? { pos: o, end: a, above: t.state.doc.lineAt(o).to < a, create() { return { dom: (e = t, X("ul", { class: "cm-tooltip-lint" }, s.map(t => dO(e, t, !1)))) }; var e } } : null } var aO = t => { var e = t.state.field(nO, !1); return !(!e || !e.panel || (t.dispatch({ effects: iO.of(!1) }), 0)) }, lO = [{ key: "Mod-Shift-m", run: t => { var e, i = t.state.field(nO, !1), i = (i && i.panel || t.dispatch({ effects: (i = t.state, e = [iO.of(!0)], i.field(nO, !1) ? e : e.concat(c.appendConfig.of(mO))) }), zs(t, fO.open)); return i && i.dom.querySelector(".cm-panel-lint ul").focus(), !0 }, preventDefault: !0 }, { key: "F8", run: t => { var e = t.state.field(nO, !1); if (!e) return !1; let i = t.state.selection.main, r = e.diagnostics.iter(i.to + 1); return !(!r.value && (!(r = e.diagnostics.iter(0)).value || r.from == i.from && r.to == i.to) || (t.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), 0)) } }], hO = d.define({ combine(t) { return Object.assign({ sources: t.map(t => t.source) }, Bt(t.map(t => t.config), { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null }, { needsRefresh: (e, i) => e ? i ? t => e(t) || i(t) : e : i })) } }); function cO(t) { var i = []; if (t) t: for (var { name: r } of t) { for (let t = 0; t < r.length; t++) { let e = r[t]; if (/[a-zA-Z]/.test(e) && !i.some(t => t.toLowerCase() == e.toLowerCase())) { i.push(e); continue t } } i.push("") } return i } function dO(a, l, t) { let e, h = t ? cO(l.actions) : []; return X("li", { class: "cm-diagnostic cm-diagnostic-" + l.severity }, X("span", { class: "cm-diagnosticText" }, l.renderMessage ? l.renderMessage() : l.message), null == (e = l.actions) ? void 0 : e.map((e, t) => { let i = !1, r = t => { t.preventDefault(), !i && (i = !0, t = tO(a.state.field(nO).diagnostics, l)) && e.apply(a, t.from, t.to) }; var n = e.name, s = h[t] ? n.indexOf(h[t]) : -1, o = s < 0 ? n : [n.slice(0, s), X("u", n.slice(s, s + 1)), n.slice(s + 1)]; return X("button", { type: "button", class: "cm-diagnosticAction", onclick: r, onmousedown: r, "aria-label": ` Action: ${n}${s < 0 ? "" : ` (access key "${h[t]})"`}.` }, o) }), l.source && X("div", { class: "cm-diagnosticSource" }, l.source)) } var OO = class extends Ne { constructor(t) { super(), this.diagnostic = t } eq(t) { return t.diagnostic == this.diagnostic } toDOM() { return X("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity }) } }, uO = class { constructor(t, e) { this.diagnostic = e, this.id = "item_" + Math.floor(4294967295 * Math.random()).toString(16), this.dom = dO(t, e, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option") } }, fO = class Rp { constructor(s) { this.view = s, this.items = []; this.list = X("ul", { tabIndex: 0, role: "listbox", "aria-label": this.view.state.phrase("Diagnostics"), onkeydown: e => { if (27 == e.keyCode) aO(this.view), this.view.focus(); else if (38 == e.keyCode || 33 == e.keyCode) this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length); else if (40 == e.keyCode || 34 == e.keyCode) this.moveSelection((this.selectedIndex + 1) % this.items.length); else if (36 == e.keyCode) this.moveSelection(0); else if (35 == e.keyCode) this.moveSelection(this.items.length - 1); else if (13 == e.keyCode) this.view.focus(); else { if (!(65 <= e.keyCode && e.keyCode <= 90 && 0 <= this.selectedIndex)) return; var i, r = this.items[this.selectedIndex].diagnostic, n = cO(r.actions); for (let t = 0; t < n.length; t++)n[t].toUpperCase().charCodeAt(0) == e.keyCode && (i = tO(this.view.state.field(nO).diagnostics, r)) && r.actions[t].apply(s, i.from, i.to) } e.preventDefault() }, onclick: e => { for (let t = 0; t < this.items.length; t++)this.items[t].dom.contains(e.target) && this.moveSelection(t) } }), this.dom = X("div", { class: "cm-panel-lint" }, this.list, X("button", { type: "button", name: "close", "aria-label": this.view.state.phrase("close"), onclick: () => aO(this.view) }, "Ã—")), this.update() } get selectedIndex() { var e = this.view.state.field(nO).selected; if (e) for (let t = 0; t < this.items.length; t++)if (this.items[t].diagnostic == e.diagnostic) return t; return -1 } update() { let { diagnostics: t, selected: s } = this.view.state.field(nO), o = 0, a = !1, l = null; for (t.between(0, this.view.state.doc.length, (t, e, { spec: i }) => { let r = -1, n; for (let t = o; t < this.items.length; t++)if (this.items[t].diagnostic == i.diagnostic) { r = t; break } r < 0 ? (n = new uO(this.view, i.diagnostic), this.items.splice(o, 0, n), a = !0) : (n = this.items[r], r > o && (this.items.splice(o, r - o), a = !0)), s && n.diagnostic == s.diagnostic ? n.dom.hasAttribute("aria-selected") || (n.dom.setAttribute("aria-selected", "true"), l = n) : n.dom.hasAttribute("aria-selected") && n.dom.removeAttribute("aria-selected"), o++ }); o < this.items.length && !(1 == this.items.length && this.items[0].diagnostic.from < 0);)a = !0, this.items.pop(); 0 == this.items.length && (this.items.push(new uO(this.view, { from: -1, to: -1, severity: "info", message: this.view.state.phrase("No diagnostics") })), a = !0), l ? (this.list.setAttribute("aria-activedescendant", l.id), this.view.requestMeasure({ key: this, read: () => ({ sel: l.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }), write: ({ sel: t, panel: e }) => { var i = e.height / this.list.offsetHeight; t.top < e.top ? this.list.scrollTop -= (e.top - t.top) / i : t.bottom > e.bottom && (this.list.scrollTop += (t.bottom - e.bottom) / i) } })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), a && this.sync() } sync() { let e = this.list.firstChild; function t() { var t = e; e = t.nextSibling, t.remove() } for (var i of this.items) if (i.dom.parentNode == this.list) { for (; e != i.dom;)t(); e = i.dom.nextSibling } else this.list.insertBefore(i.dom, e); for (; e;)t() } moveSelection(t) { this.selectedIndex < 0 || (t = tO(this.view.state.field(nO).diagnostics, this.items[t].diagnostic)) && this.view.dispatch({ selection: { anchor: t.from, head: t.to }, scrollIntoView: !0, effects: rO.of(t) }) } static open(t) { return new Rp(t) } }; function pO(t) { return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${'width="6" height="3"'}>${encodeURIComponent(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`)}</svg>')` } var Ie = $.baseTheme({ ".cm-diagnostic": { padding: "3px 6px 3px 8px", marginLeft: "-1px", display: "block", whiteSpace: "pre-wrap" }, ".cm-diagnostic-error": { borderLeft: "5px solid #d11" }, ".cm-diagnostic-warning": { borderLeft: "5px solid orange" }, ".cm-diagnostic-info": { borderLeft: "5px solid #999" }, ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" }, ".cm-diagnosticAction": { font: "inherit", border: "none", padding: "2px 4px", backgroundColor: "#444", color: "white", borderRadius: "3px", marginLeft: "8px", cursor: "pointer" }, ".cm-diagnosticSource": { fontSize: "70%", opacity: .7 }, ".cm-lintRange": { backgroundPosition: "left bottom", backgroundRepeat: "repeat-x", paddingBottom: "0.7px" }, ".cm-lintRange-error": { backgroundImage: pO("#d11") }, ".cm-lintRange-warning": { backgroundImage: pO("orange") }, ".cm-lintRange-info": { backgroundImage: pO("#999") }, ".cm-lintRange-hint": { backgroundImage: pO("#66d") }, ".cm-lintRange-active": { backgroundColor: "#ffdd9980" }, ".cm-tooltip-lint": { padding: 0, margin: 0 }, ".cm-lintPoint": { position: "relative", "&:after": { content: '""', position: "absolute", bottom: 0, left: "-2px", borderLeft: "3px solid transparent", borderRight: "3px solid transparent", borderBottom: "4px solid #d11" } }, ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } }, ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } }, ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } }, ".cm-panel.cm-panel-lint": { position: "relative", "& ul": { maxHeight: "100px", overflowY: "auto", "& [aria-selected]": { backgroundColor: "#ddd", "& u": { textDecoration: "underline" } }, "&:focus [aria-selected]": { background_fallback: "#bdf", backgroundColor: "Highlight", color_fallback: "white", color: "HighlightText" }, "& u": { textDecoration: "none" }, padding: 0, margin: 0 }, "& [name=close]": { position: "absolute", top: "0", right: "2px", background: "inherit", border: "none", font: "inherit", padding: 0, margin: 0 } } }), mO = [nO, $.decorations.compute([nO], t => { var { selected: t, panel: e } = t.field(nO); return t && e && t.from != t.to ? S.set([sO.range(t.from, t.to)]) : S.none }), _s(oO, { hideOn: function(t, e) { return e = t.startState.doc.lineAt(e.pos), !(!t.effects.some(t => t.is(eO)) && !t.changes.touchesRange(e.from, e.to)) } }), Ie], gO = (() => { return [(e = {}, [oo.of(e), Js(), ho]), uo, ps(), (e = {}, [Il, Gl.of(e), $.domEventHandlers({ beforeinput(t, e) { var i = "historyUndo" == t.inputType ? Ul : "historyRedo" == t.inputType ? Ll : null; return !!i && (t.preventDefault(), i(e)) } })]), ol(), (e = {}, [Kn.of(e), es, rs, ns, Ei.of(!0)]), [os, as], v.allowMultipleSelections.of(!0), v.transactionFilter.of(t => { if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete")) return t; var e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head); if (!e.length) return t; var i, r = t.newDoc, n = t.newSelection.main.head, s = r.lineAt(n); if (n > s.from + 200) return t; let o = r.sliceString(s.from, n); if (!e.some(t => t.test(o))) return t; let a = t.state, l = -1, h = []; for ({ head: i } of a.selection.ranges) { var c, d, O, u = a.doc.lineAt(i); u.from != l && (l = u.from, null != (c = Ca(a, u.from)) && (d = /^\s*/.exec(u.text)[0]) != (O = Ta(a, c))) && h.push({ from: u.from, to: u.from + d.length, insert: O }) } return h.length ? [t, { changes: h, sequential: !0 }] : t }), Ol(fl, { fallback: !0 }), (e = {}, [gl.of(e), yl]), [Bd, _d], (e = {}, [ud, A.of(e), vd, Hd, wd]), (t => { let i = (null == t ? void 0 : t.eventFilter) || (t => t.altKey && 0 == t.button); return $.mouseSelectionStyle.of((t, e) => i(e) ? Qs(t, e) : null) })(), ((t = {}) => { let [e, i] = xs[t.key || "Alt"], r = a.fromClass(class { constructor(t) { this.view = t, this.isDown = !1 } set(t) { this.isDown != t && (this.isDown = t, this.view.update([])) } }, { eventObservers: { keydown(t) { this.set(t.keyCode == e || i(t)) }, keyup(t) { t.keyCode != e && i(t) || this.set(!1) }, mousemove(t) { this.set(i(t)) } } }); return [r, $.contentAttributes.of(t => null != (t = t.plugin(r)) && t.isDown ? ks : null)] })(), bs, (e = [sc, nc], t && e.push(tc.of(t)), e), jn.of([...Gd, ...qh, ...Ac, ...sh, ...Ha, ...Fd, ...lO])]; var t, e })(), vO = class Yp { constructor(t, e, i, r, n, s, o, a, l, h = 0, c) { this.p = t, this.stack = e, this.state = i, this.reducePos = r, this.pos = n, this.score = s, this.buffer = o, this.bufferBase = a, this.curContext = l, this.lookAhead = h, this.parent = c } toString() { return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@` + this.pos + (this.score ? "!" + this.score : "") } static start(t, e, i = 0) { var r = t.parser.context; return new Yp(t, [], e, i, i, 0, [], 0, r ? new wO(r, r.start) : null, 0, null) } get context() { return this.curContext ? this.curContext.context : null } pushState(t, e) { this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t } reduce(t) { var e = t >> 19, i = 65535 & t, r = this.p.parser, n = r.dynamicPrecedence(i); if (n && (this.score += n), 0 == e) this.pushState(r.getGoto(this.state, i, !0), this.reducePos), i < r.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos); else { var s = this.stack.length - 3 * (e - 1) - (262144 & t ? 6 : 0), n = s ? this.stack[s - 2] : this.p.ranges[0].from, e = this.reducePos - n, o = (2e3 <= e && (null == (o = this.p.parser.nodeSet.types[i]) || !o.isAnonymous) && (n == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = e) : this.p.lastBigReductionSize < e && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = n, this.p.lastBigReductionSize = e)), s ? this.stack[s - 1] : 0), e = this.bufferBase + this.buffer.length - o; for ((i < r.minRepeatTerm || 131072 & t) && (o = r.stateFlag(this.state, 1) ? this.pos : this.reducePos, this.storeNode(i, n, o, 4 + e, !0)), 262144 & t ? this.state = this.stack[s] : (o = this.stack[s - 3], this.state = r.getGoto(o, i, !0)); this.stack.length > s;)this.stack.pop(); this.reduceContext(i, n) } } storeNode(e, i, r, n = 4, t = !1) { if (0 == e && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) { let t = this, e = this.buffer.length; if (0 == e && t.parent && (e = t.bufferBase - t.parent.bufferBase, t = t.parent), 0 < e && 0 == t.buffer[e - 4] && -1 < t.buffer[e - 1]) { if (i == r) return; if (t.buffer[e - 2] >= i) return void (t.buffer[e - 2] = r) } } if (t && this.pos != r) { let t = this.buffer.length; if (0 < t && 0 != this.buffer[t - 4]) for (; 0 < t && this.buffer[t - 2] > r;)this.buffer[t] = this.buffer[t - 4], this.buffer[t + 1] = this.buffer[t - 3], this.buffer[t + 2] = this.buffer[t - 2], this.buffer[t + 3] = this.buffer[t - 1], t -= 4, 4 < n && (n -= 4); this.buffer[t] = e, this.buffer[t + 1] = i, this.buffer[t + 2] = r, this.buffer[t + 3] = n } else this.buffer.push(e, i, r, n) } shift(t, e, i, r) { var n; 131072 & t ? this.pushState(65535 & t, this.pos) : 0 == (262144 & t) ? (t = t, n = this.p.parser, (r > this.pos || e <= n.maxNode) && (this.pos = r, n.stateFlag(t, 1) || (this.reducePos = r)), this.pushState(t, i), this.shiftContext(e, i), e <= n.maxNode && this.buffer.push(e, i, r, 4)) : (this.pos = r, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, r, 4)) } apply(t, e, i, r) { 65536 & t ? this.reduce(t) : this.shift(t, e, i, r) } useNode(t, e) { let i = this.p.reused.length - 1; (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++); var r = this.pos; this.reducePos = this.pos = r + t.length, this.pushState(e, r), this.buffer.push(i, r, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length))) } split() { let t = this, e = t.buffer.length; for (; 0 < e && t.buffer[e - 2] > t.reducePos;)e -= 4; for (var i = t.buffer.slice(e), r = t.bufferBase + e; t && r == t.bufferBase;)t = t.parent; return new Yp(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, t) } recoverByDelete(t, e) { var i = t <= this.p.parser.maxNode; i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190 } canShift(t) { for (var e = new bO(this); ;) { var i = this.p.parser.stateSlot(e.state, 4) || this.p.parser.hasAction(e.state, t); if (0 == i) return !1; if (0 == (65536 & i)) return !0; e.reduce(i) } } recoverByInsert(i) { if (300 <= this.stack.length) return []; let r = this.p.parser.nextStates(this.state); if (8 < r.length || 120 <= this.stack.length) { var n = []; for (let t = 0, e; t < r.length; t += 2)(e = r[t + 1]) != this.state && this.p.parser.hasAction(e, i) && n.push(r[t], e); if (this.stack.length < 120) for (let t = 0; n.length < 8 && t < r.length; t += 2) { let i = r[t + 1]; n.some((t, e) => 1 & e && t == i) || n.push(r[t], i) } r = n } var e = []; for (let t = 0; t < r.length && e.length < 4; t += 2) { var s, o = r[t + 1]; o != this.state && ((s = this.split()).pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(r[t], this.pos), s.reducePos = this.pos, s.score -= 200, e.push(s)) } return e } forceReduce() { var t = this.p.parser; let e = t.stateSlot(this.state, 5); if (0 == (65536 & e)) return !1; if (!t.validAction(this.state, e)) { var i = e >> 19, r = 65535 & e, i = this.stack.length - 3 * i; if (i < 0 || t.getGoto(this.stack[i], r, !1) < 0) { t = this.findForcedReduction(); if (null == t) return !1; e = t } this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100 } return this.reducePos = this.pos, this.reduce(e), !0 } findForcedReduction() { let s = this.p.parser, e = [], o = (t, n) => { if (!e.includes(t)) return e.push(t), s.allActions(t, t => { if (!(393216 & t)) if (65536 & t) { var e = (t >> 19) - n; if (1 < e) { var i = 65535 & t, r = this.stack.length - 3 * e; if (0 <= r && 0 <= s.getGoto(this.stack[r], i, !1)) return e << 19 | 65536 | i } } else { r = o(t, n + 1); if (null != r) return r } }) }; return o(this.state, 0) } forceAll() { for (; !this.p.parser.stateFlag(this.state, 2);)if (!this.forceReduce()) { this.storeNode(0, this.pos, this.pos, 4, !0); break } return this } get deadEnd() { var t; return 3 == this.stack.length && (t = this.p.parser, 65535 == t.data[t.stateSlot(this.state, 1)]) && !t.stateSlot(this.state, 4) } restart() { this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0 } sameState(e) { if (this.state != e.state || this.stack.length != e.stack.length) return !1; for (let t = 0; t < this.stack.length; t += 3)if (this.stack[t] != e.stack[t]) return !1; return !0 } get parser() { return this.p.parser } dialectEnabled(t) { return this.p.parser.dialect.flags[t] } shiftContext(t, e) { this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e))) } reduceContext(t, e) { this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e))) } emitContext() { var t = this.buffer.length - 1; (t < 0 || -3 != this.buffer[t]) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3) } emitLookAhead() { var t = this.buffer.length - 1; (t < 0 || -4 != this.buffer[t]) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4) } updateContext(t) { t != this.curContext.context && ((t = new wO(this.curContext.tracker, t)).hash != this.curContext.hash && this.emitContext(), this.curContext = t) } setLookAhead(t) { t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t) } close() { this.curContext && this.curContext.tracker.strict && this.emitContext(), 0 < this.lookAhead && this.emitLookAhead() } }, wO = class { constructor(t, e) { this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0 } }, bO = class { constructor(t) { this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length } reduce(t) { var e = 65535 & t, t = t >> 19, t = (0 == t ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= 3 * (t - 1), this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0)); this.state = t } }, yO = class Wp { constructor(t, e, i) { this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, 0 == this.index && this.maybeNext() } static create(t, e = t.bufferBase + t.buffer.length) { return new Wp(t, e, e - t.bufferBase) } maybeNext() { var t = this.stack.parent; null != t && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer) } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } next() { this.index -= 4, this.pos -= 4, 0 == this.index && this.maybeNext() } fork() { return new Wp(this.stack, this.pos, this.index) } }; function SO(s, e = Uint16Array) { if ("string" != typeof s) return s; let i = null; for (let n = 0, t = 0; n < s.length;) { let r = 0; for (; ;) { let t = s.charCodeAt(n++), e = !1; if (126 == t) { r = 65535; break } 92 <= t && t--, 34 <= t && t--; let i = t - 32; if (46 <= i && (i -= 46, e = !0), r += i, e) break; r *= 46 } i ? i[t++] = r : i = new e(r) } return i } var QO = class { constructor() { this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0 } }, xO = new QO, kO = class { constructor(t, e) { this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = xO, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext() } resolveOffset(t, e) { let i = this.range, r = this.rangeIndex, n = this.pos + t; for (; n < i.from;) { if (!r) return null; var s = this.ranges[--r]; n -= i.from - s.to, i = s } for (; e < 0 ? n > i.to : n >= i.to;) { if (r == this.ranges.length - 1) return null; var o = this.ranges[++r]; n += o.from - i.to, i = o } return n } clipPos(t) { if (t >= this.range.from && t < this.range.to) return t; for (var e of this.ranges) if (e.to > t) return Math.max(t, e.from); return this.end } peek(t) { let e = this.chunkOff + t, i, r; if (0 <= e && e < this.chunk.length) i = this.pos + t, r = this.chunk.charCodeAt(e); else { t = this.resolveOffset(t, 1); if (null == t) return -1; if ((i = t) >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length) r = this.chunk2.charCodeAt(i - this.chunk2Pos); else { let t = this.rangeIndex, e = this.range; for (; e.to <= i;)e = this.ranges[++t]; this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > e.to && (this.chunk2 = this.chunk2.slice(0, e.to - i)), r = this.chunk2.charCodeAt(0) } } return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r } acceptToken(t, e = 0) { e = e ? this.resolveOffset(e, -1) : this.pos; if (null == e || e < this.token.start) throw new RangeError("Token end out of bounds"); this.token.value = t, this.token.end = e } getChunk() { var t, e; this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length ? ({ chunk: t, chunkPos: e } = this, this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos) : (this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos, t = this.input.chunk(this.pos), e = this.pos + t.length, this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0) } readNext() { return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff) } advance(t = 1) { for (this.chunkOff += t; this.pos + t >= this.range.to;) { if (this.rangeIndex == this.ranges.length - 1) return this.setDone(); t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from } return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext() } setDone() { return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1 } reset(t, e) { if (e ? ((this.token = e).start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = xO, this.pos != t) { if ((this.pos = t) == this.end) return this.setDone(), this; for (; t < this.range.from;)this.range = this.ranges[--this.rangeIndex]; for (; t >= this.range.to;)this.range = this.ranges[++this.rangeIndex]; t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext() } return this } read(t, e) { if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length) return this.chunk.slice(t - this.chunkPos, e - this.chunkPos); if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos); if (t >= this.range.from && e <= this.range.to) return this.input.read(t, e); let i = ""; for (var r of this.ranges) { if (r.from >= e) break; r.to > t && (i += this.input.read(Math.max(r.from, t), Math.min(r.to, e))) } return i } }, $O = class { constructor(t, e) { this.data = t, this.id = e } token(t, e) { var i = e.p.parser; ZO(this.data, t, e, this.id, i.data, i.tokenPrecTable) } }, i = ($O.prototype.contextual = $O.prototype.fallback = $O.prototype.extend = !1, class { constructor(t, e, i) { this.precTable = e, this.elseToken = i, this.data = "string" == typeof t ? SO(t) : t } token(t, e) { let i = t.pos, r = 0; for (; ;) { var n = t.next < 0, s = t.resolveOffset(1, 1); if (ZO(this.data, t, e, 0, this.data, this.precTable), -1 < t.token.value) break; if (null == this.elseToken) return; if (n || r++, null == s) break; t.reset(s, t.token) } r && (t.reset(i, t.token), t.acceptToken(this.elseToken, r)) } }), PO = (i.prototype.contextual = $O.prototype.fallback = $O.prototype.extend = !1, class { constructor(t, e = {}) { this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend } }); function ZO(r, n, t, e, s, o) { let a = 0, l = 1 << e, h = t.p.parser.dialect; t: for (; 0 != (l & r[a]);) { var c = r[a + 1]; for (let t = a + 3; t < c; t += 2)if (0 < (r[t + 1] & l)) { var d = r[t]; if (h.allows(d) && (-1 == n.token.value || n.token.value == d || ((t, e, i, r) => (e = TO(i, r, e)) < 0 || TO(i, r, t) < e)(d, n.token.value, s, o))) { n.acceptToken(d); break } } let t = n.next, e = 0, i = r[a + 2]; if (!(n.next < 0 && i > e && 65535 == r[c + 3 * i - 3])) { for (; e < i;) { var O = e + i >> 1, u = c + O + (O << 1), f = r[u], p = r[u + 1] || 65536; if (t < f) i = O; else { if (!(p <= t)) { a = r[u + 2], n.advance(); continue t } e = 1 + O } } break } a = r[c + 3 * i - 1] } } function TO(i, r, n) { for (let t = r, e; 65535 != (e = i[t]); t++)if (e == n) return t - r; return -1 } var CO = "undefined" != typeof process && process.env && /\bparse\b/.test(process.env.LOG), XO = null; function AO(t, e, i) { var r = t.cursor(P.IncludeAnonymous); for (r.moveTo(e); ;)if (!(i < 0 ? r.childBefore(e) : r.childAfter(e))) for (; ;) { if ((i < 0 ? r.to < e : r.from > e) && !r.type.isError) return i < 0 ? Math.max(0, Math.min(r.to - 1, e - 25)) : Math.min(t.length, Math.max(r.from + 1, e + 25)); if (i < 0 ? r.prevSibling() : r.nextSibling()) break; if (!r.parent()) return i < 0 ? 0 : t.length } } var RO = class { constructor(t, e) { this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment() } nextFragment() { var t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]; if (t) { for (this.safeFrom = t.openStart ? AO(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? AO(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length;)this.trees.pop(), this.start.pop(), this.index.pop(); this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom } else this.nextStart = 1e9 } nodeAt(t) { if (t < this.nextStart) return null; for (; this.fragment && this.safeTo <= t;)this.nextFragment(); if (!this.fragment) return null; for (; ;) { var e = this.trees.length - 1; if (e < 0) return this.nextFragment(), null; var i = this.trees[e], r = this.index[e]; if (r == i.children.length) this.trees.pop(), this.start.pop(), this.index.pop(); else { var n = i.children[r], i = this.start[e] + i.positions[r]; if (t < i) return this.nextStart = i, null; if (n instanceof B) { if (i == t) { if (i < this.safeFrom) return null; r = i + n.length; if (r <= this.safeTo) { var s = n.prop(z.lookAhead); if (!s || r + s < this.fragment.to) return n } } this.index[e]++, i + n.length >= Math.max(this.safeFrom, t) && (this.trees.push(n), this.start.push(i), this.index.push(0)) } else this.index[e]++, this.nextStart = i + n.length } } } }, YO = class { constructor(t, e) { this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map(t => new QO) } getActions(e) { let i = 0, r = null; var t = e.p.parser, n = t.tokenizers, s = t.stateSlot(e.state, 3), o = e.curContext ? e.curContext.hash : 0; let a = 0; for (let t = 0; t < n.length; t++)if (0 != (1 << t & s)) { var l = n[t], h = this.tokens[t]; if ((!r || l.fallback) && (!l.contextual && h.start == e.pos && h.mask == s && h.context == o || (this.updateCachedToken(h, l, e), h.mask = s, h.context = o), h.lookAhead > h.end + 25 && (a = Math.max(h.lookAhead, a)), 0 != h.value)) { var c = i; if (-1 < h.extended && (i = this.addActions(e, h.extended, h.end, i)), i = this.addActions(e, h.value, h.end, i), !l.extend && (r = h, i > c)) break } } for (; this.actions.length > i;)this.actions.pop(); return a && e.setLookAhead(a), r || e.pos != this.stream.end || ((r = new QO).value = e.p.parser.eofTerm, r.start = r.end = e.pos, i = this.addActions(e, r.value, r.end, i)), this.mainToken = r, this.actions } getMainToken(t) { var e, i; return this.mainToken || ({ pos: t, p: i } = t, (e = new QO).start = t, e.end = Math.min(t + 1, i.stream.end), e.value = t == i.stream.end ? i.parser.eofTerm : 0, e) } updateCachedToken(e, t, i) { var r = this.stream.clipPos(i.pos); if (t.token(this.stream.reset(r, e), i), -1 < e.value) { var n = i.p.parser; for (let t = 0; t < n.specialized.length; t++)if (n.specialized[t] == e.value) { var s = n.specializers[t](this.stream.read(e.start, e.end), i); if (0 <= s && i.p.parser.dialect.allows(s >> 1)) { 0 == (1 & s) ? e.value = s >> 1 : e.extended = s >> 1; break } } } else e.value = 0, e.end = this.stream.clipPos(r + 1) } putAction(e, t, i, r) { for (let t = 0; t < r; t += 3)if (this.actions[t] == e) return r; return this.actions[r++] = e, this.actions[r++] = t, this.actions[r++] = i, r } addActions(t, i, r, n) { var s = t.state, o = t.p.parser, a = o.data; for (let e = 0; e < 2; e++)for (let t = o.stateSlot(s, e ? 2 : 1); ; t += 3) { if (65535 == a[t]) { if (1 != a[t + 1]) { 0 == n && 2 == a[t + 1] && (n = this.putAction(_O(a, t + 2), i, r, n)); break } t = _O(a, t + 2) } a[t] == i && (n = this.putAction(_O(a, t + 1), i, r, n)) } return n } }, WO = class { constructor(t, e, i, r) { this.parser = t, this.input = e, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new kO(e, r), this.tokens = new YO(t, this.stream), this.topTerm = t.top[1]; e = r[0].from; this.stacks = [vO.start(this, t.top[0], e)], this.fragments = i.length && this.stream.end - e > 4 * t.bufferLength ? new RO(i, t.nodeSet) : null } get parsedPos() { return this.minStackPos } advance() { let e = this.stacks, i = this.minStackPos; var r = this.stacks = []; let n, s; if (300 < this.bigReductionCount && 1 == e.length) { for (var [t] = e; t.forceReduce() && t.stack.length && t.stack[t.stack.length - 2] >= this.lastBigReductionStart;); this.bigReductionCount = this.lastBigReductionSize = 0 } for (let t = 0; t < e.length; t++)for (var o = e[t]; ;) { if (this.tokens.mainToken = null, o.pos > i) r.push(o); else { if (this.advanceStack(o, r, e)) continue; n || (n = [], s = []), n.push(o); var a = this.tokens.getMainToken(o); s.push(a.value, a.end) } break } if (!r.length) { var l = n && (t => { let e = null; for (var i of t) { var r = i.p.stoppedAt; (i.pos == i.p.stream.end || null != r && i.pos > r) && i.p.parser.stateFlag(i.state, 2) && (!e || e.score < i.score) && (e = i) } return e })(n); if (l) return CO && console.log("Finish with " + this.stackID(l)), this.stackToTree(l); if (this.parser.strict) throw CO && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + i); this.recovering || (this.recovering = 5) } if (this.recovering && n) { l = null != this.stoppedAt && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, s, r); if (l) return CO && console.log("Force-finish " + this.stackID(l)), this.stackToTree(l.forceAll()) } if (this.recovering) { var h = 1 == this.recovering ? 1 : 3 * this.recovering; if (r.length > h) for (r.sort((t, e) => e.score - t.score); r.length > h;)r.pop(); r.some(t => t.reducePos > i) && this.recovering-- } else if (1 < r.length) { t: for (let e = 0; e < r.length - 1; e++) { var c = r[e]; for (let t = e + 1; t < r.length; t++) { var d = r[t]; if (c.sameState(d) || 500 < c.buffer.length && 500 < d.buffer.length) { if (!(0 < (c.score - d.score || c.buffer.length - d.buffer.length))) { r.splice(e--, 1); continue t } r.splice(t--, 1) } } } 12 < r.length && r.splice(12, r.length - 12) } this.minStackPos = r[0].pos; for (let t = 1; t < r.length; t++)r[t].pos < this.minStackPos && (this.minStackPos = r[t].pos); return null } stopAt(t) { if (null != this.stoppedAt && this.stoppedAt < t) throw new RangeError("Can't move stoppedAt forward"); this.stoppedAt = t } advanceStack(e, i, r) { var n = e.pos, s = this.parser, o = CO ? this.stackID(e) + " -> " : ""; if (null != this.stoppedAt && n > this.stoppedAt) return e.forceReduce() ? e : null; if (this.fragments) { var a = e.curContext && e.curContext.tracker.strict, l = a ? e.curContext.hash : 0; for (let t = this.fragments.nodeAt(n); t;) { var h = this.parser.nodeSet.types[t.type.id] == t.type ? s.getGoto(e.state, t.type.id) : -1; if (-1 < h && t.length && (!a || (t.prop(z.contextHash) || 0) == l)) return e.useNode(t, h), CO && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(t.type.id)})`), !0; if (!(t instanceof B) || 0 == t.children.length || 0 < t.positions[0]) break; h = t.children[0]; if (!(h instanceof B && 0 == t.positions[0])) break; t = h } } var t = s.stateSlot(e.state, 4); if (0 < t) return e.reduce(t), CO && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(65535 & t)})`), !0; if (8400 <= e.stack.length) for (; 6e3 < e.stack.length && e.forceReduce();); var c = this.tokens.getActions(e); for (let t = 0; t < c.length;) { var d = c[t++], O = c[t++], u = c[t++], f = t == c.length || !r, p = f ? e : e.split(), m = this.tokens.mainToken; if (p.apply(d, O, m ? m.start : p.pos, u), CO && console.log(o + this.stackID(p) + ` (via ${0 == (65536 & d) ? "shift" : "reduce of " + s.getName(65535 & d)} for ${s.getName(O)} @ ${n}${p == e ? "" : ", split"})`), f) return !0; (p.pos > n ? i : r).push(p) } return !1 } advanceFully(t, e) { for (var i = t.pos; ;) { if (!this.advanceStack(t, null, null)) return !1; if (t.pos > i) return VO(t, e), !0 } } runRecovery(o, a, l) { let h = null, c = !1; for (let s = 0; s < o.length; s++) { let t = o[s], e = a[s << 1], i = a[1 + (s << 1)]; var d, O = CO ? this.stackID(t) + " -> " : ""; if (t.deadEnd) { if (c) continue; if (c = !0, t.restart(), CO && console.log(O + this.stackID(t) + " (restarted)"), this.advanceFully(t, l)) continue } let r = t.split(), n = O; for (let t = 0; r.forceReduce() && t < 10; t++) { if (CO && console.log(n + this.stackID(r) + " (via force-reduce)"), this.advanceFully(r, l)) break; CO && (n = this.stackID(r) + " -> ") } for (d of t.recoverByInsert(e)) CO && console.log(O + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, l); this.stream.end > t.pos ? (i == t.pos && (i++, e = 0), t.recoverByDelete(e, i), CO && console.log(O + this.stackID(t) + ` (via recover-delete ${this.parser.getName(e)})`), VO(t, l)) : (!h || h.score < t.score) && (h = t) } return h } stackToTree(t) { return t.close(), B.build({ buffer: yO.create(t), nodeSet: this.parser.nodeSet, topID: this.topTerm, maxBufferLength: this.parser.bufferLength, reused: this.reused, start: this.ranges[0].from, length: t.pos - this.ranges[0].from, minRepeatType: this.parser.minRepeatTerm }) } stackID(t) { let e = (XO = XO || new WeakMap).get(t); return e || XO.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t } }; function VO(e, i) { for (let t = 0; t < i.length; t++) { var r = i[t]; if (r.pos == e.pos && r.sameState(e)) return void (i[t].score < e.score && (i[t] = e)) } i.push(e) } var MO = class { constructor(t, e, i) { this.source = t, this.flags = e, this.disabled = i } allows(t) { return !this.disabled || 0 == this.disabled[t] } }, qO = t => t, Sh = class { constructor(t) { this.start = t.start, this.shift = t.shift || qO, this.reduce = t.reduce || qO, this.reuse = t.reuse || qO, this.hash = t.hash || (() => 0), this.strict = !1 !== t.strict } }, n = class Vp extends _o { constructor(i) { if (super(), this.wrappers = [], 14 != i.version) throw new RangeError(`Parser version (${i.version}) doesn't match runtime version (14)`); var e = i.nodeNames.split(" "); this.minRepeatTerm = e.length; for (let t = 0; t < i.repeatNodeCount; t++)e.push(""); let r = Object.keys(i.topRules).map(t => i.topRules[t][1]), n = []; for (let t = 0; t < e.length; t++)n.push([]); function s(t, e, i) { n[t].push([e, e.deserialize(String(i))]) } if (i.nodeProps) for (var o of i.nodeProps) { let i = o[0]; "string" == typeof i && (i = z[i]); for (let e = 1; e < o.length;) { var a = o[e++]; if (0 <= a) s(a, i, o[e++]); else { var l = o[e + -a]; for (let t = -a; 0 < t; t--)s(o[e++], i, l); e++ } } } this.nodeSet = new wo(e.map((t, e) => vo.define({ name: e >= this.minRepeatTerm ? void 0 : t, id: e, props: n[e], top: -1 < r.indexOf(e), error: 0 == e, skipped: i.skippedNodes && -1 < i.skippedNodes.indexOf(e) }))), i.propSources && (this.nodeSet = this.nodeSet.extend(...i.propSources)), this.strict = !1, this.bufferLength = 1024; let h = SO(i.tokenData); this.context = i.context, this.specializerSpecs = i.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length); for (let t = 0; t < this.specializerSpecs.length; t++)this.specialized[t] = this.specializerSpecs[t].term; this.specializers = this.specializerSpecs.map(jO), this.states = SO(i.states, Uint32Array), this.data = SO(i.stateData), this.goto = SO(i.goto), this.maxTerm = i.maxTerm, this.tokenizers = i.tokenizers.map(t => "number" == typeof t ? new $O(h, t) : t), this.topRules = i.topRules, this.dialects = i.dialects || {}, this.dynamicPrecedences = i.dynamicPrecedences || null, this.tokenPrecTable = i.tokenPrec, this.termNames = i.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]] } createParse(t, e, i) { let r = new WO(this, t, e, i); for (var n of this.wrappers) r = n(r, t, e, i); return r } getGoto(e, i, r = !1) { var n = this.goto; if (i >= n[0]) return -1; for (let t = n[i + 1]; ;) { var s = n[t++], o = 1 & s, a = n[t++]; if (o && r) return a; for (var l = t + (s >> 1); t < l; t++)if (n[t] == e) return a; if (o) return -1 } } hasAction(r, n) { var s = this.data; for (let i = 0; i < 2; i++)for (let t = this.stateSlot(r, i ? 2 : 1), e; ; t += 3) { if (65535 == (e = s[t])) { if (1 != s[t + 1]) { if (2 == s[t + 1]) return _O(s, t + 2); break } e = s[t = _O(s, t + 2)] } if (e == n || 0 == e) return _O(s, t + 1) } return 0 } stateSlot(t, e) { return this.states[6 * t + e] } stateFlag(t, e) { return 0 < (this.stateSlot(t, 0) & e) } validAction(t, e) { return !!this.allActions(t, t => t == e || null) } allActions(e, i) { var t = this.stateSlot(e, 4); let r = t ? i(t) : void 0; for (let t = this.stateSlot(e, 1); null == r; t += 3) { if (65535 == this.data[t]) { if (1 != this.data[t + 1]) break; t = _O(this.data, t + 2) } r = i(_O(this.data, t + 1)) } return r } nextStates(e) { var r = []; for (let t = this.stateSlot(e, 1); ; t += 3) { if (65535 == this.data[t]) { if (1 != this.data[t + 1]) break; t = _O(this.data, t + 2) } if (0 == (1 & this.data[t + 2])) { let i = this.data[t + 1]; r.some((t, e) => 1 & e && t == i) || r.push(this.data[t], i) } } return r } configure(r) { let n = Object.assign(Object.create(Vp.prototype), this); if (r.props && (n.nodeSet = this.nodeSet.extend(...r.props)), r.top) { var t = this.topRules[r.top]; if (!t) throw new RangeError("Invalid top rule name " + r.top); n.top = t } return r.tokenizers && (n.tokenizers = this.tokenizers.map(e => { var t = r.tokenizers.find(t => t.from == e); return t ? t.to : e })), r.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((e, t) => { var i = r.specializers.find(t => t.from == e.external); return i ? (i = Object.assign(Object.assign({}, e), { external: i.to }), n.specializers[t] = jO(i), i) : e })), r.contextTracker && (n.context = r.contextTracker), r.dialect && (n.dialect = this.parseDialect(r.dialect)), null != r.strict && (n.strict = r.strict), r.wrap && (n.wrappers = n.wrappers.concat(r.wrap)), null != r.bufferLength && (n.bufferLength = r.bufferLength), n } hasWrappers() { return 0 < this.wrappers.length } getName(t) { return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t) } get eofTerm() { return this.maxNode + 1 } get topNode() { return this.nodeSet.types[this.top[1]] } dynamicPrecedence(t) { var e = this.dynamicPrecedences; return null != e && e[t] || 0 } parseDialect(t) { var r = Object.keys(this.dialects), e = r.map(() => !1); if (t) for (var i of t.split(" ")) { i = r.indexOf(i); 0 <= i && (e[i] = !0) } let n = null; for (let i = 0; i < r.length; i++)if (!e[i]) for (let t = this.dialects[r[i]], e; 65535 != (e = this.data[t++]);)(n = n || new Uint8Array(this.maxTerm + 1))[e] = 1; return new MO(t, e, n) } static deserialize(t) { return new Vp(t) } }; function _O(t, e) { return t[e] | t[e + 1] << 16 } function jO(r) { if (r.external) { let i = r.extend ? 1 : 0; return (t, e) => r.external(t, e) << 1 | i } return r.get } var EO = 22, DO = 23, zO = 24, BO = 26, GO = 27, IO = { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0, menuitem: !0 }, NO = { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 }, UO = { dd: { dd: !0, dt: !0 }, dt: { dd: !0, dt: !0 }, li: { li: !0 }, option: { option: !0, optgroup: !0 }, optgroup: { optgroup: !0 }, p: { address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0 }, rp: { rp: !0, rt: !0 }, rt: { rp: !0, rt: !0 }, tbody: { tbody: !0, tfoot: !0 }, td: { td: !0, th: !0 }, tfoot: { tbody: !0 }, th: { td: !0, th: !0 }, thead: { tbody: !0, tfoot: !0 }, tr: { tr: !0 } }; function LO(t) { return 9 == t || 10 == t || 13 == t || 32 == t } var FO = null, HO = null, JO = 0; function KO(t, e) { var i, r = t.pos + e; if (JO == r && HO == t) return FO; let n = t.peek(e); for (; LO(n);)n = t.peek(++e); let s = ""; for (; 45 == (i = n) || 46 == i || 58 == i || 65 <= i && i <= 90 || 95 == i || 97 <= i && i <= 122 || 161 <= i;)s += String.fromCharCode(n), n = t.peek(++e); return HO = t, JO = r, FO = s ? s.toLowerCase() : 63 == n || 33 == n ? void 0 : null } function tu(e, t) { this.name = e, this.parent = t, this.hash = t ? t.hash : 0; for (let t = 0; t < e.length; t++)this.hash += (this.hash << 4) + e.charCodeAt(t) + (e.charCodeAt(t) << 8) } var eu = [6, 10, 7, 8, 9], Qh = new Sh({ start: null, shift(t, e, i, r) { return -1 < eu.indexOf(e) ? new tu(KO(r, 1) || "", t) : t }, reduce(t, e) { return 20 == e && t ? t.parent : t }, reuse(t, e, i, r) { e = e.type.id; return 6 == e || 36 == e ? new tu(KO(r, 1) || "", t) : t }, hash(t) { return t ? t.hash : 0 }, strict: !1 }), e = new PO((t, e) => { if (60 != t.next) t.next < 0 && e.context && t.acceptToken(57); else { t.advance(); var i = 47 == t.next, r = (i && t.advance(), KO(t, 0)); if (void 0 !== r) { if (!r) return t.acceptToken(i ? 14 : 6); var n = e.context ? e.context.name : null; if (!i) return "script" == r ? t.acceptToken(7) : "style" == r ? t.acceptToken(8) : "textarea" == r ? t.acceptToken(9) : IO.hasOwnProperty(r) ? t.acceptToken(10) : void (n && UO[n] && UO[n][r] ? t.acceptToken(57, -1) : t.acceptToken(6)); if (r == n) return t.acceptToken(11); if (n && NO[n]) return t.acceptToken(57, -2); if (e.dialectEnabled(0)) return t.acceptToken(12); for (let t = e.context; t; t = t.parent)if (t.name == r) return; t.acceptToken(13) } } }, { contextual: !0 }), s = new PO(i => { for (let t = 0, e = 0; ; e++) { if (i.next < 0) { e && i.acceptToken(58); break } if (45 == i.next) t++; else { if (62 == i.next && 2 <= t) { 3 <= e && i.acceptToken(58, -2); break } t = 0 } i.advance() } }); o = new PO((t, e) => { 47 == t.next && 62 == t.peek(1) ? (e = e.dialectEnabled(1) || (t => { for (; t; t = t.parent)if ("svg" == t.name || "math" == t.name) return !0; return !1 })(e.context), t.acceptToken(e ? 5 : 4, 2)) : 62 == t.next && t.acceptToken(4, 1) }); function iu(n, s, o) { let a = 2 + n.length; return new PO(r => { for (let t = 0, e = 0, i = 0; ; i++) { if (r.next < 0) { i && r.acceptToken(s); break } if (0 == t && 60 == r.next || 1 == t && 47 == r.next || 2 <= t && t < a && r.next == n.charCodeAt(t - 2)) t++, e++; else if (2 != t && t != a || !LO(r.next)) { if (t == a && 62 == r.next) { i > e ? r.acceptToken(s, -e) : r.acceptToken(o, -(e - 2)); break } if ((10 == r.next || 13 == r.next) && i) { r.acceptToken(s, 1); break } t = e = 0 } else e++; r.advance() } }) } r = iu("script", 54, 1), l = iu("style", 55, 2), ca = iu("textarea", 56, 3), la = ea({ "Text RawText": Z.content, "StartTag StartCloseTag SelfClosingEndTag EndTag": Z.angleBracket, TagName: Z.tagName, "MismatchedCloseTag/TagName": [Z.tagName, Z.invalid], AttributeName: Z.attributeName, "AttributeValue UnquotedAttributeValue": Z.attributeValue, Is: Z.definitionOperator, "EntityReference CharacterReference": Z.character, Comment: Z.blockComment, ProcessingInst: Z.processingInstruction, DoctypeDecl: Z.documentMeta }), Ge = n.deserialize({ version: 14, states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z", stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~", goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp", nodeNames: "âš  StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl", maxTerm: 67, context: Qh, nodeProps: [["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"], ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"], ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"], ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]], propSources: [la], skippedNodes: [0], repeatNodeCount: 9, tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X", tokenizers: [r, l, ca, o, e, s, 0, 1, 2, 3, 4, 5], topRules: { Document: [0, 15] }, dialects: { noMatch: 0, selfClosing: 485 }, tokenPrec: 487 }); function ru(t, e) { var i, r = Object.create(null); for (i of t.getChildren(DO)) { var n = i.getChild(zO), s = i.getChild(BO) || i.getChild(GO); n && (r[e.read(n.from, n.to)] = s ? s.type.id == BO ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "") } return r } function nu(t, e) { t = t.getChild(EO); return t ? e.read(t.from, t.to) : " " } function su(t, e, i) { let r; for (var n of i) if (!n.attrs || n.attrs(r = r || ru(t.node.parent.firstChild, e))) return { parser: n.parser }; return null } function ou(t = [], e = []) { let c = [], d = [], O = [], u = []; for (var i of t) ("script" == i.tag ? c : "style" == i.tag ? d : "textarea" == i.tag ? O : u).push(i); let f = e.length ? Object.create(null) : null; for (var r of e) (f[r.name] || (f[r.name] = [])).push(r); return n = (n, s) => { var t = n.type.id; if (28 == t) return su(n, s, c); if (31 == t) return su(n, s, d); if (34 == t) return su(n, s, O); if (20 == t && u.length) { let t = n.node, e = t.firstChild, i = e && nu(e, s), r; if (i) for (var o of u) if (o.tag == i && (!o.attrs || o.attrs(r = r || ru(t, s)))) { var a = t.lastChild, a = 37 == a.type.id ? a.from : t.to; if (a > e.to) return { parser: o.parser, overlay: [{ from: e.to, to: a }] } } } if (f && t == DO) { var e = n.node; if (t = e.firstChild) { n = f[s.read(t.from, t.to)]; if (n) for (var i of n) if (!i.tagName || i.tagName == nu(e.parent, s)) { var r = e.lastChild; if (r.type.id == BO) { var l = r.from + 1, h = r.lastChild, h = r.to - (h && h.isError ? 0 : 1); if (l < h) return { parser: i.parser, overlay: [{ from: l, to: h }] } } else if (r.type.id == GO) return { parser: i.parser, overlay: [{ from: r.from, to: r.to }] } } } } return null }, (t, e, i, r) => new Go(t, n, e, i, r); var n } var au = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288]; function lu(t) { return 65 <= t && t <= 90 || 97 <= t && t <= 122 || 161 <= t } var Zh = new PO((r, n) => { for (let t = !1, e = 0, i = 0; ; i++) { var s = r.next; if (lu(s) || 45 == s || 95 == s || t && 48 <= (o = s) && o <= 57) !t && (45 != s || 0 < i) && (t = !0), e === i && 45 == s && e++, r.advance(); else { if (92 != s || 10 == r.peek(1)) { t && r.acceptToken(40 == s ? 97 : 2 == e && n.canShift(2) ? 2 : 98); break } r.advance(), -1 < r.next && r.advance(), t = !0 } } var o }), Ph = new PO(t => { var e; au.includes(t.peek(-1)) && (e = t.next, !lu(e) && 95 != e && 35 != e && 46 != e && 91 != e && 58 != e && 45 != e && 38 != e || t.acceptToken(96)) }), Ch = new PO(t => { if (!au.includes(t.peek(-1))) { var e = t.next; if (37 == e && (t.advance(), t.acceptToken(1)), lu(e)) { for (; t.advance(), lu(t.next);); t.acceptToken(1) } } }), aa = ea({ "AtKeyword import charset namespace keyframes media supports": Z.definitionKeyword, "from to selector": Z.keyword, NamespaceName: Z.namespace, KeyframeName: Z.labelName, KeyframeRangeName: Z.operatorKeyword, TagName: Z.tagName, ClassName: Z.className, PseudoClassName: Z.constant(Z.className), IdName: Z.labelName, "FeatureName PropertyName": Z.propertyName, AttributeName: Z.attributeName, NumberLiteral: Z.number, KeywordQuery: Z.keyword, UnaryQueryOp: Z.operatorKeyword, "CallTag ValueName": Z.atom, VariableName: Z.variableName, Callee: Z.operatorKeyword, Unit: Z.unit, "UniversalSelector NestingSelector": Z.definitionOperator, MatchOp: Z.compareOperator, "ChildOp SiblingOp, LogicOp": Z.logicOperator, BinOp: Z.arithmeticOperator, Important: Z.modifier, Comment: Z.blockComment, ColorLiteral: Z.color, "ParenthesizedContent StringLiteral": Z.string, ":": Z.punctuation, "PseudoOp #": Z.derefOperator, "; ,": Z.separator, "( )": Z.paren, "[ ]": Z.squareBracket, "{ }": Z.brace }), hu = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, cu = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, du = { __proto__: null, not: 128, only: 128 }, Vh = n.deserialize({ version: 14, states: "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c", stateData: ":k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~", goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`", nodeNames: "âš  Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles", maxTerm: 114, nodeProps: [["isolate", -2, 3, 24, ""], ["openedBy", 17, "(", 48, "{"], ["closedBy", 18, ")", 49, "}"]], propSources: [aa], skippedNodes: [0, 3, 85], repeatNodeCount: 10, tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}", tokenizers: [Ph, Ch, Zh, 1, 2, 3, 4, new i("m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~", 28, 102)], topRules: { StyleSheet: [0, 4], Styles: [1, 84] }, specialized: [{ term: 97, get: t => hu[t] || -1 }, { term: 56, get: t => cu[t] || -1 }, { term: 98, get: t => du[t] || -1 }], tokenPrec: 1169 }), Ou = null; function uu() { if (!Ou && "object" == typeof document && document.body) { var t, e = document.body.style, i = [], r = new Set; for (t in e) "cssText" != t && "cssFloat" != t && "string" == typeof e[t] && (/[A-Z]/.test(t) && (t = t.replace(/[A-Z]/g, t => "-" + t.toLowerCase())), r.has(t) || (i.push(t), r.add(t))); Ou = i.sort().map(t => ({ type: "property", label: t })) } return Ou || [] } var fu = ["active", "after", "any-link", "autofill", "backdrop", "before", "checked", "cue", "default", "defined", "disabled", "empty", "enabled", "file-selector-button", "first", "first-child", "first-letter", "first-line", "first-of-type", "focus", "focus-visible", "focus-within", "fullscreen", "has", "host", "host-context", "hover", "in-range", "indeterminate", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "marker", "modal", "not", "nth-child", "nth-last-child", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "part", "placeholder", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "selection", "slotted", "target", "target-text", "valid", "visited", "where"].map(t => ({ type: "class", label: t })), pu = ["above", "absolute", "activeborder", "additive", "activecaption", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "antialiased", "appworkspace", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic-abegede-gez", "ethiopic-halehame-aa-er", "ethiopic-halehame-gez", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "graytext", "grid", "groove", "hand", "hard-light", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "keep-all", "landscape", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lowercase", "ltr", "luminosity", "manipulation", "match", "matrix", "matrix3d", "medium", "menu", "menutext", "message-box", "middle", "min-intrinsic", "mix", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "text", "text-bottom", "text-top", "textarea", "textfield", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "to", "top", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-latin", "uppercase", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"].map(t => ({ type: "keyword", label: t })).concat(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"].map(t => ({ type: "constant", label: t }))), mu = ["a", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "figcaption", "figure", "footer", "form", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "meter", "nav", "ol", "output", "p", "pre", "ruby", "section", "select", "small", "source", "span", "strong", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "tr", "u", "ul"].map(t => ({ type: "type", label: t })), gu = /^(\w[\w-]*|-\w[\w-]*|)$/, vu = /^-(-[\w-]*)?$/; var wu = new ze, bu = ["Declaration"]; var yu = (a => t => { var e, i, { state: r, pos: n } = t, s = T(r).resolveInner(n, -1), o = s.type.isError && s.from == s.to - 1 && "-" == r.doc.sliceString(s.from, s.to); if ("PropertyName" == s.name || (o || "TagName" == s.name) && /^(Block|Styles)$/.test(s.resolve(s.to).name)) return { from: s.from, options: uu(), validFor: gu }; if ("ValueName" == s.name) return { from: s.from, options: pu, validFor: gu }; if ("PseudoClassName" == s.name) return { from: s.from, options: fu, validFor: gu }; if (a(s) || (t.explicit || o) && (i = s, e = r.doc, "ArgList" == (i = "(" != i.name && !i.type.isError ? i : i.parent || i).name && "Callee" == (null == (i = null == (i = i.parent) ? void 0 : i.firstChild) ? void 0 : i.name) ? "var" == e.sliceString(i.from, i.to) : void 0)) return { from: a(s) || o ? s.from : n, options: function t(n, e, s) { if (4096 < e.to - e.from) { var i = wu.get(e); if (i) return i; var r = [], o = new Set, a = e.cursor(P.IncludeAnonymous); if (a.firstChild()) do { for (var l of t(n, a.node, s)) o.has(l.label) || (o.add(l.label), r.push(l)) } while (a.nextSibling()); return wu.set(e, r), r } { let i = [], r = new Set; return e.cursor().iterate(t => { var e; s(t) && t.matchContext(bu) && ":" == (null == (e = t.node.nextSibling) ? void 0 : e.name) && (e = n.sliceString(t.from, t.to), r.has(e) || (r.add(e), i.push({ label: e, type: "variable" }))) }), i } }(r.doc, (e => { for (let t = e; ;) { if (t.type.isTop) return t; if (!(t = t.parent)) return e } })(s), a), validFor: vu }; if ("TagName" != s.name) return t.explicit ? (i = (e = s.resolve(n)).childBefore(n)) && ":" == i.name && "PseudoClassSelector" == e.name ? { from: n, options: fu, validFor: gu } : i && ":" == i.name && "Declaration" == e.name || "ArgList" == e.name ? { from: n, options: pu, validFor: gu } : "Block" == e.name || "Styles" == e.name ? { from: n, options: uu(), validFor: gu } : null : null; for (let t = s.parent; t; t = t.parent)if ("Block" == t.name) return { from: s.from, options: uu(), validFor: gu }; return { from: s.from, options: mu, validFor: gu } })(t => "VariableName" == t.name), Su = Le.define({ name: "css", parser: Vh.configure({ props: [Aa.add({ Declaration: qa() }), ja.add({ "Block KeyframeList": Ea })] }), languageData: { commentTokens: { block: { open: "/*", close: "*/" } }, indentOnInput: /^\s*\}$/, wordChars: "-" } }); var Qu = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288], Mh = new Sh({ start: !1, shift(t, e) { return 4 == e || 5 == e || 312 == e ? t : 313 == e }, strict: !1 }), Be = new PO((t, e) => { var i = t.next; 125 != i && -1 != i && !e.context || t.acceptToken(310) }, { contextual: !0, fallback: !0 }), ha = new PO((t, e) => { var i, r = t.next; -1 < Qu.indexOf(r) || 47 == r && (47 == (i = t.peek(1)) || 42 == i) || 125 == r || 59 == r || -1 == r || e.context || t.acceptToken(309) }, { contextual: !0 }), Ue = new PO((t, e) => { var i = t.next; 43 != i && 45 != i || (t.advance(), i == t.next && (t.advance(), i = !e.context && e.canShift(1), t.acceptToken(i ? 1 : 2))) }, { contextual: !0 }); function xu(t, e) { return 65 <= t && t <= 90 || 97 <= t && t <= 122 || 95 == t || 192 <= t || !e && 48 <= t && t <= 57 } var Gt = new PO((i, t) => { if (60 == i.next && t.dialectEnabled(0) && (i.advance(), 47 != i.next)) { let e = 0; for (; -1 < Qu.indexOf(i.next);)i.advance(), e++; if (xu(i.next, !0)) { for (i.advance(), e++; xu(i.next, !1);)i.advance(), e++; for (; -1 < Qu.indexOf(i.next);)i.advance(), e++; if (44 == i.next) return; for (let t = 0; ; t++) { if (7 == t) { if (xu(i.next, !0)) break; return } if (i.next != "extends".charCodeAt(t)) break; i.advance(), e++ } } i.acceptToken(3, -e) } }), Ne = ea({ "get set async static": Z.modifier, "for while do if else switch try catch finally return throw break continue default case": Z.controlKeyword, "in of await yield void typeof delete instanceof": Z.operatorKeyword, "let var const using function class extends": Z.definitionKeyword, "import export from": Z.moduleKeyword, "with debugger as new": Z.keyword, TemplateString: Z.special(Z.string), super: Z.atom, BooleanLiteral: Z.bool, this: Z.self, null: Z.null, Star: Z.modifier, VariableName: Z.variableName, "CallExpression/VariableName TaggedTemplateExpression/VariableName": Z.function(Z.variableName), VariableDefinition: Z.definition(Z.variableName), Label: Z.labelName, PropertyName: Z.propertyName, PrivatePropertyName: Z.special(Z.propertyName), "CallExpression/MemberExpression/PropertyName": Z.function(Z.propertyName), "FunctionDeclaration/VariableDefinition": Z.function(Z.definition(Z.variableName)), "ClassDeclaration/VariableDefinition": Z.definition(Z.className), PropertyDefinition: Z.definition(Z.propertyName), PrivatePropertyDefinition: Z.definition(Z.special(Z.propertyName)), UpdateOp: Z.updateOperator, "LineComment Hashbang": Z.lineComment, BlockComment: Z.blockComment, Number: Z.number, String: Z.string, Escape: Z.escape, ArithOp: Z.arithmeticOperator, LogicOp: Z.logicOperator, BitOp: Z.bitwiseOperator, CompareOp: Z.compareOperator, RegExp: Z.regexp, Equals: Z.definitionOperator, Arrow: Z.function(Z.punctuation), ": Spread": Z.punctuation, "( )": Z.paren, "[ ]": Z.squareBracket, "{ }": Z.brace, "InterpolationStart InterpolationEnd": Z.special(Z.brace), ".": Z.derefOperator, ", ;": Z.separator, "@": Z.meta, TypeName: Z.typeName, TypeDefinition: Z.definition(Z.typeName), "type enum interface implements namespace module declare": Z.definitionKeyword, "abstract global Privacy readonly override": Z.modifier, "is keyof unique infer": Z.operatorKeyword, JSXAttributeValue: Z.attributeValue, JSXText: Z.content, "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": Z.angleBracket, "JSXIdentifier JSXNameSpacedName": Z.tagName, "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": Z.attributeName, "JSXBuiltin/JSXIdentifier": Z.standard(Z.tagName) }), ku = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, $u = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, Pu = { __proto__: null, "<": 143 }, Ie = n.deserialize({ version: 14, states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>pQ08SO1G0{O#>wQ08SO1G0{O#@oQ08SO1G0{O#CoQ(CYO'#ChO#EmQ(CYO1G1^O#EtQ(CYO'#JjO!,lQWO1G1dO#FUQ08SO,5?TOOQ07`-E<g-E<gO#FxQ08SO1G0{OOQ07b1G0{1G0{O#ITQ08SO1G1aO#IwQ&jO,5<TO#JPQ&jO,5<UO#JXQ&jO'#FlO#JpQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#JuQ&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#KWQ(CYO'#JiO#KbQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KgQ`O'#J}OOQ07b,5<a,5<aO#KoQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KtO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LPQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LoQ7[O,5=RO!(SQ7[O'#IpO#MbQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MlQpO'#CqO#NPQpO,5<nO#NWQWO'#KRO9aQWO'#KRO#NfQWO,5<pO!(SQ7[O,5<oO#NkQWO'#GUO#NvQWO,5<oO#N{QpO'#GRO$ YQpO'#KSO$ dQWO'#KSO!&dQ7[O'#KSO$ iQWO,5<sO$ nQ`O'#G^O!4eQ`O'#G^O$!PQWO'#G`O$!UQWO'#GbO!3fQWO'#GeO$!ZQ07hO'#ImO$!fQ`O,5<wOOQ07f,5<w,5<wO$!mQ`O'#G^O$!{Q`O'#G_O$#TQ`O'#G_O$#YQ7[O,5=RO$#jQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$#zQWO'#IrO$$VQWO,5?|O$$_QWO,59`O$%OQ7[O,59qOOQ07b,59q,59qO$%qQ7[O,5<fO$&dQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&nQWO,5<qO$&sQ7[O,5<vO$'TQWO'#JuO!$aQ^O1G1}O$'YQWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'_Q07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)dQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+hQ7[O'#EgOOQ07`,5?{,5?{O$+rQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,TQWO1G0qO$,YQWO'#ChO$,eQWO'#K[O$,mQWO,5=uO$,rQWO'#K[O$,wQWO'#K[O$-VQWO'#IzO$-eQWO,5@uO$-mQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-tQWO1G3`O$-yQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.OQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.TQWO1G2|O$.]Q`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.eQ7[O,5=nO9aQWO,5=nO$!UQWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.sQWO'#KYO$/OQWO,5=qOOQU1G.j1G.jO$/TQ07hO1G.jO@bQWO1G.jO$/`QWO1G.jO9kQ07hO1G.jO$1eQrO,5@wO$1uQWO,5@wO9ZQWO,5@wO$2QQ^O,5=xO$2XQWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2^Q^O1G3nO$6bQ^O'#HmOOQU1G3q1G3qO$6oQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6wQ^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;OQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;TQ(CYO,5:UOOQO,5;[,5;[O$;_Q`O'#I^O$;uQWO,5@WOOQ07b1G/o1G/oO$;}Q`O'#IdO$<XQWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<aQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<hQ07hO1G0iO$<sQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=RQ07hO1G0iOOQO1G0]1G0]O$=gQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=qQpO,5<eO$=yQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>TQWO1G5qO$>]QWO1G6OO$>eQrO1G6PO9ZQWO,5>}O$>oQ08SO1G5|O%[Q^O1G5|O$?PQ07hO1G5|O$?bQWO1G5{O$?bQWO1G5{O9ZQWO1G5{O$?jQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@OQWO,5?QO$'TQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@^QWO7+(_O$@iQ7[O7+(_O$@wQ08SO,5=RO$CSQ08SO,5=TO$E_Q08SO,5=RO$GpQ08SO,5=TO$JRQ08SO,59qO$LZQ08SO,5<fO$NfQ08SO,5<hO%!qQ08SO,5<vOOQ07b7+&]7+&]O%%SQ08SO7+&]O%%vQ7[O'#I_O%&QQWO,5@YOOQ07b1G/y1G/yO%&YQ^O'#I`O%&gQWO,5@ZO%&oQrO,5@ZOOQ07b1G0O1G0OO%&yQWO7+&fOOQ07b7+&f7+&fO%'OQ(CYO,5:eO%[Q^O7+&xO%'YQ(CYO,5:]O%'gQ(CYO,5:iO%'qQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%'{QtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(WQWO1G1yOOQ07b1G1{1G1{O%(]QpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(dQ08SO7+'hOOQ07b,5?V,5?VO%)WQpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)vQ7[O,5?YOOQ07b-E<l-E<lO%*iQ7[O,5?[OOQ07b-E<n-E<nO%*sQpO1G2qOOQ07b1G2Y1G2YO%*zQWO'#IjO%+YQWO,5@mO%+YQWO,5@mO%+bQWO,5@mO%+mQWO,5@mOOQO1G2[1G2[O%+{Q7[O1G2ZO!(SQ7[O1G2ZO%,]Q!LQO'#IlO%,mQWO,5@nO!&dQ7[O,5@nO%,uQpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'TQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-PQWO,5<zOOQ07`,5<|,5<|O$'TQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-XQWO,5<yO$!PQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%-{Q7[O1G2mO!(SQ7[O'#IpO%.nQ7[O1G2oO%.xQ7[O1G5iO%/SQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/aQWO1G2UO!(SQ7[O1G2]O%/fQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0YQWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0_QpO'#KTO#%sQWO7+(_O%0iQrO7+(_O$@aQWO7+(_O%0pQ08QO'#ChO%1TQ08QO,5<}O%1uQWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%1zQWO'#IyO%2cQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2cQWO,5@vO%2kQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2pQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2uQ08QO7+(gO!&dQ7[O7+(gO%3PQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3WQWO'#KXO%3cQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4rQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%4yQWO1G3YO%5UQ7[O1G3YO9kQ07hO1G3[O$!UQWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5dQWO'#IxO%5xQWO,5@tO%6QQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6]QWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6bQ07hO1G6cO%6lQ^O1G3dO%6sQWO1G3dO%6xQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7PQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7^QWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7cQ`O1G5sO%7wQ(CYO1G0vO%8RQWO1G0vOOQO1G/p1G/pO%8^Q(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=gQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8hQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8sQ07hO7+&TO%9RQ08SO7++hO%[Q^O7++hO%9cQWO7++gO%9cQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9kQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0iQrO<<KyO%9yQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:RQWO<<KyO%:^Q08SO,5?YO%<iQ08SO,5?[O%>tQ08SO1G2ZO%AVQ08SO1G2mO%CbQ08SO1G2oO%EmQ7[O,5>yOOQO-E<]-E<]O%EwQrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FRQWO1G5uOOQ07b<<JQ<<JQO%FZQ(CYO1G0qO%HeQ(CYO1G0{O%HlQ(CYO1G0{O%JpQ(CYO1G0{O%JwQ(CYO1G0{O%LlQ(CYO1G0{O%MSQ(CYO1G0{O& gQ(CYO1G0{O& nQ(CYO1G0{O&#rQ(CYO1G0{O&#yQ(CYO1G0{O&%qQ(CYO1G0{O&&UQ08SO<<JdO&'ZQ(CYO1G0{O&)PQ(CYO'#JdO&+SQ(CYO1G1aO&+aQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+kQWO1G1qO&+pQ(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&+zQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,YQWO1G6XO&,YQWO1G6XO&,bQWO1G6XO&,mQ7[O7+'uO&,}QpO,5?WO&-XQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-^QpO1G6YO&-hQWO1G6YOOQ07`1G2e1G2eO$'TQWO1G2eOOQ07`1G2d1G2dO&-pQWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&-uQWO1G2fO&-}QWO1G2eO&.qQ7[O,5?YOOQ07b-E<m-E<mO&/dQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/nQWO1G/_OOQ07b7+'p7+'pO&/sQ7[O7+'wO&0TQ08SO<<KTOOQ07b<<KT<<KTO&0wQWO1G0vO!&dQ7[O'#IsO&0|QWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1UQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&1xQWO,5?eO&1}QWO,5?eOOQO-E<w-E<wO&2]QWO1G6bO&2]QWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2eQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2uQ08QO<<LROOQU<<LS<<LSO%3PQpO<<LSO&2jQ`O'#IuO&2uQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&2}Q^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3XQ`O,5=oOOQU,5=o,5=oO&3`Q`O'#EcO&3tQWO7+(tO&3yQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4RQWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$!UQWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4^QWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4iQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4qQWO7++}O&4vQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&4{QWO7+)OO&5QQ^O7+)OO&5XQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5^QWO,5>YOOQU,5>[,5>[O&5cQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5hQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=gQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&5rQ07hO<<IoO&5}Q08SO<= SO&6_QWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6gQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0iQrOANAeO%[Q^OANAeO&6oQ08SO7+'uO&9QQ08SO,5?YO&;]Q08SO,5?[O&=hQ08SO7+'wO&?yQrO1G4fO&@TQ(CYO7+&]O&BXQ(CYO,5=RO&D`Q(CYO,5=TO&DpQ(CYO,5=RO&EQQ(CYO,5=TO&EbQ(CYO,59qO&GeQ(CYO,5<fO&IhQ(CYO,5<hO&KkQ(CYO,5<vO&MaQ(CYO7+'hO&MnQ(CYO7+'iO&M{QWO,5<YOOQO7+']7+']O&NQQ7[O<<KwOOQO1G4p1G4pO&NXQWO1G4pO&NdQWO1G4pO&NrQWO7++sO&NrQWO7++sO!&dQ7[O1G4rO&NzQpO1G4rO' UQWO7++tOOQ07`7+(P7+(PO$'TQWO7+(QO' ^QpO7+(QOOQ07`7+(O7+(OO$'TQWO7+(PO' eQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' jQ7[O<<NoOOQ07b7+$y7+$yO' tQpO,5?_OOQO-E<q-E<qO'!OQ08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!`QWO1G5PO'!eQWO7++|O'!eQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!mQWO,5?aOOQO-E<s-E<sO'!xQ(CYO1G6_O'%YQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&2}Q^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&3tQWO<<L`O'%dQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$!UQWO<<LbO9UQWO<<LbO'%lQ`O1G5OO'%wQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&PQWO<= iO'&UQWO<= jOOQU<<Lj<<LjO'&ZQWO<<LjO'&`Q^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&gQWO<<I|O'&rQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=gQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO'&|QWOG27PO%0iQrOG27PO''UQ(CYO<<JdO''cQ(CYO1G2ZO')XQ(CYO,5?YO'+[Q(CYO,5?[O'-_Q(CYO1G2mO'/bQ(CYO1G2oO'1eQ(CYO<<KTO'1rQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2PQWO7+*[O'2[QWO<= _O'2dQpO7+*^OOQ07`<<Kl<<KlO$'TQWO<<KlOOQ07`<<Kk<<KkO'2nQpO<<KlO$'TQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'2uQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'2}QWO7++yO&3tQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3VQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$!UQWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3_QWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=gQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3dQWOLD,kO'3lQ(CYO7+'uO'5bQ(CYO,5?YO'7eQ(CYO,5?[O'9hQ(CYO7+'wO';^Q7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'TQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';nQ(CYO7+*gOOQUG27fG27fO&3tQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO';xQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<SQ08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&3tQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>eQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@ZQrO'#JiO!*fQ^O'#DqO'@bQ^O'#D}O'@iQrO'#ChO'CPQrO'#ChO!*fQ^O'#EPO'CaQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EdQWO,5<eO'ElQ7[O,5;aO'GVQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ElQ7[O'#GgO!&dQ7[O'#GiO'ElQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ElQ7[O'#FzO!&dQ7[O'#F|O'ElQ7[O'#F|O!&dQ7[O'#G[O'ElQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CaQ^O1G0qO'G^Q(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O,5<oO'ElQ7[O,5<oO'CaQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ElQ7[O1G2ZO!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O1G2]O'ElQ7[O1G2]O'CaQ^O7+'iO'CaQ^O7+&]O!&dQ7[OANAcO'ElQ7[OANAcO'GhQWO'#EkO'GmQWO'#EkO'GuQWO'#FZO'GzQWO'#EuO'HPQWO'#JyO'H[QWO'#JwO'HgQWO,5;VO'HlQ7[O,5<bO'HsQWO'#GTO'HxQWO'#GTO'H}QWO,5<cO'IVQWO,5;VO'I_Q(CYO1G1^O'IfQWO,5<oO'IkQWO,5<oO'IpQWO,5<qO'IuQWO,5<qO'IzQWO1G1}O'JPQWO1G0qO'JUQ7[O<<KwO'J]Q7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*sQpO1G2qO%*sQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V", stateData: "'Ka~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#v#ii#x#ii#y#ii'r#ii(h#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(o#ii~P#9lO(o#|O~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO(XVO(o#|O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(p#ii~P#<^O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?OOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AiOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#CvO#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#CvO!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#LWO(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#LyO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$dO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%YO|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$%{O#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'jOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*TO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/kO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#CvOo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#LWO#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#LyO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$dO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%YO#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$%{O#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#CvO#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)_O|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*QO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-dO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.VOf(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3hOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#CvO#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#CvO`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)_O#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*QO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-dO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.VOf'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#CvOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FhO#j:lO~P%FhOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HsOn:nO~P%HsOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KOOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KOOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#v#ii#x#ii#y#ii#|#ii(h#ii(p#ii!Y#ii!Z#ii~O(o#ii~P%MjO(o#|O~P%MjOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO(XVO(o#|O#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O(p#ii~P& uO(p#}O~P& uOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$QO`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&&xO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#CvO#|!qi!Z!qi~P$'jO!Z6|O~O!Y']a!Z']a~P#CvO!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.YO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&.{O!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3hOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#CvO`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.YO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&.{O#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#CvO(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@bO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BiOj<gO|)zO!P){O(p%PO~P&@bOj<gO|)zO!P){O(o$}O~P&BiO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&&xO#|$jq!Y$jq!Z$jq~P#CvO#|$kq!Y$kq!Z$kq~P#CvO!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#CvOP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#SO![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#CvO!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#CvOP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&&xO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#CvO#|#_y!Y#_y!Z#_y~P#CvO!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&&xO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&&xOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#CvO!Y#d!Z!Z#d!Z~P#CvO#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&&xOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#SOP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'@vOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ElO!Z[X!ZeX~P'@vO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#CvO#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~", goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AuPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!f$Uc#X%n'|(S(n(u)U)V)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:r)Z)l-O.t2W2Z3_3g3h3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!b$Wc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:t)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z", nodeNames: "âš  ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem", maxTerm: 371, context: Mh, nodeProps: [["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"], ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"], ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]], propSources: [Ne], skippedNodes: [0, 4, 5, 271], repeatNodeCount: 37, tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr", tokenizers: [ha, Ue, Gt, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, Be, new i("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new i("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)], topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] }, dialects: { jsx: 0, ts: 14602 }, dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 }, specialized: [{ term: 319, get: t => ku[t] || -1 }, { term: 334, get: t => $u[t] || -1 }, { term: 70, get: t => Pu[t] || -1 }], tokenPrec: 14626 }), Zu = [Yd("function ${name}(${params}) {\n\t${}\n}", { label: "function", detail: "definition", type: "keyword" }), Yd("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", { label: "for", detail: "loop", type: "keyword" }), Yd("for (let ${name} of ${collection}) {\n\t${}\n}", { label: "for", detail: "of loop", type: "keyword" }), Yd("do {\n\t${}\n} while (${})", { label: "do", detail: "loop", type: "keyword" }), Yd("while (${}) {\n\t${}\n}", { label: "while", detail: "loop", type: "keyword" }), Yd("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", { label: "try", detail: "/ catch block", type: "keyword" }), Yd("if (${}) {\n\t${}\n}", { label: "if", detail: "block", type: "keyword" }), Yd("if (${}) {\n\t${}\n} else {\n\t${}\n}", { label: "if", detail: "/ else block", type: "keyword" }), Yd("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", { label: "class", detail: "definition", type: "keyword" }), Yd('import {${names}} from "${module}"\n${}', { label: "import", detail: "named", type: "keyword" }), Yd('import ${name} from "${module}"\n${}', { label: "import", detail: "default", type: "keyword" })], Tu = Zu.concat([Yd("interface ${name} {\n\t${}\n}", { label: "interface", detail: "definition", type: "keyword" }), Yd("type ${name} = ${type}", { label: "type", detail: "definition", type: "keyword" }), Yd("enum ${name} {\n\t${}\n}", { label: "enum", detail: "definition", type: "keyword" })]), Cu = new ze, Xu = new Set(["Script", "Block", "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration", "ForStatement"]); function Au(i) { return (t, e) => { t = t.node.getChild("VariableDefinition"); return t && e(t, i), !0 } } var Ru = ["FunctionDeclaration"], Yu = { FunctionDeclaration: Au("function"), ClassDeclaration: Au("class"), ClassExpression: () => !0, EnumDeclaration: Au("constant"), TypeAliasDeclaration: Au("type"), NamespaceDeclaration: Au("namespace"), VariableDefinition(t, e) { t.matchContext(Ru) || e(t, "variable") }, TypeDefinition(t, e) { e(t, "type") }, __proto__: null }; var Wu = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, Vu = ["TemplateString", "String", "RegExp", "LineComment", "BlockComment", "VariableDefinition", "TypeDefinition", "Label", "PropertyDefinition", "PropertyName", "PrivatePropertyDefinition", "PrivatePropertyName", ".", "?."]; function Mu(e) { var i = T(e.state).resolveInner(e.pos, -1); if (-1 < Vu.indexOf(i.name)) return null; var t = "VariableName" == i.name || i.to - i.from < 20 && Wu.test(e.state.sliceDoc(i.from, i.to)); if (!t && !e.explicit) return null; let r = []; for (let t = i; t; t = t.parent)Xu.has(t.name) && (r = r.concat(function r(n, t) { var e = Cu.get(t); if (e) return e; let s = [], o = !0; function a(t, e) { t = n.sliceString(t.from, t.to), s.push({ label: t, type: e }) } return t.cursor(P.IncludeAnonymous).iterate(t => { if (o) o = !1; else if (t.name) { var e = Yu[t.name]; if (e && e(t, a) || Xu.has(t.name)) return !1 } else if (8192 < t.to - t.from) { for (var i of r(n, t.node)) s.push(i); return !1 } }), Cu.set(t, s), s }(e.state.doc, t))); return { options: r, from: t ? i.from : e.pos, validFor: Wu } } var qu = Le.define({ name: "javascript", parser: Ie.configure({ props: [Aa.add({ IfStatement: qa({ except: /^\s*({|else\b)/ }), TryStatement: qa({ except: /^\s*({|catch\b|finally\b)/ }), LabeledStatement: t => t.baseIndent, SwitchBody: t => { var e = t.textAfter, i = /^\s*\}/.test(e), e = /^\s*(case|default)\b/.test(e); return t.baseIndent + (i ? 0 : e ? 1 : 2) * t.unit }, Block: Va({ closing: "}" }), ArrowFunction: t => t.baseIndent + t.unit, "TemplateString BlockComment": () => null, "Statement Property": qa({ except: /^{/ }), JSXElement(t) { var e = /^\s*<\//.test(t.textAfter); return t.lineIndent(t.node.from) + (e ? 0 : t.unit) }, JSXEscape(t) { var e = /\s*\}/.test(t.textAfter); return t.lineIndent(t.node.from) + (e ? 0 : t.unit) }, "JSXOpenTag JSXSelfClosingTag"(t) { return t.column(t.node.from) + t.unit } }), ja.add({ "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Ea, BlockComment(t) { return { from: t.from + 2, to: t.to - 2 } } })] }), languageData: { closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }, commentTokens: { line: "//", block: { open: "/*", close: "*/" } }, indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/, wordChars: "$" } }), _u = { test: t => /^JSX/.test(t.name), facet: Oa({ commentTokens: { block: { open: "{/*", close: "*/}" } } }) }, ju = qu.configure({ dialect: "ts" }, "typescript"), Eu = qu.configure({ dialect: "jsx", props: [ua.add(t => t.isTop ? [_u] : void 0)] }), Du = qu.configure({ dialect: "jsx ts", props: [ua.add(t => t.isTop ? [_u] : void 0)] }, "typescript"), Qh = t => ({ label: t, type: "keyword" }), zu = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(Qh), Bu = zu.concat(["declare", "implements", "private", "protected", "public"].map(Qh)); function Gu(t = {}) { var i, r, e = t.jsx ? t.typescript ? Du : Eu : t.typescript ? ju : qu, n = t.typescript ? Tu.concat(Bu) : Zu.concat(zu); return new ka(e, [qu.data.of({ autocomplete: (i = Vu, r = Ec(n), e => { for (let t = T(e.state).resolveInner(e.pos, -1); t; t = t.parent) { if (-1 < i.indexOf(t.name)) return null; if (t.type.isTop) break } return r(e) }) }), qu.data.of({ autocomplete: Mu }), t.jsx ? Lu : []]) } function Iu(e, i, r = e.length) { for (let t = null == i ? void 0 : i.firstChild; t; t = t.nextSibling)if ("JSXIdentifier" == t.name || "JSXBuiltin" == t.name || "JSXNamespacedName" == t.name || "JSXMemberExpression" == t.name) return e.sliceString(t.from, Math.min(t.to, r)); return "" } var Nu, Uu = "object" == typeof navigator && /Android\b/.test(navigator.userAgent), Lu = $.inputHandler.of((t, e, i, a, r) => { if ((Uu ? t.composing : t.compositionStarted) || t.state.readOnly || e != i || ">" != a && "/" != a || !qu.isActiveAt(t.state, e, -1)) return !1; let n = r(), l = n.state; i = l.changeByRange(t => { let e, i = t.head, r = T(l).resolveInner(i - 1, -1), n; if ("JSXStartTag" == r.name && (r = r.parent), !(l.doc.sliceString(i - 1, i) != a || "JSXAttributeValue" == r.name && r.to > i)) { if (">" == a && "JSXFragmentTag" == r.name) return { range: t, changes: { from: i, insert: "</>" } }; if ("/" == a && "JSXStartCloseTag" == r.name) { var s = r.parent, o = s.parent; if (o && s.from == i - 2 && ((n = Iu(l.doc, o.firstChild, i)) || "JSXFragmentTag" == (null == (e = o.firstChild) ? void 0 : e.name))) return s = n + ">", { range: g.cursor(i + s.length, -1), changes: { from: i, insert: s } } } else if (">" == a) { o = (t => { for (; ;) { if ("JSXOpenTag" == t.name || "JSXSelfClosingTag" == t.name || "JSXFragmentTag" == t.name) return t; if ("JSXEscape" == t.name || !t.parent) return null; t = t.parent } })(r); if (o && !/^\/?>|^<\//.test(l.doc.sliceString(i, i + 2)) && (n = Iu(l.doc, o, i))) return { range: t, changes: { from: i, insert: `</${n}>` } } } } return { range: t } }); return !i.changes.empty && (t.dispatch([n, l.update(i, { userEvent: "input.complete", scrollIntoView: !0 })]), !0) }), la = ["_blank", "_self", "_top", "_parent"], r = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], l = ["get", "post", "put", "delete"], ca = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], o = ["true", "false"], e = {}, Fu = { a: { attrs: { href: null, ping: null, type: null, media: null, target: la, hreflang: null } }, abbr: e, address: e, area: { attrs: { alt: null, coords: null, href: null, target: null, ping: null, media: null, hreflang: null, type: null, shape: ["default", "rect", "circle", "poly"] } }, article: e, aside: e, audio: { attrs: { src: null, mediagroup: null, crossorigin: ["anonymous", "use-credentials"], preload: ["none", "metadata", "auto"], autoplay: ["autoplay"], loop: ["loop"], controls: ["controls"] } }, b: e, base: { attrs: { href: null, target: la } }, bdi: e, bdo: e, blockquote: { attrs: { cite: null } }, body: e, br: e, button: { attrs: { form: null, formaction: null, name: null, value: null, autofocus: ["autofocus"], disabled: ["autofocus"], formenctype: ca, formmethod: l, formnovalidate: ["novalidate"], formtarget: la, type: ["submit", "reset", "button"] } }, canvas: { attrs: { width: null, height: null } }, caption: e, center: e, cite: e, code: e, col: { attrs: { span: null } }, colgroup: { attrs: { span: null } }, command: { attrs: { type: ["command", "checkbox", "radio"], label: null, icon: null, radiogroup: null, command: null, title: null, disabled: ["disabled"], checked: ["checked"] } }, data: { attrs: { value: null } }, datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } }, datalist: { attrs: { data: null } }, dd: e, del: { attrs: { cite: null, datetime: null } }, details: { attrs: { open: ["open"] } }, dfn: e, div: e, dl: e, dt: e, em: e, embed: { attrs: { src: null, type: null, width: null, height: null } }, eventsource: { attrs: { src: null } }, fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } }, figcaption: e, figure: e, footer: e, form: { attrs: { action: null, name: null, "accept-charset": r, autocomplete: ["on", "off"], enctype: ca, method: l, novalidate: ["novalidate"], target: la } }, h1: e, h2: e, h3: e, h4: e, h5: e, h6: e, head: { children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"] }, header: e, hgroup: e, hr: e, html: { attrs: { manifest: null } }, i: e, iframe: { attrs: { src: null, srcdoc: null, name: null, width: null, height: null, sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"], seamless: ["seamless"] } }, img: { attrs: { alt: null, src: null, ismap: null, usemap: null, width: null, height: null, crossorigin: ["anonymous", "use-credentials"] } }, input: { attrs: { alt: null, dirname: null, form: null, formaction: null, height: null, list: null, max: null, maxlength: null, min: null, name: null, pattern: null, placeholder: null, size: null, src: null, step: null, value: null, width: null, accept: ["audio/*", "video/*", "image/*"], autocomplete: ["on", "off"], autofocus: ["autofocus"], checked: ["checked"], disabled: ["disabled"], formenctype: ca, formmethod: l, formnovalidate: ["novalidate"], formtarget: la, multiple: ["multiple"], readonly: ["readonly"], required: ["required"], type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button"] } }, ins: { attrs: { cite: null, datetime: null } }, kbd: e, keygen: { attrs: { challenge: null, form: null, name: null, autofocus: ["autofocus"], disabled: ["disabled"], keytype: ["RSA"] } }, label: { attrs: { for: null, form: null } }, legend: e, li: { attrs: { value: null } }, link: { attrs: { href: null, type: null, hreflang: null, media: null, sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"] } }, map: { attrs: { name: null } }, mark: e, menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } }, meta: { attrs: { content: null, charset: r, name: ["viewport", "application-name", "author", "description", "generator", "keywords"], "http-equiv": ["content-language", "content-type", "default-style", "refresh"] } }, meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } }, nav: e, noscript: e, object: { attrs: { data: null, type: null, name: null, usemap: null, form: null, width: null, height: null, typemustmatch: ["typemustmatch"] } }, ol: { attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] }, children: ["li", "script", "template", "ul", "ol"] }, optgroup: { attrs: { disabled: ["disabled"], label: null } }, option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } }, output: { attrs: { for: null, form: null, name: null } }, p: e, param: { attrs: { name: null, value: null } }, pre: e, progress: { attrs: { value: null, max: null } }, q: { attrs: { cite: null } }, rp: e, rt: e, ruby: e, samp: e, script: { attrs: { type: ["text/javascript"], src: null, async: ["async"], defer: ["defer"], charset: r } }, section: e, select: { attrs: { form: null, name: null, size: null, autofocus: ["autofocus"], disabled: ["disabled"], multiple: ["multiple"] } }, slot: { attrs: { name: null } }, small: e, source: { attrs: { src: null, type: null, media: null } }, span: e, strong: e, style: { attrs: { type: ["text/css"], media: null, scoped: null } }, sub: e, summary: e, sup: e, table: e, tbody: e, td: { attrs: { colspan: null, rowspan: null, headers: null } }, template: e, textarea: { attrs: { dirname: null, form: null, maxlength: null, name: null, placeholder: null, rows: null, cols: null, autofocus: ["autofocus"], disabled: ["disabled"], readonly: ["readonly"], required: ["required"], wrap: ["soft", "hard"] } }, tfoot: e, th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } }, thead: e, time: { attrs: { datetime: null } }, title: e, tr: e, track: { attrs: { src: null, label: null, default: null, kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"], srclang: null } }, ul: { children: ["li", "script", "template", "ul", "ol"] }, var: e, video: { attrs: { src: null, poster: null, width: null, height: null, crossorigin: ["anonymous", "use-credentials"], preload: ["auto", "metadata", "none"], autoplay: ["autoplay"], mediagroup: ["movie"], muted: ["muted"], controls: ["controls"] } }, wbr: e }, Hu = { accesskey: null, class: null, contenteditable: o, contextmenu: null, dir: ["ltr", "rtl", "auto"], draggable: ["true", "false", "auto"], dropzone: ["copy", "move", "link", "string:", "file:"], hidden: ["hidden"], id: null, inert: ["inert"], itemid: null, itemprop: null, itemref: null, itemscope: ["itemscope"], itemtype: null, lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"], spellcheck: o, autocorrect: o, autocapitalize: o, style: null, tabindex: null, title: null, translate: ["yes", "no"], rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"], role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "), "aria-activedescendant": null, "aria-atomic": o, "aria-autocomplete": ["inline", "list", "both", "none"], "aria-busy": o, "aria-checked": ["true", "false", "mixed", "undefined"], "aria-controls": null, "aria-describedby": null, "aria-disabled": o, "aria-dropeffect": null, "aria-expanded": ["true", "false", "undefined"], "aria-flowto": null, "aria-grabbed": ["true", "false", "undefined"], "aria-haspopup": o, "aria-hidden": o, "aria-invalid": ["true", "false", "grammar", "spelling"], "aria-label": null, "aria-labelledby": null, "aria-level": null, "aria-live": ["off", "polite", "assertive"], "aria-multiline": o, "aria-multiselectable": o, "aria-owns": null, "aria-posinset": null, "aria-pressed": ["true", "false", "mixed", "undefined"], "aria-readonly": o, "aria-relevant": null, "aria-required": o, "aria-selected": ["true", "false", "undefined"], "aria-setsize": null, "aria-sort": ["ascending", "descending", "none", "other"], "aria-valuemax": null, "aria-valuemin": null, "aria-valuenow": null, "aria-valuetext": null }, s = "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map(t => "on" + t); for (Nu of s) Hu[Nu] = null; var Ju = class { constructor(t, e) { this.tags = Object.assign(Object.assign({}, Fu), t), this.globalAttrs = Object.assign(Object.assign({}, Hu), e), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs) } }; function Ku(t, e, i = t.length) { return (e = (e = e && e.firstChild) && e.getChild("TagName")) ? t.sliceString(e.from, Math.min(e.to, i)) : "" } function tf(t, e = !1) { for (; t; t = t.parent)if ("Element" == t.name) { if (!e) return t; e = !1 } return null } function ef(t, e, i) { t = i.tags[Ku(t, tf(e))]; return (null == t ? void 0 : t.children) || i.allTags } function rf(e, i) { var r = []; for (let t = tf(i); t && !t.type.isTop; t = tf(t.parent)) { var n = Ku(e, t); if (n && "CloseTag" == t.lastChild.name) break; n && r.indexOf(n) < 0 && ("EndTag" == i.name || i.from >= t.firstChild.to) && r.push(n) } return r } Ju.default = new Ju; var nf = /^[:\-\.\w\u00b7-\uffff]*$/; function sf(t, e, i, r, n) { let s = /\s*>/.test(t.sliceDoc(n, n + 5)) ? "" : ">"; var o = tf(i, !0); return { from: r, to: n, options: ef(t.doc, o, e).map(t => ({ label: t, type: "type" })).concat(rf(t.doc, i).map((t, e) => ({ label: "/" + t, apply: "/" + t + s, type: "type", boost: 99 - e }))), validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/ } } function of(t, e, i, r) { let n = /\s*>/.test(t.sliceDoc(r, r + 5)) ? "" : ">"; return { from: i, to: r, options: rf(t.doc, e).map((t, e) => ({ label: t, apply: t + n, type: "type", boost: 99 - e })), validFor: nf } } function af(i, r) { let { state: o, pos: a } = r, l = T(o).resolveInner(a, -1), n = l.resolve(a); for (let t = a, e; n == l && (e = l.childBefore(t));) { var s = e.lastChild; if (!s || !s.type.isError || s.from < s.to) break; n = l = e, t = s.from } if ("TagName" == l.name) return l.parent && /CloseTag$/.test(l.parent.name) ? of(o, l, l.from, a) : sf(o, i, l, l.from, a); if ("StartTag" == l.name) return sf(o, i, l, a, a); if ("StartCloseTag" == l.name || "IncompleteCloseTag" == l.name) return of(o, l, a, a); if (r.explicit && ("OpenTag" == l.name || "SelfClosingTag" == l.name) || "AttributeName" == l.name) return t = o, f = i, p = l, m = "AttributeName" == l.name ? l.from : a, e = a, p = tf(p), t = p ? f.tags[Ku(t.doc, p)] : null, p = t && t.attrs ? Object.keys(t.attrs) : [], { from: m, to: e, options: (t && !1 === t.globalAttrs ? p : p.length ? p.concat(f.globalAttrNames) : f.globalAttrNames).map(t => ({ label: t, type: "property" })), validFor: nf }; if ("Is" == l.name || "AttributeValue" == l.name || "UnquotedAttributeValue" == l.name) { m = o; e = i; t = l; p = "Is" == l.name ? a : l.from; f = a; var h = null == (h = t.parent) ? void 0 : h.getChild("AttributeName"); let n = [], s = void 0; if (h) { h = m.sliceDoc(h.from, h.to); let r = e.globalAttrs[h]; if (r || (e = (t = tf(t)) ? e.tags[Ku(m.doc, t)] : null, r = (null == e ? void 0 : e.attrs) && e.attrs[h]), r) { let t = m.sliceDoc(p, f).toLowerCase(), e = '"', i = '"'; /^['"]/.test(t) ? (s = '"' == t[0] ? /^[^"]*$/ : /^[^']*$/, e = "", i = m.sliceDoc(f, f + 1) == t[0] ? "" : t[0], t = t.slice(1), p++) : s = /^[^\s<>='"]*$/; for (var c of r) n.push({ label: c, apply: e + c + i, type: "constant" }) } } return { from: p, to: f, options: n, validFor: s } } if (!r.explicit || "Element" != n.name && "Text" != n.name && "Document" != n.name) return null; { h = o; r = i; i = l; var d = a; let t = [], e = 0; for (var O of ef(h.doc, i, r)) t.push({ label: "<" + O, type: "type" }); for (var u of rf(h.doc, i)) t.push({ label: "</" + u + ">", type: "type", boost: 99 - e++ }); return { from: d, to: d, options: t, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ }; return } var t, f, p, m, e } var lf = [{ tag: "script", attrs: t => "text/typescript" == t.type || "ts" == t.lang, parser: ju.parser }, { tag: "script", attrs: t => "text/babel" == t.type || "text/jsx" == t.type, parser: Eu.parser }, { tag: "script", attrs: t => "text/typescript-jsx" == t.type, parser: Du.parser }, { tag: "script", attrs(t) { return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type) }, parser: qu.parser.configure({ top: "SingleExpression" }) }, { tag: "script", attrs(t) { return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type) }, parser: qu.parser }, { tag: "style", attrs(t) { return (!t.lang || "css" == t.lang) && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type)) }, parser: Su.parser }], hf = [{ name: "style", parser: Su.parser.configure({ top: "Styles" }) }].concat(s.map(t => ({ name: t, parser: qu.parser }))), cf = Le.define({ name: "html", parser: Ge.configure({ props: [Aa.add({ Element(t) { var e = /^(\s*)(<\/)?/.exec(t.textAfter); return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit) }, "OpenTag CloseTag SelfClosingTag"(t) { return t.column(t.node.from) + t.unit }, Document(e) { if (e.pos + /\s*/.exec(e.textAfter)[0].length < e.node.to) return e.continue(); let i = null, t; for (let t = e.node; ;) { var r = t.lastChild; if (!r || "Element" != r.name || r.to != t.to) break; i = t = r } return i && (!(t = i.lastChild) || "CloseTag" != t.name && "SelfClosingTag" != t.name) ? e.lineIndent(i.from) + e.unit : null } }), ja.add({ Element(t) { var e = t.firstChild, i = t.lastChild; return e && "OpenTag" == e.name ? { from: e.to, to: "CloseTag" == i.name ? i.from : t.to } : null } }), Sl.add({ "OpenTag CloseTag": t => t.getChild("TagName") })] }), languageData: { commentTokens: { block: { open: "\x3c!--", close: "--\x3e" } }, indentOnInput: /^\s*<\/\w+\W$/, wordChars: "-._" } }), df = cf.configure({ wrap: ou(lf, hf) }); function Of(t = {}) { let e = "", i; !1 === t.matchClosingTags && (e = "noMatch"), !0 === t.selfClosingTags && (e = (e ? e + " " : "") + "selfClosing"); var r = (i = t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length ? ou((t.nestedLanguages || []).concat(lf), (t.nestedAttributes || []).concat(hf)) : i) ? cf.configure({ wrap: i, dialect: e }) : e ? df.configure({ dialect: e }) : df; return new ka(r, [df.data.of({ autocomplete: (t => { var { extraTags: t, extraGlobalAttributes: e } = t; let i = e || t ? new Ju(t, e) : Ju.default; return t => af(i, t) })(t) }), !1 !== t.autoCloseTags ? ff : [], Gu().support, new ka(Su, Su.data.of({ autocomplete: yu })).support]) } var uf = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), ff = $.inputHandler.of((t, e, i, o, r) => { if (t.composing || t.state.readOnly || e != i || ">" != o && "/" != o || !df.isActiveAt(t.state, e, -1)) return !1; let n = r(), a = n.state; i = a.changeByRange(t => { var e = a.doc.sliceString(t.from - 1, t.to) == o; let i = t.head, r = T(a).resolveInner(i - 1, -1), n; if ("TagName" != r.name && "StartTag" != r.name || (r = r.parent), e && ">" == o && "OpenTag" == r.name) { if ("CloseTag" != (null == (s = null == (s = r.parent) ? void 0 : s.lastChild) ? void 0 : s.name) && (n = Ku(a.doc, r.parent, i)) && !uf.has(n)) return { range: t, changes: { from: i, to: i + (">" === a.doc.sliceString(i, i + 1) ? 1 : 0), insert: `</${n}>` } } } else if (e && "/" == o && "IncompleteCloseTag" == r.name) { var s = r.parent; if (r.from == i - 2 && "CloseTag" != (null == (e = s.lastChild) ? void 0 : e.name) && (n = Ku(a.doc, s, i)) && !uf.has(n)) return e = i + (">" === a.doc.sliceString(i, i + 1) ? 1 : 0), s = n + ">", { range: g.cursor(i + s.length, -1), changes: { from: i, to: e, insert: s } } } return { range: t } }); return !i.changes.empty && (t.dispatch([n, a.update(i, { userEvent: "input.complete", scrollIntoView: !0 })]), !0) }), aa = "#e06c75", Ph = "#abb2bf", Ch = "#7d8799", Zh = "#d19a66", Vh = "#2c313a", Sh = "#282c34", n = "#353a42", Mh = "#528bff", pf = [$.theme({ "&": { color: Ph, backgroundColor: Sh }, ".cm-content": { caretColor: Mh }, ".cm-cursor, .cm-dropCursor": { borderLeftColor: Mh }, "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: "#3E4451" }, ".cm-panels": { backgroundColor: "#21252b", color: Ph }, ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" }, ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" }, ".cm-searchMatch": { backgroundColor: "#72a1ff59", outline: "1px solid #457dff" }, ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: "#6199ff2f" }, ".cm-activeLine": { backgroundColor: "#6699ff0b" }, ".cm-selectionMatch": { backgroundColor: "#aafe661a" }, "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bad0f847" }, ".cm-gutters": { backgroundColor: Sh, color: Ch, border: "none" }, ".cm-activeLineGutter": { backgroundColor: Vh }, ".cm-foldPlaceholder": { backgroundColor: "transparent", border: "none", color: "#ddd" }, ".cm-tooltip": { border: "none", backgroundColor: n }, ".cm-tooltip .cm-tooltip-arrow:before": { borderTopColor: "transparent", borderBottomColor: "transparent" }, ".cm-tooltip .cm-tooltip-arrow:after": { borderTopColor: n, borderBottomColor: n }, ".cm-tooltip-autocomplete": { "& > ul > li[aria-selected]": { backgroundColor: Vh, color: Ph } } }, { dark: !0 }), Ol(ll.define([{ tag: Z.keyword, color: "#c678dd" }, { tag: [Z.name, Z.deleted, Z.character, Z.propertyName, Z.macroName], color: aa }, { tag: [Z.function(Z.variableName), Z.labelName], color: "#61afef" }, { tag: [Z.color, Z.constant(Z.name), Z.standard(Z.name)], color: Zh }, { tag: [Z.definition(Z.name), Z.separator], color: Ph }, { tag: [Z.typeName, Z.className, Z.number, Z.changed, Z.annotation, Z.modifier, Z.self, Z.namespace], color: "#e5c07b" }, { tag: [Z.operator, Z.operatorKeyword, Z.url, Z.escape, Z.regexp, Z.link, Z.special(Z.string)], color: "#56b6c2" }, { tag: [Z.meta, Z.comment], color: Ch }, { tag: Z.strong, fontWeight: "bold" }, { tag: Z.emphasis, fontStyle: "italic" }, { tag: Z.strikethrough, textDecoration: "line-through" }, { tag: Z.link, color: Ch, textDecoration: "underline" }, { tag: Z.heading, fontWeight: "bold", color: aa }, { tag: [Z.atom, Z.bool, Z.special(Z.variableName)], color: Zh }, { tag: [Z.processingInstruction, Z.string, Z.inserted], color: "#98c379" }, { tag: Z.invalid, color: "#ffffff" }]))], mf = new bt; window.HtmlEditor = function(t, e) { this.element = t, this.editor = void 0, this.readOnly = !1, this.set = function(t) { null == this.editor && (this.editor = new $({ doc: t = null == t ? "" : t, parent: document.getElementById(this.element), extensions: [gO, Of(), mf.of([pf]), jn.of([_h]), Pa.of("\t"), v.readOnly.of(this.readOnly)] }), "dark" == e ? this.setDarkTheme() : this.setLightTheme()) }, this.setLightTheme = function() { this.editor.dispatch({ effects: mf.reconfigure([]) }), document.querySelector("#" + this.element + " .cm-content").classList.add("cm-light-theme") }, this.setDarkTheme = function() { this.editor.dispatch({ effects: mf.reconfigure([pf]) }), document.querySelector("#" + this.element + " .cm-content").classList.add("cm-dark-theme") }, this.setReadOnly = function(t) { (t = null == t ? !this.readOnly : t) != this.readOnly && (this.readOnly = t, this.readOnly ? (document.querySelector("#" + this.element + " .cm-content").classList.add("cm-editor-readonly"), document.querySelector("#" + this.element + " .cm-content").setAttribute("contenteditable", "false")) : (document.querySelector("#" + this.element + " .cm-content").classList.remove("cm-editor-readonly"), document.querySelector("#" + this.element + " .cm-content").setAttribute("contenteditable", "true"))) }, this.clean = function() { null != this.editor && (this.editor.destroy(), this.editor = void 0) }, this.setCode = function(t, e, i) { null == i && (i = this.editor.state.doc.length), this.editor.dispatch({ changes: { from: e = null == e ? 0 : e, to: i, insert: t } }) }, this.getCode = function(t, e) { return null == e && (e = this.editor.state.doc.length), this.editor.state.doc.sliceString(t = null == t ? 0 : t, e) }, this.getSelection = function() { return this.editor.state.sliceDoc(this.editor.state.selection.main.from, this.editor.state.selection.main.to) }, this.replaceSelection = function(t) { var e = this.editor.state.selection.main.from, i = this.editor.state.selection.main.to; this.setCode("", e, i), this.setCode(t, e, e) }, this.openSearch = function() { Cc(this.editor) }, null != this.element && this.set() } })();