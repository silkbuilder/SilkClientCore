(() => { var g = class Fu { lineAt(t) { if (t < 0 || t > this.length) throw new RangeError(`Invalid position ${t} in document of length ` + this.length); return this.lineInner(t, !1, 1, 0) } line(t) { if (t < 1 || t > this.lines) throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`); return this.lineInner(t, !0, 1, 0) } replace(t, e, i) { [t, e] = q(this, t, e); var r = []; return this.decompose(0, t, r, 2), i.length && i.decompose(0, i.length, r, 3), this.decompose(e, this.length, r, 1), L.from(r, this.length - (e - t) + i.length) } append(t) { return this.replace(this.length, this.length, t) } slice(t, e = this.length) { [t, e] = q(this, t, e); var i = []; return this.decompose(t, e, i, 0), L.from(i, e - t) } eq(t) { if (t == this) return !0; if (t.length != this.length || t.lines != this.lines) return !1; var i = this.scanIdentical(t, 1), r = this.length - this.scanIdentical(t, -1), s = new H(this), n = new H(t); for (let t = i, e = i; ;) { if (s.next(t), n.next(t), t = 0, s.lineBreak != n.lineBreak || s.done != n.done || s.value != n.value) return !1; if (e += s.value.length, s.done || e >= r) return !0 } } iter(t = 1) { return new H(this, t) } iterRange(t, e = this.length) { return new W(this, t, e) } iterLines(t, e) { let i; return i = null == t ? this.iter() : (null == e && (e = this.lines + 1), t = this.line(t).from, this.iterRange(t, Math.max(t, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to))), new z(i) } toString() { return this.sliceString(0) } toJSON() { var t = []; return this.flatten(t), t } constructor() { } static of(t) { if (0 == t.length) throw new RangeError("A document must have at least one line"); return 1 != t.length || t[0] ? t.length <= 32 ? new E(t) : L.from(E.split(t, [])) : Fu.empty } }, E = class qu extends g { constructor(t, e = (t => { let e = -1; for (var i of t) e += i.length + 1; return e })(t)) { super(), this.text = t, this.length = e } get lines() { return this.text.length } get children() { return null } lineInner(e, i, r, s) { for (let t = 0; ; t++) { var n = this.text[t], o = s + n.length; if (e <= (i ? r : o)) return new F(s, o, r, n); s = o + 1, r++ } } decompose(t, e, i, r) { e = t <= 0 && e >= this.length ? this : new qu(V(this.text, t, e), Math.min(e, this.length) - Math.max(0, t)); 1 & r ? (t = i.pop(), (r = I(e.text, t.text.slice(), 0, e.length)).length <= 32 ? i.push(new qu(r, t.length + e.length)) : (t = r.length >> 1, i.push(new qu(r.slice(0, t)), new qu(r.slice(t))))) : i.push(e) } replace(t, e, i) { if (!(i instanceof qu)) return super.replace(t, e, i);[t, e] = q(this, t, e); var r = I(this.text, I(i.text, V(this.text, 0, t)), e), i = this.length + i.length - (e - t); return r.length <= 32 ? new qu(r, i) : L.from(qu.split(r, []), i) } sliceString(i, r = this.length, s = "\n") { [i, r] = q(this, i, r); let n = ""; for (let t = 0, e = 0; t <= r && e < this.text.length; e++) { var o = this.text[e], a = t + o.length; t > i && e && (n += s), i < a && r > t && (n += o.slice(Math.max(0, i - t), r - t)), t = a + 1 } return n } flatten(t) { for (var e of this.text) t.push(e) } scanIdentical() { return 0 } static split(t, e) { let i = [], r = -1; for (var s of t) i.push(s), r += s.length + 1, 32 == i.length && (e.push(new qu(i, r)), i = [], r = -1); return -1 < r && e.push(new qu(i, r)), e } }, L = class _u extends g { constructor(t, e) { super(), this.children = t, this.length = e, this.lines = 0; for (var i of t) this.lines += i.lines } lineInner(e, i, r, s) { for (let t = 0; ; t++) { var n = this.children[t], o = s + n.length, a = r + n.lines - 1; if (e <= (i ? a : o)) return n.lineInner(e, i, r, s); s = o + 1, r = 1 + a } } decompose(i, r, s, n) { for (let t = 0, e = 0; e <= r && t < this.children.length; t++) { var o, a = this.children[t], h = e + a.length; i <= h && r >= e && (o = n & ((e <= i ? 1 : 0) | (r <= h ? 2 : 0)), e >= i && h <= r && !o ? s.push(a) : a.decompose(i - e, r - e, s, o)), e = h + 1 } } replace(i, r, s) { if ([i, r] = q(this, i, r), s.lines < this.lines) for (let t = 0, e = 0; t < this.children.length; t++) { var n, o = this.children[t], a = e + o.length; if (i >= e && r <= a) return n = o.replace(i - e, r - e, s), o = this.lines - o.lines + n.lines, n.lines < o >> 4 && n.lines > o >> 6 ? ((o = this.children.slice())[t] = n, new _u(o, this.length - (r - i) + s.length)) : super.replace(e, a, n); e = a + 1 } return super.replace(i, r, s) } sliceString(i, r = this.length, s = "\n") { [i, r] = q(this, i, r); let n = ""; for (let t = 0, e = 0; t < this.children.length && e <= r; t++) { var o = this.children[t], a = e + o.length; e > i && t && (n += s), i < a && r > e && (n += o.sliceString(i - e, r - e, s)), e = a + 1 } return n } flatten(t) { for (var e of this.children) e.flatten(t) } scanIdentical(t, e) { if (!(t instanceof _u)) return 0; let i = 0, [r, s, n, o] = 0 < e ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1]; for (; ; r += e, s += e) { if (r == n || s == o) return i; var a = this.children[r], h = t.children[s]; if (a != h) return i + a.scanIdentical(h, e); i += a.length + 1 } } static from(t, e = t.reduce((t, e) => t + e.length + 1, -1)) { let i = 0; for (var r of t) i += r.lines; if (i < 32) { var s, n = []; for (s of t) s.flatten(n); return new E(n, e) } let o = Math.max(32, i >> 5), a = o << 1, h = o >> 1, l = [], c = 0, d = -1, u = []; function f() { 0 != c && (l.push(1 == u.length ? u[0] : _u.from(u, d)), d = -1, c = u.length = 0) } for (var p of t) !function t(e) { let i; if (e.lines > a && e instanceof _u) for (var r of e.children) t(r); else e.lines > h && (c > h || !c) ? (f(), l.push(e)) : e instanceof E && c && (i = u[u.length - 1]) instanceof E && e.lines + i.lines <= 32 ? (c += e.lines, d += e.length + 1, u[u.length - 1] = new E(i.text.concat(e.text), i.length + 1 + e.length)) : (c + e.lines > o && f(), c += e.lines, d += e.length + 1, u.push(e)) }(p); return f(), 1 == l.length ? l[0] : new _u(l, e) } }; function I(n, o, a = 0, h = 1e9) { for (let i = 0, r = 0, s = !0; r < n.length && i <= h; r++) { let t = n[r], e = i + t.length; a <= e && (h < e && (t = t.slice(0, h - i)), i < a && (t = t.slice(a - i)), s ? (o[o.length - 1] += t, s = !1) : o.push(t)), i = e + 1 } return o } function V(t, e, i) { return I(t, [""], e, i) } g.empty = new E([""], 0); var H = class { constructor(t, e = 1) { this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [0 < e ? 1 : (t instanceof E ? t.text : t.children).length << 1] } nextInner(t, e) { for (this.done = this.lineBreak = !1; ;) { var i = this.nodes.length - 1, r = this.nodes[i], s = this.offsets[i], n = s >> 1, o = (r instanceof E ? r.text : r.children).length; if (n == (0 < e ? o : 0)) { if (0 == i) return this.done = !0, this.value = "", this; 0 < e && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop() } else if ((1 & s) == (0 < e ? 0 : 1)) { if (this.offsets[i] += e, 0 == t) return this.lineBreak = !0, this.value = "\n", this; t-- } else if (r instanceof E) { o = r.text[n + (e < 0 ? -1 : 0)]; if (this.offsets[i] += e, o.length > Math.max(0, t)) return this.value = 0 == t ? o : 0 < e ? o.slice(t) : o.slice(0, o.length - t), this; t -= o.length } else { s = r.children[n + (e < 0 ? -1 : 0)]; t > s.length ? (t -= s.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(s), this.offsets.push(0 < e ? 1 : (s instanceof E ? s.text : s.children).length << 1)) } } } next(t = 0) { return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir) } }, W = class { constructor(t, e, i) { this.value = "", this.done = !1, this.cursor = new H(t, i < e ? -1 : 1), this.pos = i < e ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i) } nextInner(t, e) { var i, r; return (e < 0 ? this.pos <= this.from : this.pos >= this.to) ? (this.value = "", this.done = !0) : (t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos), i = e < 0 ? this.pos - this.from : this.to - this.pos, r = (i -= t = i < t ? i : t, this.cursor.next(t)).value, this.pos += (r.length + t) * e, this.value = r.length <= i ? r : e < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value), this } next(t = 0) { return t < 0 ? t = Math.max(t, this.from - this.pos) : 0 < t && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir) } get lineBreak() { return this.cursor.lineBreak && "" != this.value } }, z = class { constructor(t) { this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1 } next(t = 0) { var { done: t, lineBreak: e, value: i } = this.inner.next(t); return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : e ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this } get lineBreak() { return !1 } }, F = ("undefined" != typeof Symbol && (g.prototype[Symbol.iterator] = function() { return this.iter() }, H.prototype[Symbol.iterator] = W.prototype[Symbol.iterator] = z.prototype[Symbol.iterator] = function() { return this }), class { constructor(t, e, i, r) { this.from = t, this.to = e, this.number = i, this.text = r } get length() { return this.to - this.from } }); function q(t, e, i) { return [e = Math.max(0, Math.min(t.length, e)), Math.max(e, Math.min(t.length, i))] } var U = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(t => t ? parseInt(t, 36) : 1); for (let t = 1; t < U.length; t++)U[t] += U[t - 1]; function Q(t) { return 127462 <= t && t <= 127487 } var $ = 8205; function u(t, e, i = !0, r = !0) { return (i ? K : X)(t, e, r) } function K(i, r, e) { if (r != i.length) { r && G(i.charCodeAt(r)) && Y(i.charCodeAt(r - 1)) && r--; let t = S(i, r); for (r += Z(t); r < i.length;) { var s = S(i, r); if (t == $ || s == $ || e && (e => { for (let t = 1; t < U.length; t += 2)if (U[t] > e) return U[t - 1] <= e })(s)) r += Z(s), t = s; else { if (!Q(s)) break; { let t = 0, e = r - 2; for (; 0 <= e && Q(S(i, e));)t++, e -= 2; if (t % 2 == 0) break; r += 2 } } } } return r } function X(t, e, i) { for (; 0 < e;) { var r = K(t, e - 2, i); if (r < e) return r; e-- } return 0 } function G(t) { return 56320 <= t && t < 57344 } function Y(t) { return 55296 <= t && t < 56320 } function S(t, e) { var i = t.charCodeAt(e); return Y(i) && e + 1 != t.length && G(t = t.charCodeAt(e + 1)) ? t - 56320 + (i - 55296 << 10) + 65536 : i } function J(t) { return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) } function Z(t) { return t < 65536 ? 1 : 2 } var tt = /\r\n?|\n/, l = (t => (t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t))(l = l || {}), et = class ju { constructor(t) { this.sections = t } get length() { let e = 0; for (let t = 0; t < this.sections.length; t += 2)e += this.sections[t]; return e } get newLength() { let e = 0; for (let t = 0; t < this.sections.length; t += 2) { var i = this.sections[t + 1]; e += i < 0 ? this.sections[t] : i } return e } get empty() { return 0 == this.sections.length || 2 == this.sections.length && this.sections[1] < 0 } iterGaps(r) { for (let t = 0, e = 0, i = 0; t < this.sections.length;) { var s = this.sections[t++], n = this.sections[t++]; n < 0 ? (r(e, i, s), i += s) : i += n, e += s } } iterChangedRanges(t, e = !1) { st(this, t, e) } get invertedDesc() { var e = []; for (let t = 0; t < this.sections.length;) { var i = this.sections[t++], r = this.sections[t++]; r < 0 ? e.push(i, r) : e.push(r, i) } return new ju(e) } composeDesc(t) { return this.empty ? t : t.empty ? this : ot(this, t) } mapDesc(t, e = !1) { return t.empty ? this : nt(this, t, e) } mapPos(e, i = -1, r = l.Simple) { let s = 0, n = 0; for (let t = 0; t < this.sections.length;) { var o = this.sections[t++], a = this.sections[t++], h = s + o; if (a < 0) { if (e < h) return n + (e - s); n += o } else { if (r != l.Simple && e <= h && (r == l.TrackDel && s < e && e < h || r == l.TrackBefore && s < e || r == l.TrackAfter && e < h)) return null; if (e < h || h == e && i < 0 && !o) return e == s || i < 0 ? n : n + a; n += a } s = h } if (e > s) throw new RangeError(`Position ${e} is out of range for changeset of length ` + s); return n } touchesRange(i, r = i) { for (let t = 0, e = 0; t < this.sections.length && e <= r;) { var s = this.sections[t++], n = this.sections[t++], s = e + s; if (0 <= n && e <= r && i <= s) return !(e < i && r < s) || "cover"; e = s } return !1 } toString() { let e = ""; for (let t = 0; t < this.sections.length;) { var i = this.sections[t++], r = this.sections[t++]; e += (e ? " " : "") + i + (0 <= r ? ":" + r : "") } return e } toJSON() { return this.sections } static fromJSON(t) { if (!Array.isArray(t) || t.length % 2 || t.some(t => "number" != typeof t)) throw new RangeError("Invalid JSON representation of ChangeDesc"); return new ju(t) } static create(t) { return new ju(t) } }, it = class Uu extends et { constructor(t, e) { super(t), this.inserted = e } apply(n) { if (this.length != n.length) throw new RangeError("Applying change set to a document with the wrong length"); return st(this, (t, e, i, r, s) => n = n.replace(i, i + (e - t), s), !1), n } mapDesc(t, e = !1) { return nt(this, t, e, !0) } invert(i) { var r = this.sections.slice(), s = []; for (let t = 0, e = 0; t < r.length; t += 2) { var n = r[t], o = r[t + 1]; if (0 <= o) { r[t] = o, r[t + 1] = n; for (var a = t >> 1; s.length < a;)s.push(g.empty); s.push(n ? i.slice(e, e + n) : g.empty) } e += n } return new Uu(r, s) } compose(t) { return this.empty ? t : t.empty ? this : ot(this, t, !0) } map(t, e = !1) { return t.empty ? this : nt(this, t, e, !0) } iterChanges(t, e = !1) { st(this, t, e) } get desc() { return et.create(this.sections) } filter(i) { var r = [], s = [], n = [], o = new at(this); t: for (let t = 0, e = 0; ;) { for (var a = t == i.length ? 1e9 : i[t++]; e < a || e == a && 0 == o.len;) { if (o.done) break t; var h = Math.min(o.len, a - e), l = (f(n, h, -1), -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0); f(r, h, l), 0 < l && rt(s, r, o.text), o.forward(h), e += h } for (var c = i[t++]; e < c;) { if (o.done) break t; var d = Math.min(o.len, c - e); f(r, d, -1), f(n, d, -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0), o.forward(d), e += d } } return { changes: new Uu(r, s), filtered: et.create(n) } } toJSON() { var e = []; for (let t = 0; t < this.sections.length; t += 2) { var i = this.sections[t], r = this.sections[t + 1]; e.push(r < 0 ? i : 0 == r ? [i] : [i].concat(this.inserted[t >> 1].toJSON())) } return e } static of(t, o, a) { let h = [], l = [], c = 0, d = null; function u(t = !1) { (t || h.length) && (c < o && f(h, o - c, -1), t = new Uu(h, l), d = d ? d.compose(t.map(d)) : t, h = [], l = [], c = 0) } return function t(e) { if (Array.isArray(e)) for (var i of e) t(i); else if (e instanceof Uu) { if (e.length != o) throw new RangeError(`Mismatched change set length (got ${e.length}, expected ${o})`); u(), d = d ? d.compose(e.map(d)) : e } else { var { from: e, to: r = e, insert: s } = e; if (r < e || e < 0 || o < r) throw new RangeError(`Invalid change range ${e} to ${r} (in doc of length ${o})`); var n = (s = s ? "string" == typeof s ? g.of(s.split(a || tt)) : s : g.empty).length; e == r && 0 == n || (e < c && u(), e > c && f(h, e - c, -1), f(h, r - e, n), rt(l, h, s), c = r) } }(t), u(!d), d } static empty(t) { return new Uu(t ? [t, -1] : [], []) } static fromJSON(e) { if (!Array.isArray(e)) throw new RangeError("Invalid JSON representation of ChangeSet"); var i = [], r = []; for (let t = 0; t < e.length; t++) { var s = e[t]; if ("number" == typeof s) i.push(s, -1); else { if (!Array.isArray(s) || "number" != typeof s[0] || s.some((t, e) => e && "string" != typeof t)) throw new RangeError("Invalid JSON representation of ChangeSet"); if (1 == s.length) i.push(s[0], 0); else { for (; r.length < t;)r.push(g.empty); r[t] = g.of(s.slice(1)), i.push(s[0], r[t].length) } } } return new Uu(i, r) } static createSet(t, e) { return new Uu(t, e) } }; function f(t, e, i, r = !1) { var s; 0 == e && i <= 0 || (0 <= (s = t.length - 2) && i <= 0 && i == t[1 + s] ? t[s] += e : 0 == e && 0 == t[s] ? t[1 + s] += i : r ? (t[s] += e, t[1 + s] += i) : t.push(e, i)) } function rt(t, e, i) { if (0 != i.length) { var r = e.length - 2 >> 1; if (r < t.length) t[t.length - 1] = t[t.length - 1].append(i); else { for (; t.length < r;)t.push(g.empty); t.push(i) } } } function st(h, l, c) { var d = h.inserted; for (let n = 0, o = 0, a = 0; a < h.sections.length;) { let r = h.sections[a++], s = h.sections[a++]; if (s < 0) n += r, o += r; else { let t = n, e = o, i = g.empty; for (; t += r, e += s, s && d && (i = i.append(d[a - 2 >> 1])), !(c || a == h.sections.length || h.sections[a + 1] < 0);)r = h.sections[a++], s = h.sections[a++]; l(n, t, o, e, i), n = t, o = e } } } function nt(t, e, r, i = !1) { var s = [], n = i ? [] : null, o = new at(t), a = new at(e); for (let i = -1; ;)if (-1 == o.ins && -1 == a.ins) { var h = Math.min(o.len, a.len); f(s, h, -1), o.forward(h), a.forward(h) } else if (0 <= a.ins && (o.ins < 0 || i == o.i || 0 == o.off && (a.len < o.len || a.len == o.len && !r))) { let t = a.len; for (f(s, a.ins, -1); t;) { var l = Math.min(o.len, t); 0 <= o.ins && i < o.i && o.len <= l && (f(s, 0, o.ins), n && rt(n, s, o.text), i = o.i), o.forward(l), t -= l } a.next() } else { if (!(0 <= o.ins)) { if (o.done && a.done) return n ? it.createSet(s, n) : et.create(s); throw new Error("Mismatched change set lengths") } { let t = 0, e = o.len; for (; e;)if (-1 == a.ins) { var c = Math.min(e, a.len); t += c, e -= c, a.forward(c) } else { if (!(0 == a.ins && a.len < e)) break; e -= a.len, a.next() } f(s, t, i < o.i ? o.ins : 0), n && i < o.i && rt(n, s, o.text), i = o.i, o.forward(o.len - e) } } } function ot(t, e, i = !1) { var r = [], s = i ? [] : null, n = new at(t), o = new at(e); for (let t = !1; ;) { if (n.done && o.done) return s ? it.createSet(r, s) : et.create(r); if (0 == n.ins) f(r, n.len, 0, t), n.next(); else if (0 != o.len || o.done) { if (n.done || o.done) throw new Error("Mismatched change set lengths"); var a, h = Math.min(n.len2, o.len), l = r.length; -1 == n.ins ? (f(r, h, a = -1 == o.ins ? -1 : o.off ? 0 : o.ins, t), s && a && rt(s, r, o.text)) : -1 == o.ins ? (f(r, n.off ? 0 : n.len, h, t), s && rt(s, r, n.textBit(h))) : (f(r, n.off ? 0 : n.len, o.off ? 0 : o.ins, t), s && !o.off && rt(s, r, o.text)), t = (n.ins > h || 0 <= o.ins && o.len > h) && (t || l < r.length), n.forward2(h), o.forward(h) } else f(r, 0, o.ins, t), s && rt(s, r, o.text), o.next() } } var at = class { constructor(t) { this.set = t, this.i = 0, this.next() } next() { var t = this.set.sections; this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0 } get done() { return -2 == this.ins } get len2() { return this.ins < 0 ? this.len : this.ins } get text() { var t = this.set.inserted, e = this.i - 2 >> 1; return e >= t.length ? g.empty : t[e] } textBit(t) { var e = this.set.inserted, i = this.i - 2 >> 1; return i >= e.length && !t ? g.empty : e[i].slice(this.off, null == t ? void 0 : this.off + t) } forward(t) { t == this.len ? this.next() : (this.len -= t, this.off += t) } forward2(t) { -1 == this.ins ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t) } }, ht = class Qu { constructor(t, e, i) { this.from = t, this.to = e, this.flags = i } get anchor() { return 32 & this.flags ? this.to : this.from } get head() { return 32 & this.flags ? this.from : this.to } get empty() { return this.from == this.to } get assoc() { return 8 & this.flags ? -1 : 16 & this.flags ? 1 : 0 } get bidiLevel() { var t = 7 & this.flags; return 7 == t ? null : t } get goalColumn() { var t = this.flags >> 6; return 16777215 == t ? void 0 : t } map(t, e = -1) { let i, r; return this.empty ? i = r = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), r = t.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new Qu(i, r, this.flags) } extend(t, e = t) { return t <= this.anchor && e >= this.anchor ? v.range(t, e) : (e = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e, v.range(this.anchor, e)) } eq(t, e = !1) { return !(this.anchor != t.anchor || this.head != t.head || e && this.empty && this.assoc != t.assoc) } toJSON() { return { anchor: this.anchor, head: this.head } } static fromJSON(t) { if (t && "number" == typeof t.anchor && "number" == typeof t.head) return v.range(t.anchor, t.head); throw new RangeError("Invalid JSON representation for SelectionRange") } static create(t, e, i) { return new Qu(t, e, i) } }, v = class $u { constructor(t, e) { this.ranges = t, this.mainIndex = e } map(e, i = -1) { return e.empty ? this : $u.create(this.ranges.map(t => t.map(e, i)), this.mainIndex) } eq(e, i = !1) { if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1; for (let t = 0; t < this.ranges.length; t++)if (!this.ranges[t].eq(e.ranges[t], i)) return !1; return !0 } get main() { return this.ranges[this.mainIndex] } asSingle() { return 1 == this.ranges.length ? this : new $u([this.main], 0) } addRange(t, e = !0) { return $u.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1) } replaceRange(t, e = this.mainIndex) { var i = this.ranges.slice(); return i[e] = t, $u.create(i, this.mainIndex) } toJSON() { return { ranges: this.ranges.map(t => t.toJSON()), main: this.mainIndex } } static fromJSON(t) { if (!t || !Array.isArray(t.ranges) || "number" != typeof t.main || t.main >= t.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection"); return new $u(t.ranges.map(t => ht.fromJSON(t)), t.main) } static single(t, e = t) { return new $u([$u.range(t, e)], 0) } static create(i, r = 0) { if (0 == i.length) throw new RangeError("A selection needs at least one range"); for (let t = 0, e = 0; e < i.length; e++) { var s = i[e]; if (s.empty ? s.from <= t : s.from < t) return $u.normalized(i.slice(), r); t = s.to } return new $u(i, r) } static cursor(t, e = 0, i, r) { return ht.create(t, t, (0 == e ? 0 : e < 0 ? 8 : 16) | (null == i ? 7 : Math.min(6, i)) | (null != r ? r : 16777215) << 6) } static range(t, e, i, r) { i = (null != i ? i : 16777215) << 6 | (null == r ? 7 : Math.min(6, r)); return e < t ? ht.create(e, t, 48 | i) : ht.create(t, e, (t < e ? 8 : 0) | i) } static normalized(e, i = 0) { var t = e[i]; e.sort((t, e) => t.from - e.from), i = e.indexOf(t); for (let t = 1; t < e.length; t++) { var r, s = e[t], n = e[t - 1]; (s.empty ? s.from <= n.to : s.from < n.to) && (r = n.from, n = Math.max(s.to, n.to), t <= i && i--, e.splice(--t, 2, s.anchor > s.head ? $u.range(n, r) : $u.range(r, n))) } return new $u(e, i) } }; function lt(t, e) { for (var i of t.ranges) if (i.to > e) throw new RangeError("Selection points outside of document") } var ct = 0, d = class Ku { constructor(t, e, i, r, s) { this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = r, this.id = ct++, this.default = t([]), this.extensions = "function" == typeof s ? s(this) : s } get reader() { return this } static define(t = {}) { return new Ku(t.combine || (t => t), t.compareInput || ((t, e) => t === e), t.compare || (t.combine ? (t, e) => t === e : dt), !!t.static, t.enables) } of(t) { return new ut([], this, 0, t) } compute(t, e) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new ut(t, this, 1, e) } computeN(t, e) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new ut(t, this, 2, e) } from(e, i) { return i = i || (t => t), this.compute([e], t => i(t.field(e))) } }; function dt(t, i) { return t == i || t.length == i.length && t.every((t, e) => t === i[e]) } var ut = class { constructor(t, e, i, r) { this.dependencies = t, this.facet = e, this.type = i, this.value = r, this.id = ct++ } dynamicSlot(t) { let e, n = this.value, o = this.facet.compareInput, a = this.id, h = t[a] >> 1, l = 2 == this.type, i = !1, r = !1, s = []; for (var c of this.dependencies) "doc" == c ? i = !0 : "selection" == c ? r = !0 : 0 == (1 & (null != (e = t[c.id]) ? e : 1)) && s.push(t[c.id]); return { create(t) { return t.values[h] = n(t), 1 }, update(t, e) { if (i && e.docChanged || r && (e.docChanged || e.selection) || pt(t, s)) { e = n(t); if (l ? !ft(e, t.values[h], o) : !o(e, t.values[h])) return t.values[h] = e, 1 } return 0 }, reconfigure: (e, i) => { let t, r = i.config.address[a]; if (null != r) { var s = Ct(i, r); if (this.dependencies.every(t => t instanceof d ? i.facet(t) === e.facet(t) : !(t instanceof p) || i.field(t, !1) == e.field(t, !1)) || (l ? ft(t = n(e), s, o) : o(t = n(e), s))) return e.values[h] = s, 0 } else t = n(e); return e.values[h] = t, 1 } } } }; function ft(e, i, r) { if (e.length == i.length) { for (let t = 0; t < e.length; t++)if (!r(e[t], i[t])) return; return 1 } } function pt(t, e) { let i = !1; for (var r of e) 1 & St(t, r) && (i = !0); return i } var mt = d.define({ static: !0 }), p = class Xu { constructor(t, e, i, r, s) { this.id = t, this.createF = e, this.updateF = i, this.compareF = r, this.spec = s, this.provides = void 0 } static define(t) { var e = new Xu(ct++, t.create, t.update, t.compare || ((t, e) => t === e), t); return t.provide && (e.provides = t.provide(e)), e } create(t) { var e = t.facet(mt).find(t => t.field == this); return ((null == e ? void 0 : e.create) || this.createF)(t) } slot(t) { let r = t[this.id] >> 1; return { create: t => (t.values[r] = this.create(t), 1), update: (t, e) => { var i = t.values[r], e = this.updateF(i, e); return this.compareF(i, e) ? 0 : (t.values[r] = e, 1) }, reconfigure: (t, e) => null != e.config.address[this.id] ? (t.values[r] = e.field(this), 0) : (t.values[r] = this.create(t), 1) } } init(t) { return [this, mt.of({ field: this, create: t })] } get extension() { return this } }, gt = 2; function vt(e) { return t => new bt(t, e) } var wt = { highest: vt(0), high: vt(1), default: vt(gt), low: vt(3), lowest: vt(4) }, bt = class { constructor(t, e) { this.inner = t, this.prec = e } }, yt = class Gu { of(t) { return new xt(this, t) } reconfigure(t) { return Gu.reconfigure.of({ compartment: this, extension: t }) } get(t) { return t.config.compartments.get(this) } }, xt = class { constructor(t, e) { this.compartment = t, this.inner = e } }, kt = class Yu { constructor(t, e, i, r, s, n) { for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = r, this.staticValues = s, this.facets = n, this.statusTemplate = []; this.statusTemplate.length < i.length;)this.statusTemplate.push(0) } staticFacet(t) { var e = this.address[t.id]; return null == e ? t.default : this.staticValues[e >> 1] } static resolve(t, e, r) { var i, s = [], n = Object.create(null), o = new Map; for (i of ((t, o, a) => { let h = [[], [], [], [], []], l = new Map; return function t(e, i) { var r = l.get(e); if (null != r) { if (r <= i) return; var s = h[r].indexOf(e); -1 < s && h[r].splice(s, 1), e instanceof xt && a.delete(e.compartment) } if (l.set(e, i), Array.isArray(e)) for (var n of e) t(n, i); else if (e instanceof xt) { if (a.has(e.compartment)) throw new RangeError("Duplicate use of compartment in extensions"); r = o.get(e.compartment) || e.inner, a.set(e.compartment, r), t(r, i) } else if (e instanceof bt) t(e.inner, e.prec); else if (e instanceof p) h[i].push(e), e.provides && t(e.provides, i); else if (e instanceof ut) h[i].push(e), e.facet.extensions && t(e.facet.extensions, gt); else { if (!(s = e.extension)) throw new Error(`Unrecognized extension value in extension set (${e}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`); t(s, i) } }(t, gt), h.reduce((t, e) => t.concat(e)) })(t, e, o)) (i instanceof p ? s : n[i.facet.id] || (n[i.facet.id] = [])).push(i); let a = Object.create(null); var h = [], l = []; for (let e of s) a[e.id] = l.length << 1, l.push(t => e.slot(t)); var d, u = null == r ? void 0 : r.config.facets; for (d in n) { let i = n[d], c = i[0].facet; var f = u && u[d] || []; if (i.every(t => 0 == t.type)) a[c.id] = h.length << 1 | 1, dt(f, i) ? h.push(r.facet(c)) : (f = c.combine(i.map(t => t.value)), h.push(r && c.compare(f, r.facet(c)) ? r.facet(c) : f)); else { for (let e of i) 0 == e.type ? (a[e.id] = h.length << 1 | 1, h.push(e.value)) : (a[e.id] = l.length << 1, l.push(t => e.dynamicSlot(t))); a[c.id] = l.length << 1, l.push(t => { { var e = t, a = c, h = i; let n = h.map(t => e[t.id]), o = h.map(t => t.type), r = n.filter(t => !(1 & t)), s = e[a.id] >> 1; function l(e) { var i = []; for (let t = 0; t < n.length; t++) { var r = Ct(e, n[t]); if (2 == o[t]) for (var s of r) i.push(s); else i.push(r) } return a.combine(i) } return { create(t) { for (var e of n) St(t, e); return t.values[s] = l(t), 1 }, update(t, e) { var i; return !pt(t, r) || (i = l(t), a.compare(i, t.values[s])) ? 0 : (t.values[s] = i, 1) }, reconfigure(t, e) { var i = pt(t, n), r = e.config.facets[a.id], e = e.facet(a); return r && !i && dt(h, r) || (i = l(t), a.compare(i, e)) ? (t.values[s] = e, 0) : (t.values[s] = i, 1) } } } }) } } e = l.map(t => t(a)); return new Yu(t, o, e, a, h, n) } }; function St(t, e) { if (1 & e) return 2; var e = e >> 1, i = t.status[e]; if (4 == i) throw new Error("Cyclic dependency between fields and/or facets"); if (2 & i) return i; t.status[e] = 4; i = t.computeSlot(t, t.config.dynamicSlots[e]); return t.status[e] = 2 | i } function Ct(t, e) { return (1 & e ? t.config.staticValues : t.values)[e >> 1] } var At = d.define(), Ot = d.define({ combine: t => t.some(t => t), static: !0 }), Mt = d.define({ combine: t => t.length ? t[0] : void 0, static: !0 }), Tt = d.define(), Dt = d.define(), Pt = d.define(), Rt = d.define({ combine: t => !!t.length && t[0] }), Bt = class { constructor(t, e) { this.type = t, this.value = e } static define() { return new Et } }, Et = class { of(t) { return new Bt(this, t) } }, Lt = class { constructor(t) { this.map = t } of(t) { return new c(this, t) } }, c = class Ju { constructor(t, e) { this.type = t, this.value = e } map(t) { t = this.type.map(this.value, t); return void 0 === t ? void 0 : t == this.value ? this : new Ju(this.type, t) } is(t) { return this.type == t } static define(t = {}) { return new Lt(t.map || (t => t)) } static mapEffects(t, e) { if (!t.length) return t; var i, r = []; for (i of t) { var s = i.map(e); s && r.push(s) } return r } }, Nt = (c.reconfigure = c.define(), c.appendConfig = c.define(), class Zu { constructor(t, e, i, r, s, n) { this.startState = t, this.changes = e, this.selection = i, this.effects = r, this.annotations = s, this.scrollIntoView = n, this._doc = null, this._state = null, i && lt(i, e.newLength), s.some(t => t.type == Zu.time) || (this.annotations = s.concat(Zu.time.of(Date.now()))) } static create(t, e, i, r, s, n) { return new Zu(t, e, i, r, s, n) } get newDoc() { return this._doc || (this._doc = this.changes.apply(this.startState.doc)) } get newSelection() { return this.selection || this.startState.selection.map(this.changes) } get state() { return this._state || this.startState.applyTransaction(this), this._state } annotation(t) { for (var e of this.annotations) if (e.type == t) return e.value } get docChanged() { return !this.changes.empty } get reconfigured() { return this.startState.config != this.state.config } isUserEvent(t) { var e = this.annotation(Zu.userEvent); return !(!e || !(e == t || e.length > t.length && e.slice(0, t.length) == t && "." == e[t.length])) } }); function It(t, e, i) { let r, s, n, o; return { changes: o = i ? (s = e.changes, n = it.empty(e.changes.length), t.changes.compose(e.changes)) : (s = e.changes.map(t.changes), n = t.changes.mapDesc(e.changes, !0), t.changes.compose(s)), selection: e.selection ? e.selection.map(n) : null == (r = t.selection) ? void 0 : r.map(s), effects: c.mapEffects(t.effects, s).concat(c.mapEffects(e.effects, n)), annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations, scrollIntoView: t.scrollIntoView || e.scrollIntoView } } function Vt(t, e, i) { let r = e.selection, s = zt(e.annotations); return e.userEvent && (s = s.concat(Nt.userEvent.of(e.userEvent))), { changes: e.changes instanceof it ? e.changes : it.of(e.changes || [], i, t.facet(Mt)), selection: r && (r instanceof v ? r : v.single(r.anchor, r.head)), effects: zt(e.effects), annotations: s, scrollIntoView: !!e.scrollIntoView } } function Ht(e, i, s) { let r = Vt(e, i.length ? i[0] : {}, e.doc.length); i.length && !1 === i[0].filter && (s = !1); for (let t = 1; t < i.length; t++) { !1 === i[t].filter && (s = !1); var n = !!i[t].sequential; r = It(r, Vt(e, i[t], n ? r.changes.newLength : e.doc.length), n) } var t = Nt.create(e, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView); { var o = s ? (i => { let r = i.startState, s = !0; for (var t of r.facet(Tt)) { t = t(i); if (!1 === t) { s = !1; break } Array.isArray(t) && (s = !0 === s ? t : ((s, n) => { var o = []; for (let i = 0, r = 0; ;) { let t, e; if (i < s.length && (r == n.length || n[r] >= s[i])) t = s[i++], e = s[i++]; else { if (!(r < n.length)) return o; t = n[r++], e = n[r++] } !o.length || o[o.length - 1] < t ? o.push(t, e) : o[o.length - 1] < e && (o[o.length - 1] = e) } })(s, t)) } if (!0 !== s) { let t, e; var n; !1 === s ? (e = i.changes.invertedDesc, t = it.empty(r.doc.length)) : (n = i.changes.filter(s), t = n.changes, e = n.filtered.mapDesc(n.changes).invertedDesc), i = Nt.create(r, t, i.selection && i.selection.map(e), c.mapEffects(i.effects, e), i.annotations, i.scrollIntoView) } var e = r.facet(Dt); for (let t = e.length - 1; 0 <= t; t--) { var o = e[t](i); i = o instanceof Nt ? o : Array.isArray(o) && 1 == o.length && o[0] instanceof Nt ? o[0] : Ht(r, zt(o), !1) } return i })(t) : t; let e = o.startState, i = e.facet(Pt), r = o; for (let t = i.length - 1; 0 <= t; t--) { var a = i[t](o); a && Object.keys(a).length && (r = It(r, Vt(e, a, o.changes.newLength), !0)) } return r == o ? o : Nt.create(e, o.changes, o.selection, r.effects, r.annotations, r.scrollIntoView) } } Nt.time = Bt.define(), Nt.userEvent = Bt.define(), Nt.addToHistory = Bt.define(), Nt.remote = Bt.define(); var Wt = []; function zt(t) { return null == t ? Wt : Array.isArray(t) ? t : [t] } var Ft, m = (t => (t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t))(m = m || {}), qt = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; try { Ft = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u") } catch (t) { } function _t(i) { return e => { if (!/\S/.test(e)) return m.Space; if ((e => { if (Ft) return Ft.test(e); for (let t = 0; t < e.length; t++) { var i = e[t]; if (/\w/.test(i) || "Â€" < i && (i.toUpperCase() != i.toLowerCase() || qt.test(i))) return 1 } })(e)) return m.Word; for (let t = 0; t < i.length; t++)if (-1 < e.indexOf(i[t])) return m.Word; return m.Other } } var w = class tf { constructor(t, e, i, r, s, n) { this.config = t, this.doc = e, this.selection = i, this.values = r, this.status = t.statusTemplate.slice(), this.computeSlot = s, n && (n._state = this); for (let t = 0; t < this.config.dynamicSlots.length; t++)St(this, t << 1); this.computeSlot = null } field(t, e = !0) { t = this.config.address[t.id]; if (null != t) return St(this, t), Ct(this, t); if (e) throw new RangeError("Field is not present in this state") } update(...t) { return Ht(this, t, !0) } applyTransaction(i) { let t = this.config, { base: e, compartments: r } = t; for (var s of i.effects) s.is(yt.reconfigure) ? (t && (r = new Map, t.compartments.forEach((t, e) => r.set(e, t)), t = null), r.set(s.value.compartment, s.value.extension)) : s.is(c.reconfigure) ? (t = null, e = s.value) : s.is(c.appendConfig) && (t = null, e = zt(e).concat(s.value)); let n; n = t ? i.startState.values.slice() : (t = kt.resolve(e, r, this), new tf(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (t, e) => e.reconfigure(t, this), null).values); var o = i.startState.facet(Ot) ? i.newSelection : i.newSelection.asSingle(); new tf(t, i.newDoc, o, n, (t, e) => e.update(t, i), i) } replaceSelection(e) { return "string" == typeof e && (e = this.toText(e)), this.changeByRange(t => ({ changes: { from: t.from, to: t.to, insert: e }, range: v.cursor(t.from + e.length) })) } changeByRange(t) { var i = this.selection, e = t(i.ranges[0]); let r = this.changes(e.changes), s = [e.range], n = zt(e.effects); for (let e = 1; e < i.ranges.length; e++) { var o = t(i.ranges[e]), a = this.changes(o.changes), h = a.map(r); for (let t = 0; t < e; t++)s[t] = s[t].map(h); a = r.mapDesc(a, !0); s.push(o.range.map(a)), r = r.compose(h), n = c.mapEffects(n, h).concat(c.mapEffects(zt(o.effects), a)) } return { changes: r, selection: v.create(s, i.mainIndex), effects: n } } changes(t = []) { return t instanceof it ? t : it.of(t, this.doc.length, this.facet(tf.lineSeparator)) } toText(t) { return g.of(t.split(this.facet(tf.lineSeparator) || tt)) } sliceDoc(t = 0, e = this.doc.length) { return this.doc.sliceString(t, e, this.lineBreak) } facet(t) { var e = this.config.address[t.id]; return null == e ? t.default : (St(this, e), Ct(this, e)) } toJSON(t) { var e = { doc: this.sliceDoc(), selection: this.selection.toJSON() }; if (t) for (var i in t) { var r = t[i]; r instanceof p && null != this.config.address[r.id] && (e[i] = r.spec.toJSON(this.field(t[i]), this)) } return e } static fromJSON(t, e = {}, r) { if (!t || "string" != typeof t.doc) throw new RangeError("Invalid JSON representation for EditorState"); var s = []; if (r) for (var n in r) if (Object.prototype.hasOwnProperty.call(t, n)) { let e = r[n], i = t[n]; s.push(e.init(t => e.spec.fromJSON(i, t))) } return tf.create({ doc: t.doc, selection: v.fromJSON(t.selection), extensions: e.extensions ? s.concat([e.extensions]) : s }) } static create(t = {}) { var e = kt.resolve(t.extensions || [], new Map), i = t.doc instanceof g ? t.doc : g.of((t.doc || "").split(e.staticFacet(tf.lineSeparator) || tt)); let r = t.selection ? t.selection instanceof v ? t.selection : v.single(t.selection.anchor, t.selection.head) : v.single(0); return lt(r, i.length), e.staticFacet(Ot) || (r = r.asSingle()), new tf(e, i, r, e.dynamicSlots.map(() => null), (t, e) => e.create(t), null) } get tabSize() { return this.facet(tf.tabSize) } get lineBreak() { return this.facet(tf.lineSeparator) || "\n" } get readOnly() { return this.facet(Rt) } phrase(t, ...i) { for (var e of this.facet(tf.phrases)) if (Object.prototype.hasOwnProperty.call(e, t)) { t = e[t]; break } return t = i.length ? t.replace(/\$(\$|\d*)/g, (t, e) => "$" == e ? "$" : !(e = +(e || 1)) || e > i.length ? t : i[e - 1]) : t } languageDataAt(t, e, i = -1) { var r, s = []; for (r of this.facet(At)) for (var n of r(this, e, i)) Object.prototype.hasOwnProperty.call(n, t) && s.push(n[t]); return s } charCategorizer(t) { return _t(this.languageDataAt("wordChars", t).join("")) } wordAt(t) { var { text: e, from: i, length: r } = this.doc.lineAt(t), s = this.charCategorizer(t); let n = t - i, o = t - i; for (; 0 < n;) { var a = u(e, n, !1); if (s(e.slice(a, n)) != m.Word) break; n = a } for (; o < r;) { var h = u(e, o); if (s(e.slice(o, h)) != m.Word) break; o = h } return n == o ? null : v.range(n + i, o + i) } }; function jt(t, e, i = {}) { var r, s, n = {}; for (r of t) for (var o of Object.keys(r)) { var a = r[o], h = n[o]; if (void 0 === h) n[o] = a; else if (h !== a && void 0 !== a) { if (!Object.hasOwnProperty.call(i, o)) throw new Error("Config merge conflict for field " + o); n[o] = i[o](h, a) } } for (s in e) void 0 === n[s] && (n[s] = e[s]); return n } w.allowMultipleSelections = Ot, w.tabSize = d.define({ combine: t => t.length ? t[0] : 4 }), w.lineSeparator = Mt, w.readOnly = Rt, w.phrases = d.define({ compare(e, i) { var t = Object.keys(e), r = Object.keys(i); return t.length == r.length && t.every(t => e[t] == i[t]) } }), w.languageData = At, w.changeFilter = Tt, w.transactionFilter = Dt, w.transactionExtender = Pt, yt.reconfigure = c.define(); var Ut = class { eq(t) { return this == t } range(t, e = t) { return Qt.create(t, e, this) } }, Qt = (Ut.prototype.startSide = Ut.prototype.endSide = 0, Ut.prototype.point = !1, Ut.prototype.mapMode = l.TrackDel, class ef { constructor(t, e, i) { this.from = t, this.to = e, this.value = i } static create(t, e, i) { return new ef(t, e, i) } }); function $t(t, e) { return t.from - e.from || t.value.startSide - e.value.startSide } var Kt = class rf { constructor(t, e, i, r) { this.from = t, this.to = e, this.value = i, this.maxPoint = r } get length() { return this.to[this.to.length - 1] } findIndex(i, r, s, n = 0) { var o = s ? this.to : this.from; for (let t = n, e = o.length; ;) { if (t == e) return t; var a = t + e >> 1, h = o[a] - i || (s ? this.value[a].endSide : this.value[a].startSide) - r; if (a == t) return 0 <= h ? t : e; 0 <= h ? e = a : t = 1 + a } } between(i, r, s, n) { for (let t = this.findIndex(r, -1e9, !0), e = this.findIndex(s, 1e9, !1, t); t < e; t++)if (!1 === n(this.from[t] + i, this.to[t] + i, this.value[t])) return !1 } map(o, a) { let h = [], l = [], c = [], d = -1, u = -1; for (let n = 0; n < this.value.length; n++) { let t = this.value[n], e = this.from[n] + o, i = this.to[n] + o, r, s; if (e == i) { var f = a.mapPos(e, t.startSide, t.mapMode); if (null == f) continue; if (r = s = f, t.startSide != t.endSide && (s = a.mapPos(e, t.endSide)) < r) continue } else if (r = a.mapPos(e, t.startSide), s = a.mapPos(i, t.endSide), r > s || r == s && 0 < t.startSide && t.endSide <= 0) continue; (s - r || t.endSide - t.startSide) < 0 || (d < 0 && (d = r), t.point && (u = Math.max(u, s - r)), h.push(t), l.push(r - d), c.push(s - d)) } return { mapped: h.length ? new rf(l, c, h, u) : null, pos: d } } }, b = class sf { constructor(t, e, i, r) { this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = r } static create(t, e, i, r) { return new sf(t, e, i, r) } get length() { var t = this.chunk.length - 1; return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length) } get size() { if (this.isEmpty) return 0; let t = this.nextLayer.size; for (var e of this.chunk) t += e.value.length; return t } chunkEnd(t) { return this.chunkPos[t] + this.chunk[t].length } update(t) { let { add: e = [], sort: i = !1, filterFrom: r = 0, filterTo: s = this.length } = t; var n = t.filter; if (0 == e.length && !n) return this; if (i && (e = e.slice().sort($t)), this.isEmpty) return e.length ? sf.of(e) : this; let o = new Yt(this, null, -1).goto(0), a = 0, h = []; for (var l, c = new Xt; o.value || a < e.length;)a < e.length && 0 <= (o.from - e[a].from || o.startSide - e[a].value.startSide) ? (l = e[a++], c.addInner(l.from, l.to, l.value) || h.push(l)) : 1 == o.rangeIndex && o.chunkIndex < this.chunk.length && (a == e.length || this.chunkEnd(o.chunkIndex) < e[a].from) && (!n || r > this.chunkEnd(o.chunkIndex) || s < this.chunkPos[o.chunkIndex]) && c.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!n || r > o.to || s < o.from || n(o.from, o.to, o.value)) && !c.addInner(o.from, o.to, o.value) && h.push(Qt.create(o.from, o.to, o.value)), o.next()); return c.finishInner(this.nextLayer.isEmpty && !h.length ? sf.empty : this.nextLayer.update({ add: h, filter: n, filterFrom: r, filterTo: s })) } map(e) { if (e.empty || this.isEmpty) return this; let i = [], r = [], s = -1; for (let t = 0; t < this.chunk.length; t++) { var n = this.chunkPos[t], o = this.chunk[t], a = e.touchesRange(n, n + o.length); !1 === a ? (s = Math.max(s, o.maxPoint), i.push(o), r.push(e.mapPos(n))) : !0 === a && ({ mapped: a, pos: o } = o.map(n, e), a) && (s = Math.max(s, a.maxPoint), i.push(a), r.push(o)) } var t = this.nextLayer.map(e); return 0 == i.length ? t : new sf(r, i, t || sf.empty, s) } between(e, i, r) { if (!this.isEmpty) { for (let t = 0; t < this.chunk.length; t++) { var s = this.chunkPos[t], n = this.chunk[t]; if (s <= i && e <= s + n.length && !1 === n.between(s, e - s, i - s, r)) return } this.nextLayer.between(e, i, r) } } iter(t = 0) { return Jt.from([this]).goto(t) } get isEmpty() { return this.nextLayer == this } static iter(t, e = 0) { return Jt.from(t).goto(e) } static compare(t, e, i, r, s = -1) { var t = t.filter(t => 0 < t.maxPoint || !t.isEmpty && t.maxPoint >= s), e = e.filter(t => 0 < t.maxPoint || !t.isEmpty && t.maxPoint >= s), n = Gt(t, e, i); let o = new te(t, n, s), a = new te(e, n, s); i.iterGaps((t, e, i) => ee(o, t, a, e, i, r)), i.empty && 0 == i.length && ee(o, 0, a, 0, 0, r) } static eq(e, i, t = 0, r) { null == r && (r = 1e9 - 1); var s = e.filter(t => !t.isEmpty && i.indexOf(t) < 0), n = i.filter(t => !t.isEmpty && e.indexOf(t) < 0); if (s.length != n.length) return !1; if (!s.length) return !0; for (var o = Gt(s, n), a = new te(s, o, 0).goto(t), h = new te(n, o, 0).goto(t); ;) { if (a.to != h.to || !ie(a.active, h.active) || a.point && (!h.point || !a.point.eq(h.point))) return !1; if (a.to > r) return !0; a.next(), h.next() } } static spans(t, e, i, r, s = -1) { let n = new te(t, null, s).goto(e), o = e, a = n.openStart; for (; ;) { var h, l, c = Math.min(n.to, i); if (n.point ? (h = n.activeForPoint(n.to), l = n.pointFrom < e ? h.length + 1 : Math.min(h.length, a), r.point(o, c, n.point, h, l, n.pointRank), a = Math.min(n.openEnd(c), h.length)) : c > o && (r.span(o, c, n.active, a), a = n.openEnd(c)), n.to > i) return a + (n.point && n.to > i ? 1 : 0); o = n.to, n.next() } } static of(t, e = !1) { var i, r = new Xt; for (i of t instanceof Qt ? [t] : e ? (i => { if (1 < i.length) for (let t = i[0], e = 1; e < i.length; e++) { var r = i[e]; if (0 < $t(t, r)) return i.slice().sort($t); t = r } return i })(t) : t) r.add(i.from, i.to, i.value); return r.finish() } static join(i) { if (!i.length) return sf.empty; let r = i[i.length - 1]; for (let e = i.length - 2; 0 <= e; e--)for (let t = i[e]; t != sf.empty; t = t.nextLayer)r = new sf(t.chunkPos, t.chunk, r, Math.max(t.maxPoint, r.maxPoint)); return r } }; (b.empty = new b([], [], null, -1)).nextLayer = b.empty; var Xt = class nf { finishChunk(t) { this.chunks.push(new Kt(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []) } constructor() { this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null } add(t, e, i) { this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new nf)).add(t, e, i) } addInner(t, e, i) { var r = t - this.lastTo || i.startSide - this.last.endSide; if (r <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`"); return !(r < 0 || (250 == this.from.length && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), 0)) } addChunk(t, e) { if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0) return !1; this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t); var i = e.value.length - 1; return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0 } finish() { return this.finishInner(b.empty) } finishInner(t) { return this.from.length && this.finishChunk(!1), 0 == this.chunks.length || (t = b.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint), this.from = null), t } }; function Gt(t, e, i) { var r, s = new Map; for (r of t) for (let t = 0; t < r.chunk.length; t++)r.chunk[t].maxPoint <= 0 && s.set(r.chunk[t], r.chunkPos[t]); var n, o = new Set; for (n of e) for (let t = 0; t < n.chunk.length; t++) { var a = s.get(n.chunk[t]); null == a || (i ? i.mapPos(a) : a) != n.chunkPos[t] || null != i && i.touchesRange(a, a + n.chunk[t].length) || o.add(n.chunk[t]) } return o } var Yt = class { constructor(t, e, i, r = 0) { this.layer = t, this.skip = e, this.minPoint = i, this.rank = r } get startSide() { return this.value ? this.value.startSide : 0 } get endSide() { return this.value ? this.value.endSide : 0 } goto(t, e = -1e9) { return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this } gotoInner(t, e, i) { for (; this.chunkIndex < this.layer.chunk.length;) { var r = this.layer.chunk[this.chunkIndex]; if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < t || r.maxPoint < this.minPoint)) break; this.chunkIndex++, i = !1 } this.chunkIndex < this.layer.chunk.length && (e = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0), !i || this.rangeIndex < e) && this.setRangeIndex(e), this.next() } forward(t, e) { (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0) } next() { for (; ;) { if (this.chunkIndex == this.layer.chunk.length) { this.from = this.to = 1e9, this.value = null; break } var t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex]; if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break } } setRangeIndex(t) { if (t == this.layer.chunk[this.chunkIndex].value.length) { if (this.chunkIndex++, this.skip) for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++; this.rangeIndex = 0 } else this.rangeIndex = t } nextChunk() { this.chunkIndex++, this.rangeIndex = 0, this.next() } compare(t) { return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide } }, Jt = class of { constructor(t) { this.heap = t } static from(i, r = null, s = -1) { var n = []; for (let e = 0; e < i.length; e++)for (let t = i[e]; !t.isEmpty; t = t.nextLayer)t.maxPoint >= s && n.push(new Yt(t, r, s, e)); return 1 == n.length ? n[0] : new of(n) } get startSide() { return this.value ? this.value.startSide : 0 } goto(t, e = -1e9) { for (var i of this.heap) i.goto(t, e); for (let t = this.heap.length >> 1; 0 <= t; t--)Zt(this.heap, t); return this.next(), this } forward(t, e) { for (var i of this.heap) i.forward(t, e); for (let t = this.heap.length >> 1; 0 <= t; t--)Zt(this.heap, t); (this.to - t || this.value.endSide - e) < 0 && this.next() } next() { var t; 0 == this.heap.length ? (this.from = this.to = 1e9, this.value = null, this.rank = -1) : (t = this.heap[0], this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), Zt(this.heap, 0)) } }; function Zt(i, r) { for (var s = i[r]; ;) { let t = 1 + (r << 1); if (t >= i.length) break; let e = i[t]; if (t + 1 < i.length && 0 <= e.compare(i[t + 1]) && (e = i[t + 1], t++), s.compare(e) < 0) break; i[t] = s, i[r] = e, r = t } } var te = class { constructor(t, e, i) { this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Jt.from(t, e, i) } goto(t, e = -1e9) { return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this } forward(t, e) { for (; -1 < this.minActive && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0;)this.removeActive(this.minActive); this.cursor.forward(t, e) } removeActive(t) { re(this.active, t), re(this.activeTo, t), re(this.activeRank, t), this.minActive = ne(this.active, this.activeTo) } addActive(t) { let e = 0, { value: i, to: r, rank: s } = this.cursor; for (; e < this.activeRank.length && 0 < (s - this.activeRank[e] || r - this.activeTo[e]);)e++; se(this.active, e, i), se(this.activeTo, e, r), se(this.activeRank, e, s), t && se(t, e, this.cursor.from), this.minActive = ne(this.active, this.activeTo) } next() { for (var e = this.to, t = this.point, i = (this.point = null, this.openStart < 0 ? [] : null); ;) { var r = this.minActive; if (-1 < r && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) { if (this.activeTo[r] > e) { this.to = this.activeTo[r], this.endSide = this.active[r].endSide; break } this.removeActive(r), i && re(i, r) } else { if (!this.cursor.value) { this.to = this.endSide = 1e9; break } if (this.cursor.from > e) { this.to = this.cursor.from, this.endSide = this.cursor.startSide; break } r = this.cursor.value; if (r.point) { if (!(t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)) { this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide); break } } else this.addActive(i); this.cursor.next() } } if (i) { this.openStart = 0; for (let t = i.length - 1; 0 <= t && i[t] < e; t--)this.openStart++ } } activeForPoint(e) { if (!this.active.length) return this.active; var i = []; for (let t = this.active.length - 1; 0 <= t && !(this.activeRank[t] < this.pointRank); t--)(this.activeTo[t] > e || this.activeTo[t] == e && this.active[t].endSide >= this.point.endSide) && i.push(this.active[t]); return i.reverse() } openEnd(e) { let i = 0; for (let t = this.activeTo.length - 1; 0 <= t && this.activeTo[t] > e; t--)i++; return i } }; function ee(t, e, i, r, s, n) { t.goto(e), i.goto(r); var o = r + s; let a = r, h = r - e; for (; ;) { var l = t.to + h - i.to || t.endSide - i.endSide, c = l < 0 ? t.to + h : i.to, d = Math.min(c, o); if (t.point || i.point ? t.point && i.point && (t.point == i.point || t.point.eq(i.point)) && ie(t.activeForPoint(t.to), i.activeForPoint(i.to)) || n.comparePoint(a, d, t.point, i.point) : d > a && !ie(t.active, i.active) && n.compareRange(a, d, t.active, i.active), o < c) break; a = c, l <= 0 && t.next(), 0 <= l && i.next() } } function ie(e, i) { if (e.length == i.length) { for (let t = 0; t < e.length; t++)if (e[t] != i[t] && !e[t].eq(i[t])) return; return 1 } } function re(i, r) { for (let t = r, e = i.length - 1; t < e; t++)i[t] = i[t + 1]; i.pop() } function se(e, i, t) { for (let t = e.length - 1; t >= i; t--)e[t + 1] = e[t]; e[i] = t } function ne(e, i) { let r = -1, s = 1e9; for (let t = 0; t < i.length; t++)(i[t] - s || e[t].endSide - e[r].endSide) < 0 && (r = t, s = i[t]); return r } function oe(e, i, r = e.length) { let s = 0; for (let t = 0; t < r;)9 == e.charCodeAt(t) ? (s += i - s % i, t++) : (s++, t = u(e, t)); return s } function ae(i, r, s, t) { for (let t = 0, e = 0; ;) { if (e >= r) return t; if (t == i.length) break; e += 9 == i.charCodeAt(t) ? s - e % s : 1, t = u(i, t) } return !0 === t ? -1 : i.length } var t, he, le = "undefined" == typeof Symbol ? "__Í¼" : Symbol.for("Í¼"), ce = "undefined" == typeof Symbol ? "__styleSet" + Math.floor(1e8 * Math.random()) : Symbol("styleSet"), de = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : {}, ue = class { constructor(t, e) { this.rules = []; let c = (e || {}).finish; function d(t) { return /^@/.test(t) ? [t] : t.split(/,\s*/) } for (var i in t) !function t(i, e, r, s) { var n, o = [], a = /^@(\w+)\b/.exec(i[0]), h = a && "keyframes" == a[1]; if (a && null == e) return r.push(i[0] + ";"); for (n in e) { var l = e[n]; if (/&/.test(n)) t(n.split(/,\s*/).map(e => i.map(t => e.replace(/&/, t))).reduce((t, e) => t.concat(e)), l, r); else if (l && "object" == typeof l) { if (!a) throw new RangeError("The value of a property (" + n + ") should be a primitive value."); t(d(n), l, o, h) } else null != l && o.push(n.replace(/_.*/, "").replace(/[A-Z]/g, t => "-" + t.toLowerCase()) + ": " + l + ";") } (o.length || h) && r.push((!c || a || s ? i : i.map(c)).join(", ") + " {" + o.join(" ") + "}") }(d(i), t[i], this.rules) } getRules() { return this.rules.join("\n") } static newName() { var t = de[le] || 1; return de[le] = t + 1, "Í¼" + t.toString(36) } static mount(t, e, i) { let r = t[ce], s = i && i.nonce; r ? s && r.setNonce(s) : r = new pe(t, s), r.mount(Array.isArray(e) ? e : [e]) } }, fe = new Map, pe = class { constructor(t, e) { var i = t.ownerDocument || t, r = i.defaultView; if (!t.head && t.adoptedStyleSheets && r.CSSStyleSheet) { var s = fe.get(i); if (s) return t.adoptedStyleSheets = [s.sheet, ...t.adoptedStyleSheets], t[ce] = s; this.sheet = new r.CSSStyleSheet, t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets], fe.set(i, this) } else { this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e); s = t.head || t; s.insertBefore(this.styleTag, s.firstChild) } this.modules = [], t[ce] = this } mount(r) { var s = this.sheet; let n = 0, o = 0; for (let i = 0; i < r.length; i++) { let e = r[i], t = this.modules.indexOf(e); if (t < o && -1 < t && (this.modules.splice(t, 1), o--, t = -1), -1 == t) { if (this.modules.splice(o++, 0, e), s) for (let t = 0; t < e.rules.length; t++)s.insertRule(e.rules[t], n++) } else { for (; o < t;)n += this.modules[o++].rules.length; n += e.rules.length, o++ } } if (!s) { let e = ""; for (let t = 0; t < this.modules.length; t++)e += this.modules[t].getRules() + "\n"; this.styleTag.textContent = e } } setNonce(t) { this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t) } }, me = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, ge = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, ve = "undefined" != typeof navigator && /Mac/.test(navigator.platform), we = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent); for (t = 0; t < 10; t++)me[48 + t] = me[96 + t] = String(t); for (t = 1; t <= 24; t++)me[t + 111] = "F" + t; for (t = 65; t <= 90; t++)me[t] = String.fromCharCode(t + 32), ge[t] = String.fromCharCode(t); for (he in me) ge.hasOwnProperty(he) || (ge[he] = me[he]); function be(t) { let e; return (e = 11 != t.nodeType || t.getSelection ? t : t.ownerDocument).getSelection() } function ye(t, e) { return !!e && (t == e || t.contains(1 != e.nodeType ? e.parentNode : e)) } function xe(t, e) { if (!e.anchorNode) return !1; try { return ye(t, e.anchorNode) } catch (t) { return !1 } } function ke(t) { return 3 == t.nodeType ? Ee(t, 0, t.nodeValue.length).getClientRects() : 1 == t.nodeType ? t.getClientRects() : [] } function Se(t, e, i, r) { return !!i && (Ae(t, e, i, r, -1) || Ae(t, e, i, r, 1)) } function Ce(t) { for (var e = 0; ; e++)if (!(t = t.previousSibling)) return e } function Ae(t, e, i, r, s) { for (; ;) { if (t == i && e == r) return !0; if (e == (s < 0 ? 0 : Oe(t))) { if ("DIV" == t.nodeName) return !1; var n = t.parentNode; if (!n || 1 != n.nodeType) return !1; e = Ce(t) + (s < 0 ? 0 : 1), t = n } else { if (1 != t.nodeType) return !1; if (1 == (t = t.childNodes[e + (s < 0 ? -1 : 0)]).nodeType && "false" == t.contentEditable) return !1; e = s < 0 ? Oe(t) : 0 } } } function Oe(t) { return (3 == t.nodeType ? t.nodeValue : t.childNodes).length } function Me(t, e) { e = e ? t.left : t.right; return { left: e, right: e, top: t.top, bottom: t.bottom } } function Te(t, e) { let i = e.width / t.offsetWidth, r = e.height / t.offsetHeight; return (.995 < i && i < 1.005 || !isFinite(i) || Math.abs(e.width - t.offsetWidth) < 1) && (i = 1), (.995 < r && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), { scaleX: i, scaleY: r } } var De, Pe = class { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } eq(t) { return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset } setRange(t) { var { anchorNode: e, focusNode: i } = t; this.set(e, Math.min(t.anchorOffset, e ? Oe(e) : 0), i, Math.min(t.focusOffset, i ? Oe(i) : 0)) } set(t, e, i, r) { this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = r } }, Re = null; function Be(e) { if (e.setActive) return e.setActive(); if (Re) return e.focus(Re); var i = []; for (let t = e; t && (i.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode); if (e.focus(null == Re ? { get preventScroll() { return Re = { preventScroll: !0 }, !0 } } : void 0), !Re) { Re = !1; for (let t = 0; t < i.length;) { var r = i[t++], s = i[t++], n = i[t++]; r.scrollTop != s && (r.scrollTop = s), r.scrollLeft != n && (r.scrollLeft = n) } } } function Ee(t, e, i = e) { var r = De = De || document.createRange(); return r.setEnd(t, i), r.setStart(t, e), r } function Le(t, e, i) { e = { key: e, code: e, keyCode: i, which: i, cancelable: !0 }, i = new KeyboardEvent("keydown", e), i.synthetic = !0, t.dispatchEvent(i), e = new KeyboardEvent("keyup", e); return e.synthetic = !0, t.dispatchEvent(e), i.defaultPrevented || e.defaultPrevented } function Ne(t) { for (; t.attributes.length;)t.removeAttributeNode(t.attributes[0]) } function Ie(t) { return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4) } var Ve = class af { constructor(t, e, i = !0) { this.node = t, this.offset = e, this.precise = i } static before(t, e) { return new af(t.parentNode, Ce(t), e) } static after(t, e) { return new af(t.parentNode, Ce(t) + 1, e) } }, He = [], y = class hf { constructor() { this.parent = null, this.dom = null, this.flags = 2 } get overrideDOMText() { return null } get posAtStart() { return this.parent ? this.parent.posBefore(this) : 0 } get posAtEnd() { return this.posAtStart + this.length } posBefore(t) { let e = this.posAtStart; for (var i of this.children) { if (i == t) return e; e += i.length + i.breakAfter } throw new RangeError("Invalid child in posBefore") } posAfter(t) { return this.posBefore(t) + t.length } sync(i, r) { if (2 & this.flags) { var s, n, o = this.dom; let t = null, e; for (s of this.children) { if (7 & s.flags && (s.dom || !(e = t ? t.nextSibling : o.firstChild) || (n = hf.get(e)) && (n.parent || !n.canReuseDOM(s)) || s.reuseDOM(e), s.sync(i, r), s.flags &= -8), e = t ? t.nextSibling : o.firstChild, r && !r.written && r.node == o && e != s.dom && (r.written = !0), s.dom.parentNode == o) for (; e && e != s.dom;)e = We(e); else o.insertBefore(s.dom, e); t = s.dom } for ((e = t ? t.nextSibling : o.firstChild) && r && r.node == o && (r.written = !0); e;)e = We(e) } else if (1 & this.flags) for (var t of this.children) 7 & t.flags && (t.sync(i, r), t.flags &= -8) } reuseDOM(t) { } localPosFromDOM(e, i) { let r; if (e == this.dom) r = this.dom.childNodes[i]; else { let t = 0 == Oe(e) ? 0 : 0 == i ? -1 : 1; for (; ;) { var s = e.parentNode; if (s == this.dom) break; 0 == t && s.firstChild != s.lastChild && (t = e == s.firstChild ? -1 : 1), e = s } r = t < 0 ? e : e.nextSibling } if (r == this.dom.firstChild) return 0; for (; r && !hf.get(r);)r = r.nextSibling; if (!r) return this.length; for (let t = 0, e = 0; ; t++) { var n = this.children[t]; if (n.dom == r) return e; e += n.length + n.breakAfter } } domBoundsAround(r, s, n = 0) { let o = -1, a = -1, h = -1, l = -1; for (let t = 0, e = n, i = n; t < this.children.length; t++) { var c = this.children[t], d = e + c.length; if (e < r && s < d) return c.domBoundsAround(r, s, e); if (r <= d && -1 == o && (o = t, a = e), e > s && c.dom.parentNode == this.dom) { h = t, l = i; break } i = d, e = d + c.breakAfter } return { from: a, to: l < 0 ? n + this.length : l, startDOM: (o ? this.children[o - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: h < this.children.length && 0 <= h ? this.children[h].dom : null } } markDirty(t = !1) { this.flags |= 2, this.markParentsDirty(t) } markParentsDirty(e) { for (let t = this.parent; t; t = t.parent) { if (e && (t.flags |= 2), 1 & t.flags) return; t.flags |= 1, e = !1 } } setParent(t) { this.parent != t && (this.parent = t, 7 & this.flags) && this.markParentsDirty(!0) } setDOM(t) { this.dom != t && (this.dom && (this.dom.cmView = null), (this.dom = t).cmView = this) } get rootView() { for (let t = this; ;) { var e = t.parent; if (!e) return t; t = e } } replaceChildren(e, i, r = He) { this.markDirty(); for (let t = e; t < i; t++) { var s = this.children[t]; s.parent == this && r.indexOf(s) < 0 && s.destroy() } this.children.splice(e, i - e, ...r); for (let t = 0; t < r.length; t++)r[t].setParent(this) } ignoreMutation(t) { return !1 } ignoreEvent(t) { return !1 } childCursor(t = this.length) { return new ze(this.children, t, this.children.length) } childPos(t, e = 1) { return this.childCursor().findPos(t, e) } toString() { var t = this.constructor.name.replace("View", ""); return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "") } static get(t) { return t.cmView } get isEditable() { return !0 } get isWidget() { return !1 } get isHidden() { return !1 } merge(t, e, i, r, s, n) { return !1 } become(t) { return !1 } canReuseDOM(t) { return t.constructor == this.constructor && !(8 & (this.flags | t.flags)) } getSide() { return 0 } destroy() { for (var t of this.children) t.parent == this && t.destroy(); this.parent = null } }; function We(t) { var e = t.nextSibling; return t.parentNode.removeChild(t), e } y.prototype.breakAfter = 0; var ze = class { constructor(t, e, i) { this.children = t, this.pos = e, this.i = i, this.off = 0 } findPos(t, e = 1) { for (; ;) { if (t > this.pos || t == this.pos && (0 < e || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t - this.pos, this; var i = this.children[--this.i]; this.pos -= i.length + i.breakAfter } } }; function Fe(t, e, i, r, s, n, o, a, h) { var l = t.children, c = l.length ? l[e] : null, d = n.length ? n[n.length - 1] : null, u = d ? d.breakAfter : o; if (!(e == r && c && !o && !u && n.length < 2 && c.merge(i, s, n.length ? d : null, 0 == i, a, h))) { if (r < l.length) { let t = l[r]; t && (s < t.length || t.breakAfter && null != d && d.breakAfter) ? (e == r && (t = t.split(s), s = 0), !u && d && t.merge(0, s, d, !0, 0, h) ? n[n.length - 1] = t : ((s || t.children.length && !t.children[0].length) && t.merge(0, s, null, !1, 0, h), n.push(t))) : null != t && t.breakAfter && (d ? d.breakAfter = 1 : o = 1), r++ } for (c && (c.breakAfter = o, 0 < i) && (!o && n.length && c.merge(i, c.length, n[0], !1, a, 0) ? c.breakAfter = n.shift().breakAfter : (i < c.length || c.children.length && 0 == c.children[c.children.length - 1].length) && c.merge(i, c.length, null, !1, a, 0), e++); e < r && n.length;)if (l[r - 1].become(n[n.length - 1])) r--, n.pop(), h = n.length ? 0 : a; else { if (!l[e].become(n[0])) break; e++, n.shift(), a = n.length ? 0 : h } !n.length && e && r < l.length && !l[e - 1].breakAfter && l[r].merge(0, 0, l[e - 1], !1, a, h) && e--, (e < r || n.length) && t.replaceChildren(e, r, n) } } function qe(t, e, i, r, s, n) { var o, a = t.childCursor(), { i: h, off: l } = a.findPos(i, 1), { i: a, off: c } = a.findPos(e, -1); let d = e - i; for (o of r) d += o.length; t.length += d, Fe(t, a, c, h, l, r, 0, s, n) } var e = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" }, _e = "undefined" != typeof document ? document : { documentElement: { style: {} } }, je = /Edge\/(\d+)/.exec(e.userAgent), Ue = /MSIE \d/.test(e.userAgent), i = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e.userAgent), Qe = !!(Ue || i || je), $e = !Qe && /gecko\/(\d+)/i.test(e.userAgent), r = !Qe && /Chrome\/(\d+)/.exec(e.userAgent), Ke = "webkitFontSmoothing" in _e.documentElement.style, Xe = !Qe && /Apple Computer/.test(e.vendor), s = Xe && (/Mobile\/\w+/.test(e.userAgent) || 2 < e.maxTouchPoints), x = { mac: s || /Mac/.test(e.platform), windows: /Win/.test(e.platform), linux: /Linux|X11/.test(e.platform), ie: Qe, ie_version: Ue ? _e.documentMode || 6 : i ? +i[1] : je ? +je[1] : 0, gecko: $e, gecko_version: $e ? +(/Firefox\/(\d+)/.exec(e.userAgent) || [0, 0])[1] : 0, chrome: !!r, chrome_version: r ? +r[1] : 0, ios: s, android: /Android\b/.test(e.userAgent), webkit: Ke, safari: Xe, webkit_version: Ke ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0, tabSize: null != _e.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" }, Ge = class lf extends y { constructor(t) { super(), this.text = t } get length() { return this.text.length } createDOM(t) { this.setDOM(t || document.createTextNode(this.text)) } sync(t, e) { this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text) } reuseDOM(t) { 3 == t.nodeType && this.createDOM(t) } merge(t, e, i) { return !(8 & this.flags || i && (!(i instanceof lf) || 256 < this.length - (e - t) + i.length || 8 & i.flags) || (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), 0)) } split(t) { var e = new lf(this.text.slice(t)); return this.text = this.text.slice(0, t), this.markDirty(), e.flags |= 8 & this.flags, e } localPosFromDOM(t, e) { return t == this.dom ? e : e ? this.text.length : 0 } domAtPos(t) { return new Ve(this.dom, t) } domBoundsAround(t, e, i) { return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling } } coordsAt(s, n) { { var o = this.dom, a = o.nodeValue.length; let t = s = a < s ? a : s, e = s, i = 0; if (0 == s && n < 0 || s == a && 0 <= n ? x.chrome || x.gecko || (s ? (t--, i = 1) : e < a && (e++, i = -1)) : n < 0 ? t-- : e < a && e++, !(s = Ee(o, t, e).getClientRects()).length) return null; let r = s[(i ? i < 0 : 0 <= n) ? 0 : s.length - 1]; return x.safari && !i && 0 == r.width && (r = Array.prototype.find.call(s, t => t.width) || r), i ? Me(r, i < 0) : r || null } } }, Ye = class cf extends y { constructor(t, e = [], i = 0) { super(), this.mark = t, this.children = e, this.length = i; for (var r of e) r.setParent(this) } setAttrs(t) { if (Ne(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs) for (var e in this.mark.attrs) t.setAttribute(e, this.mark.attrs[e]); return t } canReuseDOM(t) { return super.canReuseDOM(t) && !(8 & (this.flags | t.flags)) } reuseDOM(t) { t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6) } sync(t, e) { this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, e) } merge(t, e, i, r, s, n) { return !(i && (!(i instanceof cf && i.mark.eq(this.mark)) || t && s <= 0 || e < this.length && n <= 0) || (qe(this, t, e, i ? i.children.slice() : [], s - 1, n - 1), this.markDirty(), 0)) } split(t) { let e = [], i = 0, r = -1, s = 0; for (var n of this.children) { var o = i + n.length; t < o && e.push(i < t ? n.split(t - i) : n), r < 0 && i >= t && (r = s), i = o, s++ } var a = this.length - t; return this.length = t, -1 < r && (this.children.length = r, this.markDirty()), new cf(this.mark, e, a) } domAtPos(t) { return ti(this, t) } coordsAt(t, e) { return ei(this, t, e) } }; var Je = class df extends y { static create(t, e, i) { return new df(t, e, i) } constructor(t, e, i) { super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null } split(t) { var e = df.create(this.widget, this.length - t, this.side); return this.length -= t, e } sync(t) { this.dom && this.widget.updateDOM(this.dom, t) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable) || (this.dom.contentEditable = "false") } getSide() { return this.side } merge(t, e, i, r, s, n) { return !(i && (!(i instanceof df && this.widget.compare(i.widget)) || 0 < t && s <= 0 || e < this.length && n <= 0) || (this.length = t + (i ? i.length : 0) + (this.length - e), 0)) } become(t) { return t instanceof df && t.side == this.side && this.widget.constructor == t.widget.constructor && (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) } ignoreMutation() { return !0 } ignoreEvent(t) { return this.widget.ignoreEvent(t) } get overrideDOMText() { if (0 == this.length) return g.empty; let t = this; for (; t.parent;)t = t.parent; var e = t.view, e = e && e.state.doc, i = this.posAtStart; return e ? e.slice(i, i + this.length) : g.empty } domAtPos(t) { return (this.length ? 0 == t : 0 < this.side) ? Ve.before(this.dom) : Ve.after(this.dom, t == this.length) } domBoundsAround() { return null } coordsAt(e, t) { t = this.widget.coordsAt(this.dom, e, t); if (t) return t; let i = this.dom.getClientRects(), r = null; if (!i.length) return null; var s = this.side ? this.side < 0 : 0 < e; for (let t = s ? i.length - 1 : 0; r = i[t], !(0 < e ? 0 == t : t == i.length - 1 || r.top < r.bottom); t += s ? -1 : 1); return Me(r, !s) } get isEditable() { return !1 } get isWidget() { return !0 } get isHidden() { return this.widget.isHidden } destroy() { super.destroy(), this.dom && this.widget.destroy(this.dom) } }, Ze = class uf extends y { constructor(t) { super(), this.side = t } get length() { return 0 } merge() { return !1 } become(t) { return t instanceof uf && t.side == this.side } split() { return new uf(this.side) } sync() { var t; this.dom || ((t = document.createElement("img")).className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t)) } getSide() { return this.side } domAtPos(t) { return 0 < this.side ? Ve.before(this.dom) : Ve.after(this.dom) } localPosFromDOM() { return 0 } domBoundsAround() { return null } coordsAt(t) { return this.dom.getBoundingClientRect() } get overrideDOMText() { return g.empty } get isHidden() { return !0 } }; function ti(t, e) { let i = t.dom, r = t.children, s = 0; for (let t = 0; s < r.length; s++) { var n = r[s], o = t + n.length; if (!(o == t && n.getSide() <= 0)) { if (e > t && e < o && n.dom.parentNode == i) return n.domAtPos(e - t); if (e <= t) break; t = o } } for (let t = s; 0 < t; t--) { var a = r[t - 1]; if (a.dom.parentNode == i) return a.domAtPos(a.length) } for (let t = s; t < r.length; t++) { var h = r[t]; if (h.dom.parentNode == i) return h.domAtPos(0) } return new Ve(i, 0) } function ei(t, e, a) { let h = null, l = -1, c = null, d = -1; !function i(r, s) { for (let t = 0, e = 0; t < r.children.length && e <= s; t++) { var n = r.children[t], o = e + n.length; s <= o && (n.children.length ? i(n, s - e) : (!c || c.isHidden && 0 < a) && (s < o || e == o && 0 < n.getSide()) ? (c = n, d = s - e) : (e < s || e == o && n.getSide() < 0 && !n.isHidden) && (h = n, l = s - e)), e = o } }(t, e); var e = (a < 0 ? h : c) || h || c; return e ? e.coordsAt(Math.max(0, e == h ? l : d), a) : (t = (e = t).dom.lastChild) ? (e = ke(t))[e.length - 1] || null : e.dom.getBoundingClientRect() } function ii(t, e) { for (var i in t) "class" == i && e.class ? e.class += " " + t.class : "style" == i && e.style ? e.style += ";" + t.style : e[i] = t[i]; return e } Ge.prototype.children = Je.prototype.children = Ze.prototype.children = He; var ri = Object.create(null); function si(t, e, i) { if (t != e) { t = t || ri, e = e || ri; var r, s = Object.keys(t), n = Object.keys(e); if (s.length - (i && -1 < s.indexOf(i) ? 1 : 0) != n.length - (i && -1 < n.indexOf(i) ? 1 : 0)) return !1; for (r of s) if (r != i && (-1 == n.indexOf(r) || t[r] !== e[r])) return !1 } return !0 } function ni(t, e, i) { let r = !1; if (e) for (var s in e) i && s in i || (r = !0, "style" == s ? t.style.cssText = "" : t.removeAttribute(s)); if (i) for (var n in i) e && e[n] == i[n] || (r = !0, "style" == n ? t.style.cssText = i[n] : t.setAttribute(n, i[n])); return r } var k = class ff extends y { constructor() { super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0 } merge(t, e, i, r, s, n) { if (i) { if (!(i instanceof ff)) return !1; this.dom || i.transferDOM(this) } return r && this.setDeco(i ? i.attrs : null), qe(this, t, e, i ? i.children.slice() : [], s, n), !0 } split(i) { var r = new ff; if (r.breakAfter = this.breakAfter, 0 != this.length) { let { i: e, off: t } = this.childPos(i); t && (r.append(this.children[e].split(t), 0), this.children[e].merge(t, this.children[e].length, null, !1, 0, 0), e++); for (let t = e; t < this.children.length; t++)r.append(this.children[t], 0); for (; 0 < e && 0 == this.children[e - 1].length;)this.children[--e].destroy(); this.children.length = e, this.markDirty(), this.length = i } return r } transferDOM(t) { this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null) } setDeco(t) { si(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t) } append(t, e) { !function t(e, i, r) { let s, n = e.children; 0 < r && i instanceof Ye && n.length && (s = n[n.length - 1]) instanceof Ye && s.mark.eq(i.mark) ? t(s, i.children[0], r - 1) : (n.push(i), i.setParent(e)), e.length += i.length }(this, t, e) } addLineDeco(t) { var e = t.spec.attributes, t = t.spec.class; e && (this.attrs = ii(e, this.attrs || {})), t && (this.attrs = ii({ class: t }, this.attrs || {})) } domAtPos(t) { return ti(this, t) } reuseDOM(t) { "DIV" == t.nodeName && (this.setDOM(t), this.flags |= 6) } sync(t, e) { this.dom ? 4 & this.flags && (Ne(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (ni(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, e); let i = this.dom.lastChild; for (; i && y.get(i) instanceof Ye;)i = i.lastChild; i && this.length && ("BR" == i.nodeName || 0 != (null == (t = y.get(i)) ? void 0 : t.isEditable) || x.ios && this.children.some(t => t instanceof Ge)) || ((e = document.createElement("BR")).cmIgnore = !0, this.dom.appendChild(e)) } measureTextSize() { if (0 == this.children.length || 20 < this.length) return null; let t = 0, e; for (var i of this.children) { if (!(i instanceof Ge) || /[^ -~]/.test(i.text)) return null; i = ke(i.dom); if (1 != i.length) return null; t += i[0].width, e = i[0].height } return t ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t / this.length, textHeight: e } : null } coordsAt(t, e) { t = ei(this, t, e); if (!this.children.length && t && this.parent) { var e = this.parent.view.viewState.heightOracle, i = t.bottom - t.top; if (Math.abs(i - e.lineHeight) < 2 && e.textHeight < i) return i = (i - e.textHeight) / 2, { top: t.top + i, bottom: t.bottom - i, left: t.left, right: t.left } } return t } become(t) { return !1 } covers() { return !0 } static find(i, r) { for (let t = 0, e = 0; t < i.children.length; t++) { var s = i.children[t], n = e + s.length; if (r <= n) { if (s instanceof ff) return s; if (r < n) break } e = n + s.breakAfter } return null } }, oi = class pf extends y { constructor(t, e, i) { super(), this.widget = t, this.length = e, this.deco = i, this.breakAfter = 0, this.prevWidget = null } merge(t, e, i, r, s, n) { return !(i && (!(i instanceof pf && this.widget.compare(i.widget)) || 0 < t && s <= 0 || e < this.length && n <= 0) || (this.length = t + (i ? i.length : 0) + (this.length - e), 0)) } domAtPos(t) { return 0 == t ? Ve.before(this.dom) : Ve.after(this.dom, t == this.length) } split(t) { var e = this.length - t, t = (this.length = t, new pf(this.widget, e, this.deco)); return t.breakAfter = this.breakAfter, t } get children() { return He } sync(t) { this.dom && this.widget.updateDOM(this.dom, t) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable) || (this.dom.contentEditable = "false") } get overrideDOMText() { return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : g.empty } domBoundsAround() { return null } become(t) { return t instanceof pf && t.widget.constructor == this.widget.constructor && (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) } ignoreMutation() { return !0 } ignoreEvent(t) { return this.widget.ignoreEvent(t) } get isEditable() { return !1 } get isWidget() { return !0 } coordsAt(t, e) { return this.widget.coordsAt(this.dom, t, e) } destroy() { super.destroy(), this.dom && this.widget.destroy(this.dom) } covers(t) { var { startSide: e, endSide: i } = this.deco; return e != i && (t < 0 ? e < 0 : 0 < i) } }, Qe = class { eq(t) { return !1 } updateDOM(t, e) { return !1 } compare(t) { return this == t || this.constructor == t.constructor && this.eq(t) } get estimatedHeight() { return -1 } get lineBreaks() { return 0 } ignoreEvent(t) { return !0 } coordsAt(t, e, i) { return null } get isHidden() { return !1 } get editable() { return !1 } destroy(t) { } }, A = (t => (t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t))(A = A || {}), C = class extends Ut { constructor(t, e, i, r) { super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = r } get heightRelevant() { return !1 } static mark(t) { return new ai(t) } static widget(t) { var e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block; return e += i && !t.inlineOrder ? 0 < e ? 3e8 : -4e8 : 0 < e ? 1e8 : -1e8, new li(t, e, e, i, t.widget || null, !1) } static replace(t) { let e = !!t.block, i, r; var s, n; return r = t.isBlockGap ? (i = -5e8, 4e8) : ({ start: s, end: n } = ci(t, e), i = (s ? e ? -3e8 : -1 : 5e8) - 1, 1 + (n ? e ? 2e8 : 1 : -6e8)), new li(t, i, r, e, t.widget || null, !0) } static line(t) { return new hi(t) } static set(t, e = !1) { return b.of(t, e) } hasHeight() { return !!this.widget && -1 < this.widget.estimatedHeight } }, ai = (C.none = b.empty, class mf extends C { constructor(t) { var { start: e, end: i } = ci(t); super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null } eq(t) { var e; return this == t || t instanceof mf && this.tagName == t.tagName && (this.class || (null == (e = this.attrs) ? void 0 : e.class)) == (t.class || (null == (e = t.attrs) ? void 0 : e.class)) && si(this.attrs, t.attrs, "class") } range(t, e = t) { if (e <= t) throw new RangeError("Mark decorations may not be empty"); return super.range(t, e) } }), hi = (ai.prototype.point = !1, class gf extends C { constructor(t) { super(-2e8, -2e8, null, t) } eq(t) { return t instanceof gf && this.spec.class == t.spec.class && si(this.spec.attributes, t.spec.attributes) } range(t, e = t) { if (e != t) throw new RangeError("Line decoration ranges must be zero-length"); return super.range(t, e) } }), li = (hi.prototype.mapMode = l.TrackBefore, hi.prototype.point = !0, class vf extends C { constructor(t, e, i, r, s, n) { super(e, i, s, t), this.block = r, this.isReplace = n, this.mapMode = r ? e <= 0 ? l.TrackBefore : l.TrackAfter : l.TrackDel } get type() { return this.startSide != this.endSide ? A.WidgetRange : this.startSide <= 0 ? A.WidgetBefore : A.WidgetAfter } get heightRelevant() { return this.block || !!this.widget && (5 <= this.widget.estimatedHeight || 0 < this.widget.lineBreaks) } eq(t) { return t instanceof vf && (e = this.widget, i = t.widget, e == i || !!(e && i && e.compare(i))) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide; var e, i } range(t, e = t) { if (this.isReplace && (e < t || t == e && 0 < this.startSide && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration"); if (this.isReplace || e == t) return super.range(t, e); throw new RangeError("Widget decorations can only have zero-length ranges") } }); function ci(t, e = !1) { let { inclusiveStart: i, inclusiveEnd: r } = t; return null == i && (i = t.inclusive), null == r && (r = t.inclusive), { start: null != i ? i : e, end: null != r ? r : e } } function di(t, e, i, r = 0) { var s = i.length - 1; 0 <= s && i[s] + r >= t ? i[s] = Math.max(i[s], e) : i.push(t, e) } li.prototype.point = !0; var ui = class wf { constructor(t, e, i, r) { this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e } posCovered() { var t; return 0 == this.content.length ? !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos : !((t = this.content[this.content.length - 1]).breakAfter || t instanceof oi && t.deco.endSide < 0) } getLine() { return this.curLine || (this.content.push(this.curLine = new k), this.atCursorPos = !0), this.curLine } flushBuffer(t = this.bufferMarks) { this.pendingBuffer && (this.curLine.append(fi(new Ze(-1), t), t.length), this.pendingBuffer = 0) } addBlockWidget(t) { this.flushBuffer(), this.curLine = null, this.content.push(t) } finish(t) { this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || t && this.content.length && this.content[this.content.length - 1] instanceof oi || this.getLine() } buildText(t, e, i) { for (; 0 < t;) { if (this.textOff == this.text.length) { var { value: r, lineBreak: s, done: n } = this.cursor.next(this.skip); if (this.skip = 0, n) throw new Error("Ran out of text content when drawing inline views"); if (s) { this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--; continue } this.text = r, this.textOff = 0 } n = Math.min(this.text.length - this.textOff, t, 512); this.flushBuffer(e.slice(e.length - i)), this.getLine().append(fi(new Ge(this.text.slice(this.textOff, this.textOff + n)), e), i), this.atCursorPos = !0, this.textOff += n, t -= n, i = 0 } } span(t, e, i, r) { this.buildText(e - t, i, r), this.pos = e, this.openStart < 0 && (this.openStart = r) } point(t, e, i, r, s, n) { if (this.disallowBlockEffectsFor[n] && i instanceof li) { if (i.block) throw new RangeError("Block decorations may not be specified via plugins"); if (e > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins") } var o, a, h, l, n = e - t; i instanceof li ? i.block ? (0 < i.startSide && !this.posCovered() && this.getLine(), this.addBlockWidget(new oi(i.widget || new pi("div"), n, i))) : (o = Je.create(i.widget || new pi("span"), n, n ? 0 : i.startSide), a = this.atCursorPos && !o.isEditable && s <= r.length && (t < e || 0 < i.startSide), h = !o.isEditable && (t < e || s > r.length || i.startSide <= 0), l = this.getLine(), 2 != this.pendingBuffer || a || o.isEditable || (this.pendingBuffer = 0), this.flushBuffer(r), a && (l.append(fi(new Ze(1), r), s), s = r.length + Math.max(0, s - r.length)), l.append(fi(o, r), s), this.atCursorPos = h, this.pendingBuffer = h ? t < e || s > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice())) : this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i), n && (this.textOff + n <= this.text.length ? this.textOff += n : (this.skip += n - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = s) } static build(t, e, i, r, s) { t = new wf(t, e, i, s); return t.openEnd = b.spans(r, e, i, t), t.openStart < 0 && (t.openStart = t.openEnd), t.finish(t.openEnd), t } }; function fi(t, e) { for (var i of e) t = new Ye(i, [t], t.length); return t } var pi = class extends Qe { constructor(t) { super(), this.tag = t } eq(t) { return t.tag == this.tag } toDOM() { return document.createElement(this.tag) } updateDOM(t) { return t.nodeName.toLowerCase() == this.tag } get isHidden() { return !0 } }, O = (t => (t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t))(O = O || {}), mi = O.LTR, gi = O.RTL; function vi(e) { var i = []; for (let t = 0; t < e.length; t++)i.push(1 << +e[t]); return i } var wi, bi = vi("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), yi = vi("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), xi = Object.create(null), ki = []; for (wi of ["()", "[]", "{}"]) { var Si = wi.charCodeAt(0), Ci = wi.charCodeAt(1); xi[Si] = Ci, xi[Ci] = -Si } function Ai(t) { return t <= 247 ? bi[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? yi[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1 } var Oi = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/, Mi = class { get dir() { return this.level % 2 ? gi : mi } constructor(t, e, i) { this.from = t, this.to = e, this.level = i } side(t, e) { return this.dir == e == t ? this.to : this.from } forward(t, e) { return t == (this.dir == e) } static find(e, i, r, s) { let n = -1; for (let t = 0; t < e.length; t++) { var o = e[t]; if (o.from <= i && o.to >= i) { if (o.level == r) return t; (n < 0 || (0 != s ? s < 0 ? o.from < i : o.to > i : e[n].level > o.level)) && (n = t) } } if (n < 0) throw new RangeError("Index out of range"); return n } }; var N = []; function Ti(t, e, i, r, s, n, o) { var a = e % 2 ? 2 : 1, h = t, l = s, c = n, d = r, u = a; for (let t = 0; t <= d.length; t++) { var f = t ? d[t - 1].to : l, p = t < d.length ? d[t].from : c, m = t ? 256 : u; for (let e = f, i = m, r = m; e < p; e++) { let t = Ai(h.charCodeAt(e)); 512 == t ? t = i : 8 == t && 4 == r && (t = 16), N[e] = 4 == t ? 2 : t, 7 & t && (r = t), i = t } for (let i = f, r = m, s = m; i < p; i++) { let t = N[i]; if (128 == t) i < p - 1 && r == N[i + 1] && 24 & r ? t = N[i] = r : N[i] = 256; else if (64 == t) { let e = i + 1; for (; e < p && 64 == N[e];)e++; var g = i && 8 == r || e < c && 8 == N[e] ? 1 == s ? 1 : 8 : 256; for (let t = i; t < e; t++)N[t] = g; i = e - 1 } else 8 == t && 1 == s && (N[i] = 1); 7 & (r = t) && (s = t) } } var v = t, w = s, b = n, y = r, x = a, k = 1 == x ? 2 : 1; for (let t = 0, s = 0, n = 0; t <= y.length; t++) { var S = t ? y[t - 1].to : w, C = t < y.length ? y[t].from : b; for (let e = S, t, i, r; e < C; e++)if (i = xi[t = v.charCodeAt(e)]) if (i < 0) { for (let t = s - 3; 0 <= t; t -= 3)if (ki[t + 1] == -i) { var A = ki[t + 2], A = 2 & A ? x : 4 & A ? 1 & A ? k : x : 0; A && (N[e] = N[ki[t]] = A), s = t; break } } else { if (189 == ki.length) break; ki[s++] = e, ki[s++] = t, ki[s++] = n } else if (2 == (r = N[e]) || 1 == r) { var O = r == x; n = O ? 0 : 1; for (let t = s - 3; 0 <= t; t -= 3) { var M = ki[t + 2]; if (2 & M) break; if (O) ki[t + 2] |= 2; else { if (4 & M) break; ki[t + 2] |= 4 } } } } var T = s, D = n, P = r, R = a; for (let n = 0, i = R; n <= P.length; n++) { let t = n ? P[n - 1].to : T, e = n < P.length ? P[n].from : D; for (let s = t; s < e;) { var B = N[s]; if (256 == B) { let r = s + 1; for (; ;)if (r == e) { if (n == P.length) break; r = P[n++].to, e = n < P.length ? P[n].from : D } else { if (256 != N[r]) break; r++ } var E = 1 == i, L = E == (1 == (r < D ? N[r] : R)) ? E ? 1 : 2 : R; for (let t = r, e = n, i = e ? P[e - 1].to : T; t > s;)t == i && (t = P[--e].from, i = e ? P[e - 1].to : T), N[--t] = L; s = r } else i = B, s++ } } !function n(o, a, h, l, c, d, u) { var f = l % 2 ? 2 : 1; if (l % 2 == c % 2) for (let r = a, s = 0; r < h;) { let t = !0, e = !1; (s == d.length || r < d[s].from) && (p = N[r]) != f && (t = !1, e = 16 == p); var p, m = t || 1 != f ? null : [], g = t ? l : l + 1; let i = r; t: for (; ;)if (s < d.length && i == d[s].from) { if (e) break; var v = d[s]; if (!t) for (let t = v.to, e = s + 1; ;) { if (t == h) break t; if (!(e < d.length && d[e].from == t)) { if (N[t] == f) break t; break } t = d[e++].to } s++, m ? m.push(v) : (v.from > r && u.push(new Mi(r, v.from, g)), Ti(o, v.direction == mi != !(g % 2) ? l + 1 : l, c, v.inner, v.from, v.to, u), r = v.to), i = v.to } else { if (i == h || (t ? N[i] != f : N[i] == f)) break; i++ } m ? n(o, r, i, l + 1, c, m, u) : r < i && u.push(new Mi(r, i, g)), r = i } else for (let r = h, s = d.length; r > a;) { let t = !0, e = !1; (!s || r > d[s - 1].to) && (w = N[r - 1]) != f && (t = !1, e = 16 == w); var w, b = t || 1 != f ? null : [], y = t ? l : l + 1; let i = r; t: for (; ;)if (s && i == d[s - 1].to) { if (e) break; var x = d[--s]; if (!t) for (let t = x.from, e = s; ;) { if (t == a) break t; if (!e || d[e - 1].to != t) { if (N[t - 1] == f) break t; break } t = d[--e].from } b ? b.push(x) : (x.to < r && u.push(new Mi(x.to, r, y)), Ti(o, x.direction == mi != !(y % 2) ? l + 1 : l, c, x.inner, x.from, x.to, u), r = x.from), i = x.from } else { if (i == a || (t ? N[i - 1] != f : N[i - 1] == f)) break; i-- } b ? n(o, i, r, l + 1, c, b, u) : i < r && u.push(new Mi(i, r, y)), r = i } }(t, s, n, e, i, r, o) } function Di(t) { return [new Mi(0, t, 0)] } var Pi = ""; var Ri = d.define(), Bi = d.define(), Ei = d.define(), Li = d.define(), Ni = d.define(), Ii = d.define(), Vi = d.define(), Hi = d.define({ combine: t => t.some(t => t) }), Wi = d.define({ combine: t => t.some(t => t) }), zi = class bf { constructor(t, e = "nearest", i = "nearest", r = 5, s = 5, n = !1) { this.range = t, this.y = e, this.x = i, this.yMargin = r, this.xMargin = s, this.isSnapshot = n } map(t) { return t.empty ? this : new bf(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot) } clip(t) { return this.range.to <= t.doc.length ? this : new bf(v.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot) } }, Fi = c.define({ map: (t, e) => t.map(e) }); function qi(t, e, i) { t = t.facet(Li); t.length ? t[0](e) : window.onerror ? window.onerror(String(e), i, void 0, void 0, e) : i ? console.error(i + ":", e) : console.error(e) } var _i = d.define({ combine: t => !t.length || t[0] }), ji = 0, Ui = d.define(), a = class yf { constructor(t, e, i, r, s) { this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = r, this.extension = s(this) } static define(t, e) { let { eventHandlers: i, eventObservers: r, provide: s, decorations: n } = e || {}; return new yf(ji++, t, i, r, e => { var t = [Ui.of(e)]; return n && t.push(Xi.of(t => { t = t.plugin(e); return t ? n(t) : C.none })), s && t.push(s(e)), t }) } static fromClass(e, t) { return yf.define(t => new e(t), t) } }, Qi = class { constructor(t) { this.spec = t, this.mustUpdate = null, this.value = null } update(e) { if (this.value) { if (this.mustUpdate) { var i = this.mustUpdate; if (this.mustUpdate = null, this.value.update) try { this.value.update(i) } catch (t) { if (qi(i.state, t, "CodeMirror plugin crashed"), this.value.destroy) try { this.value.destroy() } catch (t) { } this.deactivate() } } } else if (this.spec) try { this.value = this.spec.create(e) } catch (t) { qi(e.state, t, "CodeMirror plugin crashed"), this.deactivate() } return this } destroy(e) { var t; if (null != (t = this.value) && t.destroy) try { this.value.destroy() } catch (t) { qi(e.state, t, "CodeMirror plugin crashed") } } deactivate() { this.spec = this.value = null } }, $i = d.define(), Ki = d.define(), Xi = d.define(), Gi = d.define(), Yi = d.define(), Ji = d.define(); function Zi(e, l) { var t = e.state.facet(Ji); if (!t.length) return t; t = t.map(t => t instanceof Function ? t(e) : t); let i = []; return b.spans(t, l.from, l.to, { point() { }, span(t, e, r, s) { var n, o = t - l.from, a = e - l.from; let h = i; for (let i = r.length - 1; 0 <= i; i--, s--) { let t = r[i].spec.bidiIsolate, e; null == t && (t = ((e, i, r) => { for (let t = i; t < r; t++) { var s = Ai(e.charCodeAt(t)); if (1 == s) return mi; if (2 == s || 4 == s) return gi } return mi })(l.text, o, a)), h = (0 < s && h.length && (e = h[h.length - 1]).to == o && e.direction == t ? (e.to = a, e) : (n = { from: o, to: a, direction: t, inner: [] }, h.push(n), n)).inner } } }), i } var tr = d.define(); function er(t) { let e = 0, i = 0, r = 0, s = 0; for (var n of t.state.facet(tr)) { n = n(t); n && (null != n.left && (e = Math.max(e, n.left)), null != n.right && (i = Math.max(i, n.right)), null != n.top && (r = Math.max(r, n.top)), null != n.bottom) && (s = Math.max(s, n.bottom)) } return { left: e, right: i, top: r, bottom: s } } var ir = d.define(), rr = class xf { constructor(t, e, i, r) { this.fromA = t, this.toA = e, this.fromB = i, this.toB = r } join(t) { return new xf(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB)) } addToSet(t) { let e = t.length, i = this; for (; 0 < e; e--) { var r = t[e - 1]; if (!(r.fromA > i.toA)) { if (r.toA < i.fromA) break; i = i.join(r), t.splice(e - 1, 1) } } return t.splice(e, 0, i), t } static extendWithRanges(s, n) { if (0 == n.length) return s; var o = []; for (let t = 0, e = 0, i = 0, r = 0; ; t++) { for (var a = t == s.length ? null : s[t], h = i - r, l = a ? a.fromB : 1e9; e < n.length && n[e] < l;) { var c = n[e], d = n[e + 1], c = Math.max(r, c), u = Math.min(l, d); if (c <= u && new xf(c + h, u + h, c, u).addToSet(o), l < d) break; e += 2 } if (!a) return o; new xf(a.fromA, a.toA, a.fromB, a.toB).addToSet(o), i = a.toA, r = a.toB } } }, sr = class kf { constructor(t, e, i) { this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = it.empty(this.startState.doc.length); for (var r of i) this.changes = this.changes.compose(r.changes); let s = []; this.changes.iterChangedRanges((t, e, i, r) => s.push(new rr(t, e, i, r))), this.changedRanges = s } static create(t, e, i) { return new kf(t, e, i) } get viewportChanged() { return 0 < (4 & this.flags) } get heightChanged() { return 0 < (2 & this.flags) } get geometryChanged() { return this.docChanged || 0 < (10 & this.flags) } get focusChanged() { return 0 < (1 & this.flags) } get docChanged() { return !this.changes.empty } get selectionSet() { return this.transactions.some(t => t.selection) } get empty() { return 0 == this.flags && 0 == this.transactions.length } }, nr = class extends y { get length() { return this.view.state.doc.length } constructor(t) { super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = new Set, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new k], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new rr(0, 0, 0, t.state.doc.length)], 0, null) } update(t) { let e, i = t.changedRanges, r = (0 < this.minWidth && i.length && (i.every(({ fromA: t, toA: e }) => e < this.minWidthFrom || t > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), -1); 0 <= this.view.inputState.composing && (null != (e = this.domChanged) && e.newSel ? r = this.domChanged.newSel.head : ((t, i) => { let r = !1; return i && t.iterChangedRanges((t, e) => { t < i.to && e > i.from && (r = !0) }), r })(t.changes, this.hasComposition) || t.selectionSet || (r = t.state.selection.main.head)); var s, n = -1 < r ? ((e, t, i) => { if (!(i = ar(e, i))) return null; var { node: r, from: s, to: n } = i, o = r.nodeValue; if (/[\n\r]/.test(o)) return null; if (e.state.doc.sliceString(i.from, i.to) != o) return null; var i = t.invertedDesc, a = new rr(i.mapPos(s), i.mapPos(n), s, n), h = []; for (let t = r.parentNode; ; t = t.parentNode) { var l = y.get(t); if (l instanceof Ye) h.push({ node: t, deco: l.mark }); else { if (l instanceof k || "DIV" == t.nodeName && t.parentNode == e.contentDOM) return { range: a, text: r, marks: h, line: t }; if (t == e.contentDOM) return null; h.push({ node: t, deco: new ai({ inclusive: !0, attributes: (e => { var i = Object.create(null); for (let t = 0; t < e.attributes.length; t++) { var r = e.attributes[t]; i[r.name] = r.value } return i })(t), tagName: t.tagName.toLowerCase() }) }) } } })(this.view, t.changes, r) : null, o = (this.domChanged = null, this.hasComposition && (this.markedForComposition.clear(), { from: o, to: a } = this.hasComposition, i = new rr(o, a, t.changes.mapPos(o, -1), t.changes.mapPos(a, 1)).addToSet(i.slice())), this.hasComposition = n ? { from: n.range.fromB, to: n.range.toB } : null, (x.ie || x.chrome) && !n && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0), this.decorations), a = this.updateDeco(), h = (o = o, a = a, h = t.changes, s = new lr, b.compare(o, a, h, s), s.changes); return i = rr.extendWithRanges(i, h), !!(7 & this.flags || 0 != i.length) && (this.updateInner(i, t.startState.doc.length, n), t.transactions.length && (this.lastUpdate = Date.now()), !0) } updateInner(t, e, i) { this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e, i); let r = this.view.observer; r.ignore(() => { this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : ""; var t = x.chrome || x.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0; this.sync(this.view, t), this.flags &= -8, t && (t.written || r.selectionRange.focusNode != t.node) && (this.forceSelection = !0), this.dom.style.height = "" }), this.markedForComposition.forEach(t => t.flags &= -9); var s = []; if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (var n of this.children) n instanceof oi && n.widget instanceof or && s.push(n.dom); r.updateGaps(s) } updateChildren(t, e, l) { var c = l ? l.range.addToSet(t.slice()) : t, d = this.childCursor(e); for (let h = c.length - 1; ; h--) { var u = 0 <= h ? c[h] : null; if (!u) break; let { fromA: t, toA: e, fromB: i, toB: r } = u, s, n, o, a; l && l.range.fromB < r && l.range.toB > i ? (u = ui.build(this.view.state.doc, i, l.range.fromB, this.decorations, this.dynamicDecorationMap), p = ui.build(this.view.state.doc, l.range.toB, r, this.decorations, this.dynamicDecorationMap), n = u.breakAtStart, o = u.openStart, a = p.openEnd, f = this.compositionView(l), p.breakAtStart ? f.breakAfter = 1 : p.content.length && f.merge(f.length, f.length, p.content[0], !1, p.openStart, 0) && (f.breakAfter = p.content[0].breakAfter, p.content.shift()), u.content.length && f.merge(0, 0, u.content[u.content.length - 1], !0, 0, u.openEnd) && u.content.pop(), s = u.content.concat(f).concat(p.content)) : { content: s, breakAtStart: n, openStart: o, openEnd: a } = ui.build(this.view.state.doc, i, r, this.decorations, this.dynamicDecorationMap); var { i: u, off: f } = d.findPos(e, 1), { i: p, off: m } = d.findPos(t, -1); Fe(this, p, m, u, f, s, n, o, a) } l && this.fixCompositionDOM(l) } compositionView(t) { let e = new Ge(t.text.nodeValue); e.flags |= 8; for (var { deco: i } of t.marks) e = new Ye(i, [e], e.length); t = new k; return t.append(e, 0), t } fixCompositionDOM(e) { var i = (t, e) => { e.flags |= 8 | (e.children.some(t => 7 & t.flags) ? 1 : 0), this.markedForComposition.add(e); var i = y.get(t); i && i != e && (i.dom = null), e.setDOM(t) }; let r = this.childPos(e.range.fromB, 1), s = this.children[r.i]; i(e.line, s); for (let t = e.marks.length - 1; -1 <= t; t--)r = s.childPos(r.off, 1), s = s.children[r.i], i(0 <= t ? e.marks[t].node : e.text, s) } updateSelection(t = !1, e = !1) { !t && this.view.observer.selectionRange.focusNode || this.view.observer.readSelectionRange(); let a = this.view.root.activeElement, i = a == this.dom, h = !i && xe(this.dom, this.view.observer.selectionRange) && !(a && this.dom.contains(a)); if (i || e || h) { let e = this.forceSelection, r = (this.forceSelection = !1, this.view.state.selection.main), s = this.moveToLine(this.domAtPos(r.anchor)), n = r.empty ? s : this.moveToLine(this.domAtPos(r.head)); if (x.gecko && r.empty && !this.hasComposition && 1 == (t = s).node.nodeType && t.node.firstChild && (0 == t.offset || "false" == t.node.childNodes[t.offset - 1].contentEditable) && (t.offset == t.node.childNodes.length || "false" == t.node.childNodes[t.offset].contentEditable)) { let t = document.createTextNode(""); this.view.observer.ignore(() => s.node.insertBefore(t, s.node.childNodes[s.offset] || null)), s = n = new Ve(t, 0), e = !0 } let o = this.view.observer.selectionRange; !e && o.focusNode && (Se(s.node, s.offset, o.anchorNode, o.anchorOffset) && Se(n.node, n.offset, o.focusNode, o.focusOffset) || this.suppressWidgetCursorChange(o, r)) || (this.view.observer.ignore(() => { x.android && x.chrome && this.dom.contains(o.focusNode) && ((e, i) => { for (let t = e; t && t != i; t = t.assignedSlot || t.parentNode)if (1 == t.nodeType && "false" == t.contentEditable) return 1 })(o.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 })); var t, e = be(this.view.root); if (e) if (r.empty) x.gecko && (i = s.node, t = s.offset, i = 1 != i.nodeType ? 0 : (t && "false" == i.childNodes[t - 1].contentEditable ? 1 : 0) | (t < i.childNodes.length && "false" == i.childNodes[t].contentEditable ? 2 : 0)) && 3 != i && (t = hr(s.node, s.offset, 1 == i ? 1 : -1)) && (s = new Ve(t.node, t.offset)), e.collapse(s.node, s.offset), null != r.bidiLevel && void 0 !== e.caretBidiLevel && (e.caretBidiLevel = r.bidiLevel); else if (e.extend) { e.collapse(s.node, s.offset); try { e.extend(n.node, n.offset) } catch (t) { } } else { var i = document.createRange(); r.anchor > r.head && ([s, n] = [n, s]), i.setEnd(n.node, n.offset), i.setStart(s.node, s.offset), e.removeAllRanges(), e.addRange(i) } h && this.view.root.activeElement == this.dom && (this.dom.blur(), a) && a.focus() }), this.view.observer.setSelectionRange(s, n)), this.impreciseAnchor = s.precise ? null : new Ve(o.anchorNode, o.anchorOffset), this.impreciseHead = n.precise ? null : new Ve(o.focusNode, o.focusOffset) } } suppressWidgetCursorChange(t, e) { return this.hasComposition && e.empty && Se(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head } enforceCursorAssoc() { var t, e, i, r, s, n, o; this.hasComposition || (t = this.view, e = t.state.selection.main, i = be(t.root), { anchorNode: r, anchorOffset: s } = t.observer.selectionRange, i && e.empty && e.assoc && i.modify && (o = k.find(this, e.head)) && (n = o.posAtStart, e.head == n || e.head == n + o.length || (n = this.coordsAt(e.head, -1), o = this.coordsAt(e.head, 1), !n) || !o || n.bottom > o.top || (n = this.domAtPos(e.head + e.assoc), i.collapse(n.node, n.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange(), o = t.observer.selectionRange, t.docView.posFromDOM(o.anchorNode, o.anchorOffset) != e.from && i.collapse(r, s)))) } moveToLine(e) { let i = this.dom, r; if (e.node != i) return e; for (let t = e.offset; !r && t < i.childNodes.length; t++) { var s = y.get(i.childNodes[t]); s instanceof k && (r = s.domAtPos(0)) } for (let t = e.offset - 1; !r && 0 <= t; t--) { var n = y.get(i.childNodes[t]); n instanceof k && (r = n.domAtPos(n.length)) } return r ? new Ve(r.node, r.offset, !0) : e } nearest(e) { for (let t = e; t;) { var i = y.get(t); if (i && i.rootView == this) return i; t = t.parentNode } return null } posFromDOM(t, e) { var i = this.nearest(t); if (i) return i.localPosFromDOM(t, e) + i.posAtStart; throw new RangeError("Trying to find position for a DOM position outside of the document") } domAtPos(t) { let { i: e, off: i } = this.childCursor().findPos(t, -1); for (; e < this.children.length - 1;) { var r = this.children[e]; if (i < r.length || r instanceof k) break; e++, i = 0 } return this.children[e].domAtPos(i) } coordsAt(i, r) { let s = null, n = 0; for (let t = this.length, e = this.children.length - 1; 0 <= e; e--) { var o = this.children[e], a = t - o.breakAfter, h = a - o.length; if (a < i) break; h <= i && (h < i || o.covers(-1)) && (i < a || o.covers(1)) && (!s || o instanceof k && !(s instanceof k && 0 <= r)) && (s = o, n = h), t = h } return s ? s.coordsAt(i - n, r) : null } coordsForChar(t) { let { i: e, off: i } = this.childPos(t, 1), r = this.children[e]; if (r instanceof k) { for (; r.children.length;) { let { i: t, off: e } = r.childPos(i, 1); for (; ; t++) { if (t == r.children.length) return null; if ((r = r.children[t]).length) break } i = e } if (r instanceof Ge) { t = u(r.text, i); if (t != i) { var s = Ee(r.dom, i, t).getClientRects(); for (let t = 0; t < s.length; t++) { var n = s[t]; if (t == s.length - 1 || n.top < n.bottom && n.left < n.right) return n } } } } return null } measureVisibleLineHeights(t) { var i = [], { from: r, to: s } = t, n = this.view.contentDOM.clientWidth, o = n > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1; let a = -1, h = this.view.textDirection == O.LTR; for (let t = 0, e = 0; e < this.children.length; e++) { var l, c, d = this.children[e], u = t + d.length; if (s < u) break; t >= r && (c = d.dom.getBoundingClientRect(), i.push(c.height), o) && (l = (l = d.dom.lastChild) ? ke(l) : []).length && (l = l[l.length - 1], (c = h ? l.right - c.left : c.right - l.left) > a) && (a = c, this.minWidth = n, this.minWidthFrom = t, this.minWidthTo = u), t = u + d.breakAfter } return i } textDirectionAt(t) { t = this.childPos(t, 1).i; return "rtl" == getComputedStyle(this.children[t].dom).direction ? O.RTL : O.LTR } measureTextSize() { for (var t of this.children) if (t instanceof k) { t = t.measureTextSize(); if (t) return t } let e = document.createElement("div"), i, r, s; return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => { this.dom.appendChild(e); var t = ke(e.firstChild)[0]; i = e.getBoundingClientRect().height, r = t ? t.width / 27 : 7, s = t ? t.height : i, e.remove() }), { lineHeight: i, charWidth: r, textHeight: s } } childCursor(t = this.length) { let e = this.children.length; return e && (t -= this.children[--e].length), new ze(this.children, t, e) } computeBlockGapDeco() { var i = [], r = this.view.viewState; for (let t = 0, e = 0; ; e++) { var s, n = e == r.viewports.length ? null : r.viewports[e], o = n ? n.from - 1 : this.length; if (o > t && (s = (r.lineBlockAt(o).bottom - r.lineBlockAt(t).top) / this.view.scaleY, i.push(C.replace({ widget: new or(s), block: !0, inclusive: !0, isBlockGap: !0 }).range(t, o))), !n) break; t = n.to + 1 } return C.set(i) } updateDeco() { var e = this.view.state.facet(Xi).map((t, e) => (this.dynamicDecorationMap[e] = "function" == typeof t) ? t(this.view) : t); let r = !1, t = this.view.state.facet(Gi).map((t, e) => { var i = "function" == typeof t; return i && (r = !0), i ? t(this.view) : t }); t.length && (this.dynamicDecorationMap[e.length] = r, e.push(b.join(t))); for (let t = e.length; t < e.length + 3; t++)this.dynamicDecorationMap[t] = !1; return this.decorations = [...e, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco] } scrollIntoView(i) { if (i.isSnapshot) r = this.view.viewState.lineBlockAt(i.range.head), this.view.scrollDOM.scrollTop = r.top - i.yMargin, this.view.scrollDOM.scrollLeft = i.xMargin; else { var r = i.range; let t = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), e; if (t) { !r.empty && (e = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (t = { left: Math.min(t.left, e.left), top: Math.min(t.top, e.top), right: Math.max(t.right, e.right), bottom: Math.max(t.bottom, e.bottom) }); var h, l, s = er(this.view), s = { left: t.left - s.left, top: t.top - s.top, right: t.right + s.right, bottom: t.bottom + s.bottom }, { offsetWidth: n, offsetHeight: o } = this.view.scrollDOM, c = this.view.scrollDOM, d = s, u = r.head < r.anchor ? -1 : 1, f = i.x, p = i.y, m = Math.max(Math.min(i.xMargin, n), -n), g = Math.max(Math.min(i.yMargin, o), -o), v = this.view.textDirection == O.LTR, w = c.ownerDocument, b = w.defaultView || window; for (let o = c, a = !1; o && !a;)if (1 == o.nodeType) { let t, e = o == w.body, i = 1, r = 1; if (e) t = { left: 0, right: b.innerWidth, top: 0, bottom: b.innerHeight }; else { if (/^(fixed|sticky)$/.test(getComputedStyle(o).position) && (a = !0), o.scrollHeight <= o.clientHeight && o.scrollWidth <= o.clientWidth) { o = o.assignedSlot || o.parentNode; continue } var y = o.getBoundingClientRect(); ({ scaleX: i, scaleY: r } = Te(o, y)), t = { left: y.left, right: y.left + o.clientWidth * i, top: y.top, bottom: y.top + o.clientHeight * r } } let s = 0, n = 0; if ("nearest" == p ? d.top < t.top ? (n = -(t.top - d.top + g), 0 < u && d.bottom > t.bottom + n && (n = d.bottom - t.bottom + n + g)) : d.bottom > t.bottom && (n = d.bottom - t.bottom + g, u < 0) && d.top - n < t.top && (n = -(t.top + n - d.top + g)) : (y = d.bottom - d.top, h = t.bottom - t.top, h = "center" == p && y <= h ? d.top + y / 2 - h / 2 : "start" == p || "center" == p && u < 0 ? d.top - g : d.bottom - h + g, n = h - t.top), "nearest" == f ? d.left < t.left ? (s = -(t.left - d.left + m), 0 < u && d.right > t.right + s && (s = d.right - t.right + s + m)) : d.right > t.right && (s = d.right - t.right + m, u < 0) && d.left < t.left + s && (s = -(t.left + s - d.left + m)) : (h = "center" == f ? d.left + (d.right - d.left) / 2 - (t.right - t.left) / 2 : "start" == f == v ? d.left - m : d.right - (t.right - t.left) + m, s = h - t.left), s || n) if (e) b.scrollBy(s, n); else { let t = 0, e = 0; n && (l = o.scrollTop, o.scrollTop += n / r, e = (o.scrollTop - l) * r), s && (l = o.scrollLeft, o.scrollLeft += s / i, t = (o.scrollLeft - l) * i), d = { left: d.left - t, top: d.top - e, right: d.right - t, bottom: d.bottom - e }, t && Math.abs(t - s) < 1 && (f = "nearest"), e && Math.abs(e - n) < 1 && (p = "nearest") } if (e) break; o = o.assignedSlot || o.parentNode } else { if (11 != o.nodeType) break; o = o.host } } } } }; var or = class extends Qe { constructor(t) { super(), this.height = t } toDOM() { var t = document.createElement("div"); return t.className = "cm-gap", this.updateDOM(t), t } eq(t) { return t.height == this.height } updateDOM(t) { return t.style.height = this.height + "px", !0 } get editable() { return !0 } get estimatedHeight() { return this.height } }; function ar(t, e) { t = t.observer.selectionRange, t = t.focusNode && hr(t.focusNode, t.focusOffset, 0); return t ? { from: e = e - t.offset, to: e + t.node.nodeValue.length, node: t.node } : null } function hr(i, r, s) { if (s <= 0) for (let t = i, e = r; ;) { if (3 == t.nodeType) return { node: t, offset: e }; if (!(1 == t.nodeType && 0 < e)) break; t = t.childNodes[e - 1], e = Oe(t) } if (0 <= s) for (let t = i, e = r; ;) { if (3 == t.nodeType) return { node: t, offset: e }; if (!(1 == t.nodeType && e < t.childNodes.length && 0 <= s)) break; t = t.childNodes[e], e = 0 } return null } var lr = class { constructor() { this.changes = [] } compareRange(t, e) { di(t, e, this.changes) } comparePoint(t, e) { di(t, e, this.changes) } }; function cr(t, e) { return t.top < e.bottom - 1 && t.bottom > e.top + 1 } function dr(t, e) { return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t } function ur(t, e) { return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t } function fr(t, r, s) { let n, o, a, h, l = !1, c, d, u, f; for (let i = t.firstChild; i; i = i.nextSibling) { var p = ke(i); for (let e = 0; e < p.length; e++) { let t = p[e]; o && cr(o, t) && (t = dr(ur(t, o.bottom), o.top)); g = r; g = (v = t).left > g ? v.left - g : Math.max(0, g - v.right), v = (v = s, (m = t).top > v ? m.top - v : Math.max(0, v - m.bottom)); if (0 == g && 0 == v) return (3 == i.nodeType ? pr : fr)(i, r, s); (!n || h > v || h == v && a > g) && (n = i, o = t, a = g, m = (h = v) ? s < t.top ? -1 : 1 : g ? r < t.left ? -1 : 1 : 0, l = !m || (0 < m ? e < p.length - 1 : 0 < e)), 0 == g ? s > t.bottom && (!u || u.bottom < t.bottom) ? (c = i, u = t) : s < t.top && (!f || f.top > t.top) && (d = i, f = t) : u && cr(u, t) ? u = ur(u, t.bottom) : f && cr(f, t) && (f = dr(f, t.top)) } } var m, g, v, e; return u && u.bottom >= s ? (n = c, o = u) : f && f.top <= s && (n = d, o = f), n ? (e = Math.max(o.left, Math.min(o.right, r)), 3 == n.nodeType ? pr(n, e, s) : l && "false" != n.contentEditable ? fr(n, e, s) : { node: t, offset: Array.prototype.indexOf.call(t.childNodes, n) + (r >= (o.left + o.right) / 2 ? 1 : 0) }) : { node: t, offset: 0 } } function pr(r, s, e) { var t = r.nodeValue.length; let n = -1, o = 1e9, a = 0; for (let i = 0; i < t; i++) { var h = Ee(r, i, i + 1).getClientRects(); for (let t = 0; t < h.length; t++) { var l = h[t]; if (l.top != l.bottom) { a = a || s - l.left; var c = (e < l.top ? l.top - e : e - l.bottom) - 1; if (l.left - 1 <= s && l.right + 1 >= s && c < o) { let t = s >= (l.left + l.right) / 2, e = t; if ((x.chrome || x.gecko) && Ee(r, i).getBoundingClientRect().left == l.right && (e = !t), c <= 0) return { node: r, offset: i + (e ? 1 : 0) }; n = i + (e ? 1 : 0), o = c } } } } return { node: r, offset: -1 < n ? n : 0 < a ? r.nodeValue.length : 0 } } function mr(i, t, r, s = -1) { var e = i.contentDOM.getBoundingClientRect(), n = e.top + i.viewState.paddingTop; let o, a = i.viewState.docHeight, { x: h, y: l } = t, c = l - n; if (c < 0) return 0; if (c > a) return i.state.doc.length; for (let t = i.viewState.heightOracle.textHeight / 2, e = !1; (o = i.elementAtHeight(c)).type != A.Text;)for (; !(0 <= (c = 0 < s ? o.bottom + t : o.top - t) && c <= a);) { if (e) return r ? null : 0; e = !0, s = -s } l = n + c; n = o.from; if (n < i.viewport.from) return 0 == i.viewport.from ? 0 : r ? null : gr(i, e, o, h, l); if (n > i.viewport.to) return i.viewport.to == i.state.doc.length ? i.state.doc.length : r ? null : gr(i, e, o, h, l); var d = i.dom.ownerDocument, u = i.root.elementFromPoint ? i.root : d; let f = u.elementFromPoint(h, l); (f = f && !i.contentDOM.contains(f) ? null : f) || (h = Math.max(e.left + 1, Math.min(e.right - 1, h)), (f = u.elementFromPoint(h, l)) && !i.contentDOM.contains(f) && (f = null)); let p, m = -1; if (f && 0 != (null == (e = i.docView.nearest(f)) ? void 0 : e.isEditable) && (d.caretPositionFromPoint ? (u = d.caretPositionFromPoint(h, l)) && ({ offsetNode: p, offset: m } = u) : d.caretRangeFromPoint && (e = d.caretRangeFromPoint(h, l)) && ({ startContainer: p, startOffset: m } = e, !i.contentDOM.contains(p) || x.safari && ((e, t, i) => { let r; if (3 == e.nodeType && t == (r = e.nodeValue.length)) { for (let t = e.nextSibling; t; t = t.nextSibling)if (1 != t.nodeType || "BR" != t.nodeName) return; return Ee(e, r - 1, r).getBoundingClientRect().left > i } })(p, m, h) || x.chrome && ((e, t, i) => { if (0 == t) { for (let t = e; ;) { var r = t.parentNode; if (!r || 1 != r.nodeType || r.firstChild != t) return; if (r.classList.contains("cm-line")) break; t = r } return t = (1 == e.nodeType ? e : Ee(e, 0, Math.max(e.nodeValue.length, 1))).getBoundingClientRect(), 5 < i - t.left } })(p, m, h)) && (p = void 0)), !p || !i.docView.dom.contains(p)) { u = k.find(i.docView, n); if (!u) return c > o.top + o.height / 2 ? o.to : o.from; ({ node: p, offset: m } = fr(u.dom, h, l)) } d = i.docView.nearest(p); return d ? d.isWidget && 1 == (null == (e = d.dom) ? void 0 : e.nodeType) ? (n = d.dom.getBoundingClientRect(), t.y < n.top || t.y <= n.bottom && t.x <= (n.left + n.right) / 2 ? d.posAtStart : d.posAtEnd) : d.localPosFromDOM(p, m) + d.posAtStart : null } function gr(t, e, i, r, s) { let n = Math.round((r - e.left) * t.defaultCharacterWidth); t.lineWrapping && i.height > 1.5 * t.defaultLineHeight && (r = t.viewState.heightOracle.textHeight, e = Math.floor((s - i.top - .5 * (t.defaultLineHeight - r)) / r), n += e * t.viewState.heightOracle.lineLength); s = t.state.sliceDoc(i.from, i.to); return i.from + ae(s, n, t.state.tabSize) } function vr(t, e) { var i = t.lineBlockAt(e); if (Array.isArray(i.type)) for (var r of i.type) if (r.to > e || r.to == e && (r.to == i.to || r.type == A.Text)) return r; return i } function wr(s, t, n, o) { let a = s.state.doc.lineAt(t.head), h = s.bidiSpans(a); var l = s.textDirectionAt(a.from); for (let i = t, r = null; ;) { let t = ((t, e, i, r, s) => { let n, o = r.head - t.from, a = Mi.find(e, o, null != (n = r.bidiLevel) ? n : -1, r.assoc), h = e[a], l = h.side(s, i); if (o == l) { r = a += s ? 1 : -1; if (r < 0 || r >= e.length) return null; h = e[a = r], o = h.side(!s, i), l = h.side(s, i) } let c = u(t.text, o, h.forward(s, i)); return (c < h.from || c > h.to) && (c = l), Pi = t.text.slice(Math.min(o, c), Math.max(o, c)), (r = a == (s ? e.length - 1 : 0) ? null : e[a + (s ? 1 : -1)]) && c == l && r.level + (s ? 0 : 1) < h.level ? v.cursor(r.side(!s, i) + t.from, r.forward(s, i) ? 1 : -1, r.level) : v.cursor(c + t.from, h.forward(s, i) ? -1 : 1, h.level) })(a, h, l, i, n), e = Pi; if (!t) { if (a.number == (n ? s.state.doc.lines : 1)) return i; e = "\n", a = s.state.doc.line(a.number + (n ? 1 : -1)), h = s.bidiSpans(a), t = s.visualLineSide(a, !n) } if (r) { if (!r(e)) return i } else { if (!o) return t; r = o(e) } i = t } } function br(t, n, o) { for (; ;) { let s = 0; for (var e of t) e.between(n - 1, n + 1, (t, e, i) => { var r; t < n && n < e && (r = s || o || (n - t < e - n ? -1 : 1), n = r < 0 ? t : e, s = r) }); if (!s) return n } } function yr(e, t, i) { t = br(e.state.facet(Yi).map(t => t(e)), i.from, t.head > i.from ? -1 : 1); return t == i.from ? i : v.cursor(t, t < i.from ? 1 : -1) } var xr = class { setSelectionOrigin(t) { this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now() } constructor(t) { this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, x.safari && t.contentDOM.addEventListener("input", () => null), x.gecko && (t = t.contentDOM.ownerDocument, Qr.has(t) || (Qr.add(t), t.addEventListener("copy", () => { }), t.addEventListener("cut", () => { }))) } handleEvent(t) { !((i, r) => { if (r.bubbles) { if (r.defaultPrevented) return; for (let t = r.target, e; t != i.contentDOM; t = t.parentNode)if (!t || 11 == t.nodeType || (e = y.get(t)) && e.ignoreEvent(r)) return } return 1 })(this.view, t) || this.ignoreDuringComposition(t) || "keydown" == t.type && this.keydown(t) || this.runHandlers(t.type, t) } runHandlers(t, e) { t = this.handlers[t]; if (t) { for (var i of t.observers) i(this.view, e); for (var r of t.handlers) { if (e.defaultPrevented) break; if (r(this.view, e)) { e.preventDefault(); break } } } } ensureHandlers(t) { var e, i, r = (t => { let e = Object.create(null); function i(t) { return e[t] || (e[t] = { observers: [], handlers: [] }) } for (var r of t) { var s = r.spec; if (s && s.domEventHandlers) for (var n in s.domEventHandlers) { var o = s.domEventHandlers[n]; o && i(n).handlers.push(kr(r.value, o)) } if (s && s.domEventObservers) for (var a in s.domEventObservers) { var h = s.domEventObservers[a]; h && i(a).observers.push(kr(r.value, h)) } } for (var l in Tr) i(l).handlers.push(Tr[l]); for (var c in Dr) i(c).observers.push(Dr[c]); return e })(t), s = this.handlers, n = this.view.contentDOM; for (e in r) if ("scroll" != e) { var o = !r[e].handlers.length; let t = s[e]; t && o != !t.handlers.length && (n.removeEventListener(e, this.handleEvent), t = null), t || n.addEventListener(e, this.handleEvent, { passive: o }) } for (i in s) "scroll" == i || r[i] || n.removeEventListener(i, this.handleEvent); this.handlers = r } keydown(e) { if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), 9 == e.keyCode && Date.now() < this.lastEscPress + 2e3) return !0; if (27 != e.keyCode && Ar.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), x.android && x.chrome && !e.synthetic && (13 == e.keyCode || 8 == e.keyCode)) return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0; let t; return !x.ios || e.synthetic || e.altKey || e.metaKey || !((t = Sr.find(t => t.keyCode == e.keyCode)) && !e.ctrlKey || -1 < Cr.indexOf(e.key) && e.ctrlKey && !e.shiftKey) ? (229 != e.keyCode && this.view.observer.forceFlush(), !1) : (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) } flushIOSKey() { var t = this.pendingIOSKey; return !!t && (this.pendingIOSKey = void 0, Le(this.view.contentDOM, t.key, t.keyCode)) } ignoreDuringComposition(t) { return !!/^key/.test(t.type) && (0 < this.composing || !!(x.safari && !x.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && !(this.compositionPendingKey = !1)) } startMouseSelection(t) { this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t } update(t) { this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0) } destroy() { this.mouseSelection && this.mouseSelection.destroy() } }; function kr(i, r) { return (e, t) => { try { return r.call(i, t, e) } catch (t) { qi(e.state, t) } } } var Sr = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], Cr = "dthko", Ar = [16, 17, 18, 20, 91, 92, 224, 225]; function Or(t) { return .7 * Math.max(0, t) + 8 } var Mr = class { constructor(e, t, i, r) { this.view = e, this.startEvent = t, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = (e => { var i = e.ownerDocument; for (let t = e.parentNode; t && t != i.body;)if (1 == t.nodeType) { if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth) return t; t = t.assignedSlot || t.parentNode } else { if (11 != t.nodeType) break; t = t.host } return null })(e.contentDOM), this.atoms = e.state.facet(Yi).map(t => t(e)); i = e.contentDOM.ownerDocument; i.addEventListener("mousemove", this.move = this.move.bind(this)), i.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(w.allowMultipleSelections) && ((t, e) => (t = t.state.facet(Ri)).length ? t[0](e) : x.mac ? e.metaKey : e.ctrlKey)(e, t), this.dragging = !(!((t, e) => { var i = t.state.selection.main; if (!i.empty) { i = be(t.root); if (!i || 0 == i.rangeCount) return 1; var r = i.getRangeAt(0).getClientRects(); for (let t = 0; t < r.length; t++) { var s = r[t]; if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY) return 1 } } })(e, t) || 1 != zr(t)) && null } start(t) { !1 === this.dragging && this.select(t) } move(i) { var r; if (0 == i.buttons) return this.destroy(); if (!(this.dragging || null == this.dragging && (r = this.startEvent, s = i, Math.max(Math.abs(r.clientX - s.clientX), Math.abs(r.clientY - s.clientY)) < 10))) { this.select(this.lastEvent = i); let t = 0, e = 0; var s = (null == (r = this.scrollParent) ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, n = er(this.view); i.clientX - n.left <= s.left + 6 ? t = -Or(s.left - i.clientX) : i.clientX + n.right >= s.right - 6 && (t = Or(i.clientX - s.right)), i.clientY - n.top <= s.top + 6 ? e = -Or(s.top - i.clientY) : i.clientY + n.bottom >= s.bottom - 6 && (e = Or(i.clientY - s.bottom)), this.setScrollSpeed(t, e) } } up(t) { null == this.dragging && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy() } destroy() { this.setScrollSpeed(0, 0); var t = this.view.contentDOM.ownerDocument; t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null } setScrollSpeed(t, e) { this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : -1 < this.scrolling && (clearInterval(this.scrolling), this.scrolling = -1) } scroll() { this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), !1 === this.dragging && this.select(this.lastEvent) } skipAtoms(r) { let s = null; for (let i = 0; i < r.ranges.length; i++) { let t = r.ranges[i], e = null; var n, o; t.empty ? (n = br(this.atoms, t.from, 0)) != t.from && (e = v.cursor(n, -1)) : (n = br(this.atoms, t.from, -1), o = br(this.atoms, t.to, 1), n == t.from && o == t.to || (e = v.range(t.from == t.anchor ? n : o, t.from == t.head ? n : o))), e && ((s = s || r.ranges.slice())[i] = e) } return s ? v.create(s, r.mainIndex) : r } select(t) { var e = this.view, t = this.skipAtoms(this.style.get(t, this.extend, this.multiple)); !this.mustSelect && t.eq(e.state.selection, !1 === this.dragging) || this.view.dispatch({ selection: t, userEvent: "select.pointer" }), this.mustSelect = !1 } update(t) { this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20) } }; var Tr = Object.create(null), Dr = Object.create(null), Pr = x.ie && x.ie_version < 15 || x.ios && x.webkit_version < 604; function Rr(t, s) { let n = t.state, e, o = 1, a = n.toText(s), h = a.lines == n.selection.ranges.length; if (null != qr && n.selection.ranges.every(t => t.empty) && qr == a.toString()) { let r = -1; e = n.changeByRange(t => { var e = n.doc.lineAt(t.from); if (e.from == r) return { range: t }; r = e.from; var i = n.toText((h ? a.line(o++).text : s) + n.lineBreak); return { changes: { from: e.from, insert: i }, range: v.cursor(t.from + i.length) } }) } else e = h ? n.changeByRange(t => { var e = a.line(o++); return { changes: { from: t.from, to: t.to, insert: e.text }, range: v.cursor(t.from + e.length) } }) : n.replaceSelection(a); t.dispatch(e, { userEvent: "input.paste", scrollIntoView: !0 }) } function Br(i, r, s, n) { if (1 == n) return v.cursor(r, s); if (2 == n) { var [n, s, o = 1] = [i.state, r, s]; var a = n.charCategorizer(s), h = n.doc.lineAt(s), n = s - h.from; if (0 == h.length) return v.cursor(s); 0 == n ? o = 1 : n == h.length && (o = -1); let t = n, e = n; o < 0 ? t = u(h.text, n, !1) : e = u(h.text, n); for (var l = a(h.text.slice(t, e)); 0 < t;) { var c = u(h.text, t, !1); if (a(h.text.slice(c, t)) != l) break; t = c } for (; e < h.length;) { var d = u(h.text, e); if (a(h.text.slice(e, d)) != l) break; e = d } return v.range(t + h.from, e + h.from) } { s = k.find(i.docView, r), o = i.state.doc.lineAt(s ? s.posAtEnd : r); let t = s ? s.posAtStart : o.from, e = s ? s.posAtEnd : o.to; return e < i.state.doc.length && e == o.to && e++, v.range(t, e) } } Dr.scroll = t => { t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft }, Tr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), 27 == e.keyCode && (t.inputState.lastEscPress = Date.now()), !1), Dr.touchstart = (t, e) => { t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer") }, Dr.touchmove = t => { t.inputState.setSelectionOrigin("select.pointer") }, Tr.mousedown = (e, i) => { if (e.observer.flush(), !(e.inputState.lastTouchTime > Date.now() - 2e3)) { let t = null; for (var r of e.state.facet(Ei)) if (t = r(e, i)) break; if (t = t || 0 != i.button ? t : ((a, t) => { let h = Nr(a, t), l = zr(t), c = a.state.selection; return { update(t) { t.docChanged && (h.pos = t.changes.mapPos(h.pos), c = c.map(t.changes)) }, get(t, e, i) { let r = Nr(a, t), s, n = Br(a, r.pos, r.bias, l); var o; return h.pos == r.pos || e || (t = Br(a, h.pos, h.bias, l), o = Math.min(t.from, n.from), t = Math.max(t.to, n.to), n = o < n.from ? v.range(o, t) : v.range(t, o)), e ? c.replaceRange(c.main.extend(n.from, n.to)) : i && 1 == l && 1 < c.ranges.length && (s = ((e, i) => { for (let t = 0; t < e.ranges.length; t++) { var { from: r, to: s } = e.ranges[t]; if (r <= i && i <= s) return v.create(e.ranges.slice(0, t).concat(e.ranges.slice(t + 1)), e.mainIndex == t ? 0 : e.mainIndex - (e.mainIndex > t ? 1 : 0)) } return null })(c, r.pos)) ? s : i ? c.addRange(n) : v.create([n]) } } })(e, i)) { var s = !e.hasFocus, s = (e.inputState.startMouseSelection(new Mr(e, i, t, s)), s && e.observer.ignore(() => Be(e.contentDOM)), e.inputState.mouseSelection); if (s) return s.start(i), !1 === s.dragging } } return !1 }; var Er = (t, e) => t >= e.top && t <= e.bottom, Lr = (t, e, i) => Er(e, i) && t >= i.left && t <= i.right; function Nr(t, e) { var i, r, s = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1); return { pos: s, bias: (t = t, s = s, i = e.clientX, e = e.clientY, (t = k.find(t.docView, s)) && 0 != (s = s - t.posAtStart) && (s == t.length || (r = t.coordsAt(s, -1)) && Lr(i, e, r) || (!(t = t.coordsAt(s, 1)) || !Lr(i, e, t)) && r && Er(e, r)) ? -1 : 1) } } var Ir = x.ie && x.ie_version <= 11, Vr = null, Hr = 0, Wr = 0; function zr(t) { var e, i; return Ir ? (e = Vr, i = Wr, Vr = t, Wr = Date.now(), Hr = !e || i > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (Hr + 1) % 3 : 1) : t.detail } function Fr(t, e, i, r) { var s, n; i && (s = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = t.inputState.draggedContent, e = r && n && (r = e, (e = (e = t).state.facet(Bi)).length ? e[0](r) : x.mac ? !r.altKey : !r.ctrlKey) ? { from: n.from, to: n.to } : null, r = { from: s, insert: i }, n = t.state.changes(e ? [e, r] : r), t.focus(), t.dispatch({ changes: n, selection: { anchor: n.mapPos(s, -1), head: n.mapPos(s, 1) }, userEvent: e ? "move.drop" : "input.drop" }), t.inputState.draggedContent = null) } Tr.dragstart = (t, e) => { let i = t.state.selection.main; var r, s = (e.target.draggable && (r = t.docView.nearest(e.target)) && r.isWidget && (r = (s = r.posAtStart) + r.length, s >= i.to || r <= i.from) && (i = v.range(s, r)), t).inputState; return s.mouseSelection && (s.mouseSelection.dragging = !0), s.draggedContent = i, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(i.from, i.to)), e.dataTransfer.effectAllowed = "copyMove"), !1 }, Tr.dragend = t => (t.inputState.draggedContent = null, !1), Tr.drop = (e, s) => { if (!s.dataTransfer) return !1; if (e.state.readOnly) return !0; let n = s.dataTransfer.files; if (n && n.length) { let i = Array(n.length), t = 0, r = () => { ++t == n.length && Fr(e, s, i.filter(t => null != t).join(e.state.lineBreak), !1) }; for (let e = 0; e < n.length; e++) { let t = new FileReader; t.onerror = r, t.onload = () => { /[\x00-\x08\x0e-\x1f]{2}/.test(t.result) || (i[e] = t.result), r() }, t.readAsText(n[e]) } return !0 } var t = s.dataTransfer.getData("Text"); return !!t && (Fr(e, s, t, !0), !0) }, Tr.paste = (t, e) => { if (t.state.readOnly) return !0; t.observer.flush(); e = Pr ? null : e.clipboardData; if (e) return Rr(t, e.getData("text/plain") || e.getData("text/uri-text")), !0; var i = t, e = i.dom.parentNode; if (e) { let t = e.appendChild(document.createElement("textarea")); t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => { i.focus(), t.remove(), Rr(i, t.value) }, 50) } return !1 }; var qr = null, _r = (Tr.copy = Tr.cut = (t, e) => { var { text: i, ranges: r, linewise: s } = (e => { let i = [], r = [], s = !1; for (var t of e.selection.ranges) t.empty || (i.push(e.sliceDoc(t.from, t.to)), r.push(t)); if (!i.length) { let t = -1; for (var { from: n } of e.selection.ranges) { n = e.doc.lineAt(n); n.number > t && (i.push(n.text), r.push({ from: n.from, to: Math.min(e.doc.length, n.to + 1) })), t = n.number } s = !0 } return { text: i.join(e.lineBreak), ranges: r, linewise: s } })(t.state); if (i || s) { qr = s ? i : null, "cut" != e.type || t.state.readOnly || t.dispatch({ changes: r, scrollIntoView: !0, userEvent: "delete.cut" }); s = Pr ? null : e.clipboardData; if (s) return s.clearData(), s.setData("text/plain", i), !0; var n = t, r = i, e = n.dom.parentNode; if (e) { let t = e.appendChild(document.createElement("textarea")); t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.value = r, t.focus(), t.selectionEnd = r.length, t.selectionStart = 0, setTimeout(() => { t.remove(), n.focus() }, 50) } } return !1 }, Bt.define()); function jr(t, e) { var i, r = []; for (i of t.facet(Vi)) { var s = i(t, e); s && r.push(s) } return r ? t.update({ effects: r, annotations: _r.of(!0) }) : null } function Ur(e) { setTimeout(() => { var t = e.hasFocus; t != e.inputState.notifiedFocused && ((t = jr(e.state, t)) ? e.dispatch(t) : e.update([])) }, 10) } Dr.focus = t => { t.inputState.lastFocusTime = Date.now(), t.scrollDOM.scrollTop || !t.inputState.lastScrollTop && !t.inputState.lastScrollLeft || (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Ur(t) }, Dr.blur = t => { t.observer.clearSelectionRange(), Ur(t) }, Dr.compositionstart = Dr.compositionupdate = t => { null == t.inputState.compositionFirstChange && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0) }, Dr.compositionend = t => { t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = 0 < t.observer.pendingRecords().length, t.inputState.compositionFirstChange = null, x.chrome && x.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => { t.inputState.composing < 0 && t.docView.hasComposition && t.update([]) }, 50) }, Dr.contextmenu = t => { t.inputState.lastContextMenu = Date.now() }, Tr.beforeinput = (i, e) => { let t, r; if (x.chrome && x.android && (r = Sr.find(t => t.inputType == e.inputType)) && (i.observer.delayAndroidKey(r.key, r.keyCode), "Backspace" == r.key || "Delete" == r.key)) { let e = (null == (t = window.visualViewport) ? void 0 : t.height) || 0; setTimeout(() => { var t; ((null == (t = window.visualViewport) ? void 0 : t.height) || 0) > e + 10 && i.hasFocus && (i.contentDOM.blur(), i.focus()) }, 100) } return !1 }; var Qr = new Set; var $r = ["pre-wrap", "normal", "pre-line", "break-spaces"], Kr = class { constructor(t) { this.lineWrapping = t, this.doc = g.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1 } heightForGap(t, e) { let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1; return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * .5) / this.lineLength))), this.lineHeight * i } heightForLine(t) { return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight } setDoc(t) { return this.doc = t, this } mustRefreshForWrapping(t) { return -1 < $r.indexOf(t) != this.lineWrapping } mustRefreshForHeights(e) { let i = !1; for (let t = 0; t < e.length; t++) { var r = e[t]; r < 0 ? t++ : this.heightSamples[Math.floor(10 * r)] || (i = !0, this.heightSamples[Math.floor(10 * r)] = !0) } return i } refresh(t, e, i, r, s, n) { var t = -1 < $r.indexOf(t), o = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != t; if (this.lineWrapping = t, this.lineHeight = e, this.charWidth = i, this.textHeight = r, this.lineLength = s, o) { this.heightSamples = {}; for (let t = 0; t < n.length; t++) { var a = n[t]; a < 0 ? t++ : this.heightSamples[Math.floor(10 * a)] = !0 } } return o } }, Xr = class { constructor(t, e) { this.from = t, this.heights = e, this.index = 0 } get more() { return this.index < this.heights.length } }, Gr = class Sf { constructor(t, e, i, r, s) { this.from = t, this.length = e, this.top = i, this.height = r, this._content = s } get type() { return "number" == typeof this._content ? A.Text : Array.isArray(this._content) ? this._content : this._content.type } get to() { return this.from + this.length } get bottom() { return this.top + this.height } get widget() { return this._content instanceof li ? this._content.widget : null } get widgetLineBreaks() { return "number" == typeof this._content ? this._content : 0 } join(t) { var e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]); return new Sf(this.from, this.length + t.length, this.top, this.height + t.height, e) } }, M = (t => (t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t))(M = M || {}), Yr = class Cf { constructor(t, e, i = 2) { this.length = t, this.height = e, this.flags = i } get outdated() { return 0 < (2 & this.flags) } set outdated(t) { this.flags = (t ? 2 : 0) | -3 & this.flags } setHeight(t, e) { this.height != e && (.001 < Math.abs(this.height - e) && (t.heightChanged = !0), this.height = e) } replace(t, e, i) { return Cf.of(i) } decomposeLeft(t, e) { e.push(this) } decomposeRight(t, e) { e.push(this) } applyChanges(o, a, h, l) { let c = this, d = h.doc; for (let n = l.length - 1; 0 <= n; n--) { let { fromA: t, toA: e, fromB: i, toB: r } = l[n], s = c.lineAt(t, M.ByPosNoHeight, h.setDoc(a), 0, 0); var u = s.to >= e ? s : c.lineAt(e, M.ByPosNoHeight, h, 0, 0); for (r += u.to - e, e = u.to; 0 < n && s.from <= l[n - 1].toA;)t = l[n - 1].fromA, i = l[n - 1].fromB, n--, t < s.from && (s = c.lineAt(t, M.ByPosNoHeight, h, 0, 0)); i += s.from - t, t = s.from; u = rs.build(h.setDoc(d), o, i, r); c = c.replace(t, e, u) } return c.updateHeight(h, 0) } static empty() { return new Zr(0, 0) } static of(t) { if (1 == t.length) return t[0]; let e = 0, i = t.length, r = 0, s = 0; for (; ;) { var n; if (e == i) if (r > 2 * s) { var o = t[e - 1]; o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, r -= o.size } else { if (!(s > 2 * r)) break; o = t[i]; o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, s -= o.size } else r < s ? (n = t[e++]) && (r += n.size) : (n = t[--i]) && (s += n.size) } let a = 0; return null == t[e - 1] ? (a = 1, e--) : null == t[e] && (a = 1, i++), new es(Cf.of(t.slice(0, e)), a, Cf.of(t.slice(i))) } }, Jr = (Yr.prototype.size = 1, class extends Yr { constructor(t, e, i) { super(t, e), this.deco = i } blockAt(t, e, i, r) { return new Gr(r, this.length, i, this.height, this.deco || 0) } lineAt(t, e, i, r, s) { return this.blockAt(0, i, r, s) } forEachLine(t, e, i, r, s, n) { t <= s + this.length && s <= e && n(this.blockAt(0, i, r, s)) } updateHeight(t, e = 0, i, r) { return r && r.from <= e && r.more && this.setHeight(t, r.heights[r.index++]), this.outdated = !1, this } toString() { return `block(${this.length})` } }), Zr = class Af extends Jr { constructor(t, e) { super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0 } blockAt(t, e, i, r) { return new Gr(r, this.length, i, this.height, this.breaks) } replace(t, e, i) { let r = i[0]; return 1 == i.length && (r instanceof Af || r instanceof ts && 4 & r.flags) && Math.abs(this.length - r.length) < 10 ? (r instanceof ts ? r = new Af(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : Yr.of(i) } updateHeight(t, e = 0, i = !1, r) { return r && r.from <= e && r.more ? this.setHeight(t, r.heights[r.index++]) : (i || this.outdated) && this.setHeight(t, Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this } toString() { return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})` } }, ts = class Of extends Yr { constructor(t) { super(t, 0) } heightMetrics(t, e) { var i = t.doc.lineAt(e).number, e = t.doc.lineAt(e + this.length).number, r = e - i + 1; let s, n = 0; return t.lineWrapping ? (t = Math.min(this.height, t.lineHeight * r), s = t / r, this.length > 1 + r && (n = (this.height - t) / (this.length - r - 1))) : s = this.height / r, { firstLine: i, lastLine: e, perLine: s, perChar: n } } blockAt(t, e, i, r) { var s, { firstLine: n, lastLine: o, perLine: a, perChar: h } = this.heightMetrics(e, r); return e.lineWrapping ? (r = r + Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length), h = a + (r = e.doc.lineAt(r)).length * h, s = Math.max(i, t - h / 2), new Gr(r.from, r.length, s, h, 0)) : (r = Math.max(0, Math.min(o - n, Math.floor((t - i) / a))), { from: s, length: h } = e.doc.line(n + r), new Gr(s, h, i + a * r, a, 0)) } lineAt(t, e, i, r, s) { var n, o; return e == M.ByHeight ? this.blockAt(t, i, r, s) : e == M.ByPosNoHeight ? ({ from: e, to: o } = i.doc.lineAt(t), new Gr(e, o - e, 0, 0, 0)) : ({ firstLine: o, perLine: e, perChar: n } = this.heightMetrics(i, s), t = e + (i = i.doc.lineAt(t)).length * n, o = i.number - o, new Gr(i.from, i.length, Math.max(r, Math.min(r + e * o + n * (i.from - s - o), r + this.height - t)), t, 0)) } forEachLine(i, r, s, n, o, a) { i = Math.max(i, o), r = Math.min(r, o + this.length); var { firstLine: h, perLine: l, perChar: c } = this.heightMetrics(s, o); for (let t = i, e = n; t <= r;) { var d = s.doc.lineAt(t), u = (t == i && (u = d.number - h, e += l * u + c * (i - o - u)), l + c * d.length); a(new Gr(d.from, d.length, e, u, 0)), e += u, t = d.to + 1 } } replace(t, e, i) { var r, e = this.length - e; return 0 < e && ((r = i[i.length - 1]) instanceof Of ? i[i.length - 1] = new Of(r.length + e) : i.push(null, new Of(e - 1))), 0 < t && ((r = i[0]) instanceof Of ? i[0] = new Of(t + r.length) : i.unshift(new Of(t - 1), null)), Yr.of(i) } decomposeLeft(t, e) { e.push(new Of(t - 1), null) } decomposeRight(t, e) { e.push(null, new Of(this.length - t - 1)) } updateHeight(r, s = 0, t = !1, n) { var o = s + this.length; if (n && n.from <= s + this.length && n.more) { let t = [], e = Math.max(s, n.from), i = -1; for (n.from > s && t.push(new Of(n.from - s - 1).updateHeight(r, s)); e <= o && n.more;) { var a = r.doc.lineAt(e).length, h = (t.length && t.push(null), n.heights[n.index++]), h = (-1 == i ? i = h : .001 <= Math.abs(h - i) && (i = -2), new Zr(a, h)); h.outdated = !1, t.push(h), e += a + 1 } e <= o && t.push(null, new Of(o - e).updateHeight(r, e)); var l = Yr.of(t); return (i < 0 || .001 <= Math.abs(l.height - this.height) || .001 <= Math.abs(i - this.heightMetrics(r, s).perLine)) && (r.heightChanged = !0), l } return (t || this.outdated) && (this.setHeight(r, r.heightForGap(s, s + this.length)), this.outdated = !1), this } toString() { return `gap(${this.length})` } }, es = class extends Yr { constructor(t, e, i) { super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size } get break() { return 1 & this.flags } blockAt(t, e, i, r) { var s = i + this.left.height; return t < s ? this.left.blockAt(t, e, i, r) : this.right.blockAt(t, e, s, r + this.left.length + this.break) } lineAt(t, e, i, r, s) { var n = r + this.left.height, o = s + this.left.length + this.break, a = e == M.ByHeight ? t < n : t < o, t = a ? this.left.lineAt(t, e, i, r, s) : this.right.lineAt(t, e, i, n, o); return this.break || (a ? t.to < o : t.from > o) ? t : (e = e == M.ByPosNoHeight ? M.ByPosNoHeight : M.ByPos, a ? t.join(this.right.lineAt(o, e, i, n, o)) : this.left.lineAt(o, e, i, r, s).join(t)) } forEachLine(t, e, i, r, s, n) { var o, a = r + this.left.height, h = s + this.left.length + this.break; this.break ? (t < h && this.left.forEachLine(t, e, i, r, s, n), h <= e && this.right.forEachLine(t, e, i, a, h, n)) : (t < (o = this.lineAt(h, M.ByPos, i, r, s)).from && this.left.forEachLine(t, o.from - 1, i, r, s, n), t <= o.to && o.from <= e && n(o), o.to < e && this.right.forEachLine(o.to + 1, e, i, a, h, n)) } replace(t, e, i) { var r = this.left.length + this.break; if (e < r) return this.balanced(this.left.replace(t, e, i), this.right); if (t > this.left.length) return this.balanced(this.left, this.right.replace(t - r, e - r, i)); var s, n = [], r = (0 < t && this.decomposeLeft(t, n), n.length); for (s of i) n.push(s); return 0 < t && is(n, r - 1), e < this.length && (i = n.length, this.decomposeRight(e, n), is(n, i)), Yr.of(n) } decomposeLeft(t, e) { let i = this.left.length; if (t <= i) return this.left.decomposeLeft(t, e); e.push(this.left), this.break && t >= ++i && e.push(null), t > i && this.right.decomposeLeft(t - i, e) } decomposeRight(t, e) { var i = this.left.length, r = i + this.break; if (r <= t) return this.right.decomposeRight(t - r, e); t < i && this.left.decomposeRight(t, e), this.break && t < r && e.push(null), e.push(this.right) } balanced(t, e) { return t.size > 2 * e.size || e.size > 2 * t.size ? Yr.of(this.break ? [t, null, e] : [t, e]) : (this.left = t, this.right = e, this.height = t.height + e.height, this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this) } updateHeight(t, e = 0, i = !1, r) { let { left: s, right: n } = this, o = e + s.length + this.break, a = null; return r && r.from <= e + s.length && r.more ? a = s = s.updateHeight(t, e, i, r) : s.updateHeight(t, e, i), r && r.from <= o + n.length && r.more ? a = n = n.updateHeight(t, o, i, r) : n.updateHeight(t, o, i), a ? this.balanced(s, n) : (this.height = this.left.height + this.right.height, this.outdated = !1, this) } toString() { return this.left + (this.break ? " " : "-") + this.right } }; function is(t, e) { let i, r; null == t[e] && (i = t[e - 1]) instanceof ts && (r = t[e + 1]) instanceof ts && t.splice(e - 1, 3, new ts(i.length + 1 + r.length)) } var rs = class Mf { constructor(t, e) { this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t } get isCovered() { return this.covering && this.nodes[this.nodes.length - 1] == this.covering } span(t, e) { var i, r; -1 < this.lineStart && (i = Math.min(e, this.lineEnd), (r = this.nodes[this.nodes.length - 1]) instanceof Zr ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Zr(i - this.pos, -1)), (this.writtenTo = i) < e) && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1), this.pos = e } point(e, i, r) { if (e < i || r.heightRelevant) { let t = r.widget ? r.widget.estimatedHeight : 0; var s = r.widget ? r.widget.lineBreaks : 0, n = (t < 0 && (t = this.oracle.lineHeight), i - e); r.block ? this.addBlock(new Jr(n, t, r)) : (n || s || 5 <= t) && this.addLineDeco(t, s, n) } else e < i && this.span(e, i); -1 < this.lineEnd && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to) } enterLine() { var t, e; -1 < this.lineStart || ({ from: t, to: e } = this.oracle.doc.lineAt(this.pos), this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new Zr(this.pos - t, -1)), this.writtenTo = this.pos) } blankContent(t, e) { var i = new ts(e - t); return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i } ensureLine() { this.enterLine(); var t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null; return t instanceof Zr || (t = new Zr(0, -1), this.nodes.push(t)), t } addBlock(t) { this.enterLine(); var e = t.deco; e && 0 < e.startSide && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && 0 < e.endSide && (this.covering = t) } addLineDeco(t, e, i) { var r = this.ensureLine(); r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, t), r.breaks += e, this.writtenTo = this.pos = this.pos + i } finish(t) { var e, i = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1]; !(-1 < this.lineStart) || i instanceof Zr || this.isCovered ? (this.writtenTo < this.pos || null == i) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new Zr(0, -1)); let r = t; for (e of this.nodes) e instanceof Zr && e.updateHeight(this.oracle, r), r += e ? e.length : 1; return this.nodes } static build(t, e, i, r) { t = new Mf(i, t); return b.spans(e, i, r, t, 0), t.finish(i) } }; var ss = class { constructor() { this.changes = [] } compareRange() { } comparePoint(t, e, i, r) { (t < e || i && i.heightRelevant || r && r.heightRelevant) && di(t, e, this.changes, 5) } }; var ns = class { constructor(t, e, i) { this.from = t, this.to = e, this.size = i } static same(e, i) { if (e.length != i.length) return !1; for (let t = 0; t < e.length; t++) { var r = e[t], s = i[t]; if (r.from != s.from || r.to != s.to || r.size != s.size) return !1 } return !0 } draw(t, e) { return C.replace({ widget: new os(this.size * (e ? t.scaleY : t.scaleX), e) }).range(this.from, this.to) } }, os = class extends Qe { constructor(t, e) { super(), this.size = t, this.vertical = e } eq(t) { return t.size == this.size && t.vertical == this.vertical } toDOM() { var t = document.createElement("div"); return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t } get estimatedHeight() { return this.vertical ? this.size : -1 } }, as = class { constructor(t) { this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = ds, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = O.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1; var e = t.facet(Ki).some(t => "function" != typeof t && "cm-lineWrapping" == t.class); this.heightOracle = new Kr(e), this.stateDeco = t.facet(Xi).filter(t => "function" != typeof t), this.heightMap = Yr.empty().applyChanges(this.stateDeco, g.empty, this.heightOracle.setDoc(t.doc), [new rr(0, 0, 0, t.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = C.set(this.lineGaps.map(t => t.draw(this, !1))), this.computeVisibleRanges() } updateForViewport() { var e, r, s = [this.viewport], n = this.state.selection.main; for (let t = 0; t <= 1; t++) { let i = t ? n.head : n.anchor; s.some(({ from: t, to: e }) => i >= t && i <= e) || ({ from: e, to: r } = this.lineBlockAt(i), s.push(new hs(e, r))) } this.viewports = s.sort((t, e) => t.from - e.from), this.scaler = this.heightMap.height <= 7e6 ? ds : new us(this.heightOracle, this.heightMap, this.viewports) } updateViewportLines() { this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, t => { this.viewportLines.push(1 == this.scaler.scale ? t : fs(t, this.scaler)) }) } update(t, e = null) { this.state = t.state; var i = this.stateDeco, r = (this.stateDeco = this.state.facet(Xi).filter(t => "function" != typeof t), t.changedRanges), r = rr.extendWithRanges(r, (r = i, i = this.stateDeco, s = t ? t.changes : it.empty(this.state.doc.length), o = new ss, b.compare(r, i, s, o, 0), o.changes)), i = this.heightMap.height, s = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop); this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), r), this.heightMap.height != i && (t.flags |= 2), s ? (this.scrollAnchorPos = t.changes.mapPos(s.from, -1), this.scrollAnchorHeight = s.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height); let n = r.length ? this.mapViewport(this.viewport, t.changes) : this.viewport; (e && (e.range.head < n.from || e.range.head > n.to) || !this.viewportIsAppropriate(n)) && (n = this.getViewport(0, e)); var o = !t.changes.empty || 2 & t.flags || n.from != this.viewport.from || n.to != this.viewport.to; this.viewport = n, this.updateForViewport(), o && this.updateViewportLines(), (this.lineGaps.length || 4e3 < this.viewport.to - this.viewport.from) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(Wi) && (this.mustEnforceCursorAssoc = !0) } measure(t) { var e = t.contentDOM, i = window.getComputedStyle(e), r = this.heightOracle, s = i.whiteSpace; this.defaultTextDirection = "rtl" == i.direction ? O.RTL : O.LTR; let n = this.heightOracle.mustRefreshForWrapping(s); var o = e.getBoundingClientRect(); let a = n || this.mustMeasureContent || this.contentDOMHeight != o.height, h = (this.contentDOMHeight = o.height, this.mustMeasureContent = !1, 0), l = 0; o.width && o.height && ({ scaleX: c, scaleY: d } = Te(e, o), this.scaleX == c && this.scaleY == d || (this.scaleX = c, this.scaleY = d, h |= 8, n = a = !0)); var c = (parseInt(i.paddingTop) || 0) * this.scaleY, d = (parseInt(i.paddingBottom) || 0) * this.scaleY, i = (this.paddingTop == c && this.paddingBottom == d || (this.paddingTop = c, this.paddingBottom = d, h |= 10), this.editorWidth != t.scrollDOM.clientWidth && (r.lineWrapping && (a = !0), this.editorWidth = t.scrollDOM.clientWidth, h |= 8), t.scrollDOM.scrollTop * this.scaleY), c = (this.scrollTop != i && (this.scrollAnchorHeight = -1, this.scrollTop = i), this.scrolledToBottom = Ie(t.scrollDOM), (this.printing ? function(t, e) { return { left: 0, right: (t = t.getBoundingClientRect()).right - t.left, top: e, bottom: t.bottom - (t.top + e) } } : function(e, t) { var i = e.getBoundingClientRect(), r = e.ownerDocument, s = r.defaultView || window; let n = Math.max(0, i.left), o = Math.min(s.innerWidth, i.right), a = Math.max(0, i.top), h = Math.min(s.innerHeight, i.bottom); for (let t = e.parentNode; t && t != r.body;)if (1 == t.nodeType) { var l, c = t, d = window.getComputedStyle(c); (c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && "visible" != d.overflow && (l = c.getBoundingClientRect(), n = Math.max(n, l.left), o = Math.min(o, l.right), a = Math.max(a, l.top), h = t == e.parentNode ? l.bottom : Math.min(h, l.bottom)), t = "absolute" == d.position || "fixed" == d.position ? c.offsetParent : c.parentNode } else { if (11 != t.nodeType) break; t = t.host } return { left: n - i.left, right: Math.max(n, o) - i.left, top: a - (i.top + t), bottom: Math.max(a, h) - (i.top + t) } })(e, this.paddingTop)), d = c.top - this.pixelViewport.top, i = c.bottom - this.pixelViewport.bottom, e = (this.pixelViewport = c, this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left); if (e != this.inView && (this.inView = e) && (a = !0), !this.inView && !this.scrollTarget) return 0; c = o.width; if (this.contentDOMWidth == c && this.editorHeight == t.scrollDOM.clientHeight || (this.contentDOMWidth = o.width, this.editorHeight = t.scrollDOM.clientHeight, h |= 8), a) { var u, f, p = t.docView.measureVisibleLineHeights(this.viewport); ((n = r.mustRefreshForHeights(p) ? !0 : n) || r.lineWrapping && Math.abs(c - this.contentDOMWidth) > r.charWidth) && ({ lineHeight: e, charWidth: o, textHeight: u } = t.docView.measureTextSize(), n = 0 < e && r.refresh(s, e, o, u, c / o, p)) && (t.docView.minWidth = 0, h |= 8), 0 < d && 0 < i ? l = Math.max(d, i) : d < 0 && i < 0 && (l = Math.min(d, i)), r.heightChanged = !1; for (f of this.viewports) { var m = f.from == this.viewport.from ? p : t.docView.measureVisibleLineHeights(f); this.heightMap = (n ? Yr.empty().applyChanges(this.stateDeco, g.empty, this.heightOracle, [new rr(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(r, 0, n, new Xr(f.from, m)) } r.heightChanged && (h |= 2) } s = !this.viewportIsAppropriate(this.viewport, l) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to); return s && (this.viewport = this.getViewport(l, this.scrollTarget)), this.updateForViewport(), (2 & h || s) && this.updateViewportLines(), (this.lineGaps.length || 4e3 < this.viewport.to - this.viewport.from) && this.updateLineGaps(this.ensureLineGaps(n ? [] : this.lineGaps, t)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), h } get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top) } get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom) } getViewport(t, i) { var t = .5 - Math.max(-.5, Math.min(.5, t / 1e3 / 2)), r = this.heightMap, s = this.heightOracle, { visibleTop: n, visibleBottom: o } = this; let a = new hs(r.lineAt(n - 1e3 * t, M.ByHeight, s, 0, 0).from, r.lineAt(o + 1e3 * (1 - t), M.ByHeight, s, 0, 0).to); if (i) { n = i.range.head; if (n < a.from || n > a.to) { o = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top); let t = r.lineAt(n, M.ByPos, s, 0, 0), e; e = "center" == i.y ? (t.top + t.bottom) / 2 - o / 2 : "start" == i.y || "nearest" == i.y && n < a.from ? t.top : t.bottom - o, a = new hs(r.lineAt(e - 500, M.ByHeight, s, 0, 0).from, r.lineAt(e + o + 500, M.ByHeight, s, 0, 0).to) } } return a } mapViewport(t, e) { var i = e.mapPos(t.from, -1), e = e.mapPos(t.to, 1); return new hs(this.heightMap.lineAt(i, M.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(e, M.ByPos, this.heightOracle, 0, 0).to) } viewportIsAppropriate({ from: t, to: e }, i = 0) { var r, s, n, o; return !this.inView || (r = this.heightMap.lineAt(t, M.ByPos, this.heightOracle, 0, 0).top, s = this.heightMap.lineAt(e, M.ByPos, this.heightOracle, 0, 0).bottom, { visibleTop: n, visibleBottom: o } = this, (0 == t || r <= n - Math.max(10, Math.min(-i, 250))) && (e == this.state.doc.length || s >= o + Math.max(10, Math.min(i, 250))) && n - 2e3 < r && s < o + 2e3) } mapLineGaps(t, e) { if (!t.length || e.empty) return t; var i, r = []; for (i of t) e.touchesRange(i.from, i.to) || r.push(new ns(e.mapPos(i.from), e.mapPos(i.to), i.size)); return r } ensureLineGaps(l, c) { let d = this.heightOracle.lineWrapping, s = d ? 1e4 : 2e3, u = s >> 1, t = s << 1; if (this.defaultTextDirection != O.LTR && !d) return []; let f = [], p = (r, s, n, o) => { if (!(s - r < u)) { let t = this.state.selection.main, i = [t.from]; t.empty || i.push(t.to); for (var a of i) if (a > r && a < s) return p(r, a - 10, n, o), void p(a + 10, s, n, o); let e = ((t, e) => { for (var i of t) if (e(i)) return i })(l, e => e.from >= n.from && e.to <= n.to && Math.abs(e.from - r) < u && Math.abs(e.to - s) < u && !i.some(t => e.from < t && e.to > t)); var h; e || (s < n.to && c && d && c.visibleRanges.some(t => t.from <= s && t.to >= s) && (h = c.moveToLineBoundary(v.cursor(s), !1, !0).head, r < h) && (s = h), e = new ns(r, s, this.gapSize(n, r, s, o))), f.push(e) } }; for (var n of this.viewportLines) if (!(n.length < t)) { var o = ((t, e, i) => { let r = [], s = t, n = 0; return b.spans(i, t, e, { span() { }, point(t, e) { t > s && (r.push({ from: s, to: t }), n += t - s), s = e } }, 20), s < e && (r.push({ from: s, to: e }), n += e - s), { total: n, ranges: r } })(n.from, n.to, this.stateDeco); if (!(o.total < t)) { var a = this.scrollTarget ? this.scrollTarget.range.head : null; let i, r; if (d) { var h = s / this.heightOracle.lineLength * this.heightOracle.lineHeight; let t, e; e = null != a ? (m = cs(o, a), g = ((this.visibleBottom - this.visibleTop) / 2 + h) / n.height, t = m - g, m + g) : (t = (this.visibleTop - n.top - h) / n.height, (this.visibleBottom - n.top + h) / n.height), i = ls(o, t), r = ls(o, e) } else { var m = o.total * this.heightOracle.charWidth, g = s * this.heightOracle.charWidth; let t, e; e = null != a ? (h = cs(o, a), a = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / m, t = h - a, h + a) : (t = (this.pixelViewport.left - g) / m, (this.pixelViewport.right + g) / m), i = ls(o, t), r = ls(o, e) } i > n.from && p(n.from, i, n, o), r < n.to && p(r, n.to, n, o) } } return f } gapSize(t, e, i, r) { i = cs(r, i) - cs(r, e); return this.heightOracle.lineWrapping ? t.height * i : r.total * this.heightOracle.charWidth * i } updateLineGaps(t) { ns.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = C.set(t.map(t => t.draw(this, this.heightOracle.lineWrapping)))) } computeVisibleRanges() { let t = this.stateDeco, i = (this.lineGaps.length && (t = t.concat(this.lineGapDeco)), []); b.spans(t, this.viewport.from, this.viewport.to, { span(t, e) { i.push({ from: t, to: e }) }, point() { } }, 20); var e = i.length != this.visibleRanges.length || this.visibleRanges.some((t, e) => t.from != i[e].from || t.to != i[e].to); return this.visibleRanges = i, e ? 4 : 0 } lineBlockAt(e) { return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find(t => t.from <= e && t.to >= e) || fs(this.heightMap.lineAt(e, M.ByPos, this.heightOracle, 0, 0), this.scaler) } lineBlockAtHeight(t) { return fs(this.heightMap.lineAt(this.scaler.fromDOM(t), M.ByHeight, this.heightOracle, 0, 0), this.scaler) } scrollAnchorAt(t) { var e = this.lineBlockAtHeight(t + 8); return e.from >= this.viewport.from || 200 < this.viewportLines[0].top - t ? e : this.viewportLines[0] } elementAtHeight(t) { return fs(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler) } get docHeight() { return this.scaler.toDOM(this.heightMap.height) } get contentHeight() { return this.docHeight + this.paddingTop + this.paddingBottom } }, hs = class { constructor(t, e) { this.from = t, this.to = e } }; function ls({ total: t, ranges: e }, i) { if (i <= 0) return e[0].from; if (1 <= i) return e[e.length - 1].to; let r = Math.floor(t * i); for (let t = 0; ; t++) { var { from: s, to: n } = e[t], n = n - s; if (r <= n) return s + r; r -= n } } function cs(t, e) { let i = 0; for (var { from: r, to: s } of t.ranges) { if (e <= s) { i += e - r; break } i += s - r } return i / t.total } var ds = { toDOM(t) { return t }, fromDOM(t) { return t }, scale: 1 }, us = class { constructor(s, n, t) { let o = 0, e = 0, i = 0; this.viewports = t.map(({ from: t, to: e }) => { var i = n.lineAt(t, M.ByPos, s, 0, 0).top, r = n.lineAt(e, M.ByPos, s, 0, 0).bottom; return o += r - i, { from: t, to: e, top: i, bottom: r, domTop: 0, domBottom: 0 } }), this.scale = (7e6 - o) / (n.height - o); for (var r of this.viewports) r.domTop = i + (r.top - e) * this.scale, i = r.domBottom = r.domTop + (r.bottom - r.top), e = r.bottom } toDOM(r) { for (let t = 0, e = 0, i = 0; ; t++) { var s = t < this.viewports.length ? this.viewports[t] : null; if (!s || r < s.top) return i + (r - e) * this.scale; if (r <= s.bottom) return s.domTop + (r - s.top); e = s.bottom, i = s.domBottom } } fromDOM(r) { for (let t = 0, e = 0, i = 0; ; t++) { var s = t < this.viewports.length ? this.viewports[t] : null; if (!s || r < s.domTop) return e + (r - i) / this.scale; if (r <= s.domBottom) return s.top + (r - s.domTop); e = s.bottom, i = s.domBottom } } }; function fs(t, e) { var i, r; return 1 == e.scale ? t : (i = e.toDOM(t.top), r = e.toDOM(t.bottom), new Gr(t.from, t.length, i, r - i, Array.isArray(t._content) ? t._content.map(t => fs(t, e)) : t._content)) } var ps = d.define({ combine: t => t.join(" ") }), ms = d.define({ combine: t => -1 < t.indexOf(!0) }), gs = ue.newName(), vs = ue.newName(), ws = ue.newName(), bs = { "&light": "." + vs, "&dark": "." + ws }; function ys(e, t, i) { return new ue(t, { finish(t) { return /&/.test(t) ? t.replace(/&\w*/, t => { if ("&" == t) return e; if (i && i[t]) return i[t]; throw new RangeError("Unsupported selector: " + t) }) : e + " " + t } }) } var xs = ys("." + gs, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, bs), ks = class { constructor(t, e) { this.points = t, this.text = "", this.lineSeparator = e.facet(w.lineSeparator) } append(t) { this.text += t } lineBreak() { this.text += "ï¿¿" } readRange(e, i) { if (e) { var r = e.parentNode; for (let t = e; ;) { this.findPointBefore(r, t); var s = this.text.length, n = (this.readNode(t), t.nextSibling); if (n == i) break; var o = y.get(t), a = y.get(n); (o && a ? o.breakAfter : (o ? o.breakAfter : Ss(t)) || Ss(n) && ("BR" != t.nodeName || t.cmIgnore) && this.text.length > s) && this.lineBreak(), t = n } this.findPointBefore(r, i) } return this } readTextNode(n) { var t, o = n.nodeValue; for (t of this.points) t.node == n && (t.pos = this.text.length + Math.min(t.offset, o.length)); for (let r = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ;) { let t = -1, e = 1, i; if (this.lineSeparator ? (t = o.indexOf(this.lineSeparator, r), e = this.lineSeparator.length) : (i = s.exec(o)) && (t = i.index, e = i[0].length), this.append(o.slice(r, t < 0 ? o.length : t)), t < 0) break; if (this.lineBreak(), 1 < e) for (var a of this.points) a.node == n && a.pos > this.text.length && (a.pos -= e - 1); r = t + e } } readNode(t) { if (!t.cmIgnore) { var e = y.get(t), e = e && e.overrideDOMText; if (null != e) { this.findPointInside(t, e.length); for (var i = e.iter(); !i.next().done;)i.lineBreak ? this.lineBreak() : this.append(i.value) } else 3 == t.nodeType ? this.readTextNode(t) : "BR" == t.nodeName ? t.nextSibling && this.lineBreak() : 1 == t.nodeType && this.readRange(t.firstChild, null) } } findPointBefore(t, e) { for (var i of this.points) i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length) } findPointInside(t, e) { for (var i of this.points) (3 == t.nodeType ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (((t, e, i) => { for (; ;) { if (!e || i < Oe(e)) return; if (e == t) return 1; i = Ce(e) + 1, e = e.parentNode } })(t, i.node, i.offset) ? e : 0)) } }; function Ss(t) { return 1 == t.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName) } var Cs = class { constructor(t, e) { this.node = t, this.offset = e, this.pos = -1 } }, As = class { constructor(i, r, s, n) { this.typeOver = n, this.bounds = null, this.text = ""; var { impreciseHead: n, impreciseAnchor: o } = i.docView; if (i.state.readOnly && -1 < r) this.newSel = null; else if (-1 < r && (this.bounds = i.docView.domBoundsAround(r, s, 0))) { var s = n || o ? [] : (r = [], (s = i).root.activeElement == s.contentDOM && ({ anchorNode: s, anchorOffset: t, focusNode: a, focusOffset: h } = s.observer.selectionRange, s) && (r.push(new Cs(s, t)), a == s && h == t || r.push(new Cs(a, h))), r), t = new ks(s, i.state); t.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = t.text, this.newSel = ((t, e) => { var i; return 0 != t.length && (i = t[0].pos, t = 2 == t.length ? t[1].pos : i, -1 < i) && -1 < t ? v.single(i + e, t + e) : null })(s, this.bounds.from) } else { var a = i.observer.selectionRange; let t = n && n.node == a.focusNode && n.offset == a.focusOffset || !ye(i.contentDOM, a.focusNode) ? i.state.selection.main.head : i.docView.posFromDOM(a.focusNode, a.focusOffset), e = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !ye(i.contentDOM, a.anchorNode) ? i.state.selection.main.anchor : i.docView.posFromDOM(a.anchorNode, a.anchorOffset); var h = i.viewport; x.ios && i.state.selection.main.empty && t != e && (0 < h.from || h.to < i.state.doc.length) && (r = h.from - Math.min(t, e), s = h.to - Math.max(t, e), 0 != r && 1 != r || 0 != s && -1 != s || (t = 0, e = i.state.doc.length)), this.newSel = v.single(e, t) } } }; function Os(r, i) { let s, n = i.newSel, o = r.state.selection.main; var a = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1; if (i.bounds) { var { from: h, to: l } = i.bounds; let t = o.from, e = null; (8 === a || x.android && i.text.length < l - h) && (t = o.to, e = "end"); l = ((t, e, i, r) => { let s = Math.min(t.length, e.length), n = 0; for (; n < s && t.charCodeAt(n) == e.charCodeAt(n);)n++; if (n == s && t.length == e.length) return null; let o = t.length, a = e.length; for (; 0 < o && 0 < a && t.charCodeAt(o - 1) == e.charCodeAt(a - 1);)o--, a--; return "end" == r && (r = Math.max(0, n - Math.min(o, a)), i -= o + r - n), o < n && t.length < e.length ? (r = i <= n && i >= o ? n - i : 0, n -= r, a = n + (a - o), o = n) : a < n && (r = i <= n && i >= a ? n - i : 0, n -= r, o = n + (o - a), a = n), { from: n, toA: o, toB: a } })(r.state.doc.sliceString(h, l, "ï¿¿"), i.text, t - h, e); l && (x.chrome && 13 == a && l.toB == l.from + 2 && "ï¿¿ï¿¿" == i.text.slice(l.from, l.toB) && l.toB--, s = { from: h + l.from, to: h + l.toA, insert: g.of(i.text.slice(l.from, l.toB).split("ï¿¿")) }) } else n && (!r.hasFocus && r.state.facet(_i) || n.main.eq(o)) && (n = null); if (!s && !n) return !1; if (!s && i.typeOver && !o.empty && n && n.main.empty ? s = { from: o.from, to: o.to, insert: r.state.doc.slice(o.from, o.to) } : s && s.from >= o.from && s.to <= o.to && (s.from != o.from || s.to != o.to) && o.to - o.from - (s.to - s.from) <= 4 ? s = { from: o.from, to: o.to, insert: r.state.doc.slice(o.from, s.from).append(s.insert).append(r.state.doc.slice(s.to, o.to)) } : (x.mac || x.android) && s && s.from == s.to && s.from == o.head - 1 && /^\. ?$/.test(s.insert.toString()) && "off" == r.contentDOM.getAttribute("autocorrect") ? (n && 2 == s.insert.length && (n = v.single(n.main.anchor - 1, n.main.head - 1)), s = { from: o.from, to: o.to, insert: g.of([" "]) }) : x.chrome && s && s.from == s.to && s.from == o.head && "\n " == s.insert.toString() && r.lineWrapping && (n = n && v.single(n.main.anchor - 1, n.main.head - 1), s = { from: o.from, to: o.to, insert: g.of([" "]) }), s) { if ((!x.ios || !r.inputState.flushIOSKey()) && (!x.android || !(s.from == o.from && s.to == o.to && 1 == s.insert.length && 2 == s.insert.lines && Le(r.contentDOM, "Enter", 13) || (s.from == o.from - 1 && s.to == o.to && 0 == s.insert.length || 8 == a && s.insert.length < s.to - s.from && s.to > o.head) && Le(r.contentDOM, "Backspace", 8) || s.from == o.from && s.to == o.to + 1 && 0 == s.insert.length && Le(r.contentDOM, "Delete", 46)))) { let e = s.insert.toString(); 0 <= r.inputState.composing && r.inputState.composing++; let t, i = () => t = t || ((l, c, e) => { let i, d = l.state, u = d.selection.main; if (c.from >= u.from && c.to <= u.to && c.to - c.from >= (u.to - u.from) / 3 && (!e || e.main.empty && e.main.from == c.from + c.insert.length) && l.inputState.composing < 0) { var f = u.from < c.from ? d.sliceDoc(u.from, c.from) : "", t = u.to > c.to ? d.sliceDoc(c.to, u.to) : ""; i = d.replaceSelection(l.state.toText(f + c.insert.sliceString(0, void 0, l.state.lineBreak) + t)) } else { let a = d.changes(c), h = e && e.main.to <= a.newLength ? e.main : void 0; if (1 < d.selection.ranges.length && 0 <= l.inputState.composing && c.to <= u.to && c.to >= u.to - 10) { let r = l.state.sliceDoc(c.from, c.to), s, t = e && ar(l, e.main.head); s = t ? (f = c.insert.length - (c.to - c.from), { from: t.from, to: t.to - f }) : l.state.doc.lineAt(u.head); let n = u.to - c.to, o = u.to - u.from; i = d.changeByRange(t => { var e, i; return t.from == u.from && t.to == u.to ? { changes: a, range: h || t.map(a) } : (e = (i = t.to - n) - r.length, t.to - t.from != o || l.state.sliceDoc(e, i) != r || t.to >= s.from && t.from <= s.to ? { range: t } : (e = d.changes({ from: e, to: i, insert: c.insert }), i = t.to - u.to, { changes: e, range: h ? v.range(Math.max(0, h.anchor + i), Math.max(0, h.head + i)) : t.map(e) })) }) } else i = { changes: a, selection: h && d.selection.replaceRange(h) } } let r = "input.type"; return (l.composing || l.inputState.compositionPendingChange && l.inputState.compositionEndedAt > Date.now() - 50) && (l.inputState.compositionPendingChange = !1, r += ".compose", l.inputState.compositionFirstChange) && (r += ".start", l.inputState.compositionFirstChange = !1), d.update(i, { userEvent: r, scrollIntoView: !0 }) })(r, s, n); r.state.facet(Ii).some(t => t(r, s.from, s.to, e, i)) || r.dispatch(i()) } return !0 } if (!n || n.main.eq(o)) return !1; { let t = !1, e = "select"; return r.inputState.lastSelectionTime > Date.now() - 50 && ("select" == r.inputState.lastSelectionOrigin && (t = !0), e = r.inputState.lastSelectionOrigin), r.dispatch({ selection: n, scrollIntoView: t, userEvent: e }), !0 } } var Ms = { childList: !0, characterData: !0, subtree: !0, attributes: !0, characterDataOldValue: !0 }, Ts = x.ie && x.ie_version <= 11, Ds = class { constructor(i) { this.view = i, this.active = !1, this.selectionRange = new Pe, this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = i.contentDOM, this.observer = new MutationObserver(t => { for (var e of t) this.queue.push(e); (x.ie && x.ie_version <= 11 || x.ios && i.composing) && t.some(t => "childList" == t.type && t.removedNodes.length || "characterData" == t.type && t.oldValue.length > t.target.nodeValue.length) ? this.flushSoon() : this.flush() }), Ts && (this.onCharData = t => { this.queue.push({ target: t.target, type: "characterData", oldValue: t.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver(() => { var t; (null == (t = this.view.docView) ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize() }), this.resizeScroll.observe(i.scrollDOM)), this.addWindowListeners(this.win = i.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver(t => { this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), 0 < t.length && 0 < t[t.length - 1].intersectionRatio != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView) && this.onScrollChanged(document.createEvent("Event")) }, { threshold: [0, .001] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver(t => { 0 < t.length && 0 < t[t.length - 1].intersectionRatio && this.onScrollChanged(document.createEvent("Event")) }, {})), this.listenForScroll(), this.readSelectionRange() } onScrollChanged(t) { this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure() } onScroll(t) { this.intersecting && this.flush(!1), this.onScrollChanged(t) } onResize() { this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => { this.resizeTimeout = -1, this.view.requestMeasure() }, 50)) } onPrint() { this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => { this.view.viewState.printing = !1, this.view.requestMeasure() }, 500) } updateGaps(i) { if (this.gapIntersection && (i.length != this.gaps.length || this.gaps.some((t, e) => t != i[e]))) { this.gapIntersection.disconnect(); for (var t of i) this.gapIntersection.observe(t); this.gaps = i } } onSelectionChange(t) { var e, i, r, s = this.selectionChanged; this.readSelectionRange() && !this.delayedAndroidKey && (e = this.view, i = this.selectionRange, e.state.facet(_i) ? e.root.activeElement == this.dom : xe(e.dom, i)) && ((r = i.anchorNode && e.docView.nearest(i.anchorNode)) && r.ignoreEvent(t) ? s || (this.selectionChanged = !1) : (x.ie && x.ie_version <= 11 || x.android && x.chrome) && !e.state.selection.main.empty && i.focusNode && Se(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1)) } readSelectionRange() { var t, e = this.view, i = x.safari && 11 == e.root.nodeType && (t => { let e = t.activeElement; for (; e && e.shadowRoot;)e = e.shadowRoot.activeElement; return e })(this.dom.ownerDocument) == this.dom && (t => { let e = null; function i(t) { t.preventDefault(), t.stopImmediatePropagation(), e = t.getTargetRanges()[0] } if (t.contentDOM.addEventListener("beforeinput", i, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, !0), !e) return null; let r = e.startContainer, s = e.startOffset, n = e.endContainer, o = e.endOffset, a = t.docView.domAtPos(t.state.selection.main.anchor); return Se(a.node, a.offset, n, o) && ([r, s, n, o] = [n, o, r, s]), { anchorNode: r, anchorOffset: s, focusNode: n, focusOffset: o } })(this.view) || be(e.root); return !(!i || this.selectionRange.eq(i) || ((t = xe(this.dom, i)) && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && ((t, e) => { let i = e.focusNode, r = e.focusOffset; if (i && e.anchorNode == i && e.anchorOffset == r) for (r = Math.min(r, Oe(i)); ;)if (r) { if (1 != i.nodeType) return; var s = i.childNodes[r - 1]; "false" == s.contentEditable ? r-- : (i = s, r = Oe(i)) } else { if (i == t) return 1; r = Ce(i), i = i.parentNode } })(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), 1) : (this.selectionRange.setRange(i), t && (this.selectionChanged = !0), 0))) } setSelectionRange(t, e) { this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1 } clearSelectionRange() { this.selectionRange.set(null, 0, null, 0) } listenForScroll() { this.parentCheck = -1; let e = 0, i = null; for (let t = this.dom; t;)if (1 == t.nodeType) !i && e < this.scrollTargets.length && this.scrollTargets[e] == t ? e++ : i = i || this.scrollTargets.slice(0, e), i && i.push(t), t = t.assignedSlot || t.parentNode; else { if (11 != t.nodeType) break; t = t.host } if (i = e < this.scrollTargets.length && !i ? this.scrollTargets.slice(0, e) : i) { for (var t of this.scrollTargets) t.removeEventListener("scroll", this.onScroll); for (var r of this.scrollTargets = i) r.addEventListener("scroll", this.onScroll) } } ignore(t) { if (!this.active) return t(); try { return this.stop(), t() } finally { this.start(), this.clear() } } start() { this.active || (this.observer.observe(this.dom, Ms), Ts && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0) } stop() { this.active && (this.active = !1, this.observer.disconnect(), Ts) && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData) } clear() { this.processRecords(), this.queue.length = 0, this.selectionChanged = !1 } delayAndroidKey(t, e) { this.delayedAndroidKey || (this.flushingAndroidKey = this.view.win.requestAnimationFrame(() => { var t = this.delayedAndroidKey; t && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = t.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush()) && t.force && Le(this.dom, t.key, t.keyCode) })), this.delayedAndroidKey && "Enter" != t || (this.delayedAndroidKey = { key: t, keyCode: e, force: this.lastChange < Date.now() - 50 || !(null == (t = this.delayedAndroidKey) || !t.force) }) } clearDelayedAndroidKey() { this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1 } flushSoon() { this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1, this.flush() })) } forceFlush() { 0 <= this.delayedFlush && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush() } pendingRecords() { for (var t of this.observer.takeRecords()) this.queue.push(t); return this.queue } processRecords() { var t, e = this.pendingRecords(); e.length && (this.queue = []); let i = -1, r = -1, s = !1; for (t of e) { var n = this.readMutation(t); n && (n.typeOver && (s = !0), -1 == i ? { from: i, to: r } = n : (i = Math.min(n.from, i), r = Math.max(n.to, r))) } return { from: i, to: r, typeOver: s } } readChange() { var { from: t, to: e, typeOver: i } = this.processRecords(), r = this.selectionChanged && xe(this.dom, this.selectionRange); if (t < 0 && !r) return null; -1 < t && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1; r = new As(this.view, t, e, i); return this.view.docView.domChanged = { newSel: r.newSel ? r.newSel.main : null }, r } flush(t = !0) { if (0 <= this.delayedFlush || this.delayedAndroidKey) return !1; t && this.readSelectionRange(); var e, t = this.readChange(); return t ? (e = this.view.state, t = Os(this.view, t), this.view.state == e && this.view.update([]), t) : (this.view.requestMeasure(), !1) } readMutation(t) { var e, i, r = this.view.docView.nearest(t.target); return !r || r.ignoreMutation(t) ? null : (r.markDirty("attributes" == t.type), "attributes" == t.type && (r.flags |= 4), "childList" == t.type ? (e = Ps(r, t.previousSibling || t.target.previousSibling, -1), i = Ps(r, t.nextSibling || t.target.nextSibling, 1), { from: e ? r.posAfter(e) : r.posAtStart, to: i ? r.posBefore(i) : r.posAtEnd, typeOver: !1 }) : "characterData" == t.type ? { from: r.posAtStart, to: r.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null) } setWindow(t) { t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win)) } addWindowListeners(t) { t.addEventListener("resize", this.onResize), t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange) } removeWindowListeners(t) { t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange) } destroy() { var t, e; this.stop(), null != (t = this.intersection) && t.disconnect(), null != (t = this.gapIntersection) && t.disconnect(), null != (t = this.resizeScroll) && t.disconnect(); for (e of this.scrollTargets) e.removeEventListener("scroll", this.onScroll); this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey) } }; function Ps(t, e, i) { for (; e;) { var r = y.get(e); if (r && r.parent == t) return r; r = e.parentNode; e = r != t.dom ? r : 0 < i ? e.nextSibling : e.previousSibling } return null } var T = class Tf { get state() { return this.viewState.state } get viewport() { return this.viewState.viewport } get visibleRanges() { return this.viewState.visibleRanges } get inView() { return this.viewState.inView } get composing() { return 0 < this.inputState.composing } get compositionStarted() { return 0 <= this.inputState.composing } get root() { return this._root } get win() { return this.dom.ownerDocument.defaultView || window } constructor(t = {}) { this.plugins = [], this.pluginMap = new Map, this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom); let e = t.dispatch; this.dispatchTransactions = t.dispatchTransactions || (e ? t => t.forEach(t => e(t, this)) : t => this.update(t)), this.dispatch = this.dispatch.bind(this), this._root = t.root || (t => { for (; t;) { if (t && (9 == t.nodeType || 11 == t.nodeType && t.host)) return t; t = t.assignedSlot || t.parentNode } return null })(t.parent) || document, this.viewState = new as(t.state || w.create(t)), t.scrollTo && t.scrollTo.is(Fi) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Ui).map(t => new Qi(t)); for (var i of this.plugins) i.update(this); this.observer = new Ds(this), this.inputState = new xr(this), this.inputState.ensureHandlers(this.plugins), this.docView = new nr(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure() } dispatch(...t) { t = 1 == t.length && t[0] instanceof Nt ? t : 1 == t.length && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)]; this.dispatchTransactions(t, this) } update(o) { if (0 != this.updateState) throw new Error("Calls to EditorView.update are not allowed while an update is in progress"); let a = !1, h = !1, l, c = this.state; for (var t of o) { if (t.startState != c) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state."); c = t.state } if (this.destroyed) this.viewState.state = c; else { let t = this.hasFocus, e = 0, i = null, r = (o.some(t => t.annotation(_r)) ? (this.inputState.notifiedFocused = t, e = 1) : t == this.inputState.notifiedFocused || (this.inputState.notifiedFocused = t, i = jr(c, t)) || (e = 1), this.observer.delayedAndroidKey), s = null; if (r ? (this.observer.clearDelayedAndroidKey(), (!(s = this.observer.readChange()) || this.state.doc.eq(c.doc)) && this.state.selection.eq(c.selection) || (s = null)) : this.observer.clear(), c.facet(w.phrases) != this.state.facet(w.phrases)) return this.setState(c); (l = sr.create(this, c, o)).flags |= e; let n = this.viewState.scrollTarget; try { this.updateState = 2; for (var d of o) { var u, f; n = n && n.map(d.changes), d.scrollIntoView && (u = d.state.selection.main, n = new zi(u.empty ? u : v.cursor(u.head, u.head > u.anchor ? -1 : 1))); for (f of d.effects) f.is(Fi) && (n = f.value.clip(this.state)) } this.viewState.update(l, n), this.bidiCache = Es.update(this.bidiCache, l.changes), l.empty || (this.updatePlugins(l), this.inputState.update(l)), a = this.docView.update(l), this.state.facet(ir) != this.styleModules && this.mountStyles(), h = this.updateAttrs(), this.showAnnouncements(o), this.docView.updateSelection(a, o.some(t => t.isUserEvent("select.pointer"))) } finally { this.updateState = 0 } if (l.startState.facet(ps) != l.state.facet(ps) && (this.viewState.mustMeasureContent = !0), (a || h || n || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !l.empty) for (var p of this.state.facet(Ni)) try { p(l) } catch (t) { qi(this.state, t, "update listener") } (i || s) && Promise.resolve().then(() => { i && this.state == i.startState && this.dispatch(i), s && !Os(this, s) && r.force && Le(this.contentDOM, r.key, r.keyCode) }) } } setState(t) { if (0 != this.updateState) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress"); if (this.destroyed) this.viewState.state = t; else { this.updateState = 2; var e = this.hasFocus; try { for (var i of this.plugins) i.destroy(this); this.viewState = new as(t), this.plugins = t.facet(Ui).map(t => new Qi(t)), this.pluginMap.clear(); for (var r of this.plugins) r.update(this); this.docView.destroy(), this.docView = new nr(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [] } finally { this.updateState = 0 } e && this.focus(), this.requestMeasure() } } updatePlugins(t) { var e = t.startState.facet(Ui), i = t.state.facet(Ui); if (e != i) { var r, s, n = []; for (r of i) { var o = e.indexOf(r); o < 0 ? n.push(new Qi(r)) : ((o = this.plugins[o]).mustUpdate = t, n.push(o)) } for (s of this.plugins) s.mustUpdate != t && s.destroy(this); this.plugins = n, this.pluginMap.clear() } else for (var a of this.plugins) a.mustUpdate = t; for (let t = 0; t < this.plugins.length; t++)this.plugins[t].update(this); e != i && this.inputState.ensureHandlers(this.plugins) } measure(t = !0) { if (!this.destroyed) if (-1 < this.measureScheduled && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) this.measureScheduled = -1, this.requestMeasure(); else { this.measureScheduled = 0, t && this.observer.forceFlush(); let s = null, n = this.scrollDOM, o = n.scrollTop * this.scaleY, { scrollAnchorPos: a, scrollAnchorHeight: h } = this.viewState; 1 < Math.abs(o - this.viewState.scrollTop) && (h = -1), this.viewState.scrollAnchorHeight = -1; try { for (let r = 0; ; r++) { h < 0 && (h = Ie(n) ? (a = -1, this.viewState.heightMap.height) : (l = this.viewState.scrollAnchorAt(o), a = l.from, l.top)), this.updateState = 1; var l, c = this.viewState.measure(this); if (!c && !this.measureRequests.length && null == this.viewState.scrollTarget) break; if (5 < r) { console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize"); break } let e = []; 4 & c || ([this.measureRequests, e] = [e, this.measureRequests]); var d = e.map(t => { try { return t.read(this) } catch (t) { return qi(this.state, t), Bs } }); let t = sr.create(this, this.state, []), i = !1; t.flags |= c, s ? s.flags |= c : s = t, this.updateState = 2, t.empty || (this.updatePlugins(t), this.inputState.update(t), this.updateAttrs(), i = this.docView.update(t)); for (let t = 0; t < e.length; t++)if (d[t] != Bs) try { var u = e[t]; u.write && u.write(d[t], this) } catch (t) { qi(this.state, t) } if (i && this.docView.updateSelection(!0), !t.viewportChanged && 0 == this.measureRequests.length) { if (this.viewState.editorHeight) { if (this.viewState.scrollTarget) { this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, h = -1; continue } var f = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - h; if (1 < f || f < -1) { o += f, n.scrollTop = o / this.scaleY, h = -1; continue } } break } } } finally { this.updateState = 0, this.measureScheduled = -1 } if (s && !s.empty) for (var e of this.state.facet(Ni)) e(s) } } get themeClasses() { return gs + " " + (this.state.facet(ms) ? ws : vs) + " " + this.state.facet(ps) } updateAttrs() { let i = Ls(this, $i, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), r = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(_i) ? "true" : "false", class: "cm-content", style: x.tabSize + ": " + this.state.tabSize, role: "textbox", "aria-multiline": "true" }; this.state.readOnly && (r["aria-readonly"] = "true"), Ls(this, Ki, r); var t = this.observer.ignore(() => { var t = ni(this.contentDOM, this.contentAttrs, r), e = ni(this.dom, this.editorAttrs, i); return t || e }); return this.editorAttrs = i, this.contentAttrs = r, t } showAnnouncements(t) { let e = !0; for (var i of t) for (var r of i.effects) r.is(Tf.announce) && (e && (this.announceDOM.textContent = ""), e = !1, this.announceDOM.appendChild(document.createElement("div")).textContent = r.value) } mountStyles() { this.styleModules = this.state.facet(ir); var t = this.state.facet(Tf.cspNonce); ue.mount(this.root, this.styleModules.concat(xs).reverse(), t ? { nonce: t } : void 0) } readMeasured() { if (2 == this.updateState) throw new Error("Reading the editor layout isn't allowed during an update"); 0 == this.updateState && -1 < this.measureScheduled && this.measure(!1) } requestMeasure(e) { if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e && !(-1 < this.measureRequests.indexOf(e))) { if (null != e.key) for (let t = 0; t < this.measureRequests.length; t++)if (this.measureRequests[t].key === e.key) return void (this.measureRequests[t] = e); this.measureRequests.push(e) } } plugin(e) { let t = this.pluginMap.get(e); return (void 0 === t || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find(t => t.spec == e) || null), t && t.update(this).value } get documentTop() { return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop } get documentPadding() { return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom } } get scaleX() { return this.viewState.scaleX } get scaleY() { return this.viewState.scaleY } elementAtHeight(t) { return this.readMeasured(), this.viewState.elementAtHeight(t) } lineBlockAtHeight(t) { return this.readMeasured(), this.viewState.lineBlockAtHeight(t) } get viewportLineBlocks() { return this.viewState.viewportLines } lineBlockAt(t) { return this.viewState.lineBlockAt(t) } get contentHeight() { return this.viewState.contentHeight } moveByChar(t, e, i) { return yr(this, t, wr(this, t, e, i)) } moveByGroup(n, t) { return yr(this, n, wr(this, n, t, t => { { var r = this, s = n.head; let e = r.state.charCategorizer(s), i = e(t); return t => { t = e(t); return (i = i == m.Space ? t : i) == t } } })) } visualLineSide(t, e) { var i = this.bidiSpans(t), r = this.textDirectionAt(t.from), i = i[e ? i.length - 1 : 0]; return v.cursor(i.side(e, r) + t.from, i.forward(!e, r) ? 1 : -1) } moveToLineBoundary(t, e, i = !0) { var r = vr(n = this, (t = t).head); if (i = i && r.type == A.Text && (n.lineWrapping || r.widgetLineBreaks) ? n.coordsAtPos(t.assoc < 0 && t.head > r.from ? t.head - 1 : t.head) : null) { var t = n.dom.getBoundingClientRect(), s = n.textDirectionAt(r.from), n = n.posAtCoords({ x: e == (s == O.LTR) ? t.right - 1 : t.left + 1, y: (i.top + i.bottom) / 2 }); if (null != n) return v.cursor(n, e ? -1 : 1) } return v.cursor(e ? r.to : r.from, e ? -1 : 1) } moveVertically(t, e, i) { return yr(this, t, ((e, t, i, r) => { var s = t.head, n = i ? 1 : -1; if (s == (i ? e.state.doc.length : 0)) return v.cursor(s, t.assoc); let o = t.goalColumn, a; var h = e.contentDOM.getBoundingClientRect(), i = e.coordsAtPos(s, t.assoc || -1), t = e.documentTop, l = (a = i ? (null == o && (o = i.left - h.left), n < 0 ? i.top : i.bottom) : (i = e.viewState.lineBlockAt(s), null == o && (o = Math.min(h.right - h.left, e.defaultCharacterWidth * (s - i.from))), (n < 0 ? i.top : i.bottom) + t), h.left + o), c = null != r ? r : e.viewState.heightOracle.textHeight >> 1; for (let t = 0; ; t += 10) { var d, u = a + (c + t) * n, f = mr(e, { x: l, y: u }, !1, n); if (u < h.top || u > h.bottom || (n < 0 ? f < s : s < f)) return u = !(d = e.docView.coordsForChar(f)) || u < d.top ? -1 : 1, v.cursor(f, u, void 0, o) } })(this, t, e, i)) } domAtPos(t) { return this.docView.domAtPos(t) } posAtDOM(t, e = 0) { return this.docView.posFromDOM(t, e) } posAtCoords(t, e = !0) { return this.readMeasured(), mr(this, t, e) } coordsAtPos(t, e = 1) { this.readMeasured(); var i, r, s = this.docView.coordsAt(t, e); return s && s.left != s.right ? (i = this.state.doc.lineAt(t), Me(s, (r = this.bidiSpans(i))[Mi.find(r, t - i.from, -1, e)].dir == O.LTR == 0 < e)) : s } coordsForChar(t) { return this.readMeasured(), this.docView.coordsForChar(t) } get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth } get defaultLineHeight() { return this.viewState.heightOracle.lineHeight } get textDirection() { return this.viewState.defaultTextDirection } textDirectionAt(t) { return !this.state.facet(Hi) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t)) } get lineWrapping() { return this.viewState.heightOracle.lineWrapping } bidiSpans(t) { if (t.length > Rs) return Di(t.length); let e = this.textDirectionAt(t.from), i; for (var r of this.bidiCache) if (r.from == t.from && r.dir == e && (r.fresh || function e(i, r) { if (i.length == r.length) { for (let t = 0; t < i.length; t++) { var s = i[t], n = r[t]; if (s.from != n.from || s.to != n.to || s.direction != n.direction || !e(s.inner, n.inner)) return } return 1 } }(r.isolates, i = Zi(this, t)))) return r.order; i = i || Zi(this, t); var s = ((t, e, i) => { if (!t) return [new Mi(0, 0, e == gi ? 1 : 0)]; if (e == mi && !i.length && !Oi.test(t)) return Di(t.length); if (i.length) for (; t.length > N.length;)N[N.length] = 256; var r = []; return Ti(t, e = e == mi ? 0 : 1, e, i, 0, t.length, r), r })(t.text, e, i); return this.bidiCache.push(new Es(t.from, t.to, e, i, !0, s)), s } get hasFocus() { var t; return (this.dom.ownerDocument.hasFocus() || x.safari && (null == (t = this.inputState) ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM } focus() { this.observer.ignore(() => { Be(this.contentDOM), this.docView.updateSelection() }) } setRoot(t) { this._root != t && (this._root = t, this.observer.setWindow((9 == t.nodeType ? t : t.ownerDocument).defaultView || window), this.mountStyles()) } destroy() { for (var t of this.plugins) t.destroy(this); this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), -1 < this.measureScheduled && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0 } static scrollIntoView(t, e = {}) { return Fi.of(new zi("number" == typeof t ? v.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin)) } scrollSnapshot() { var { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t); return Fi.of(new zi(v.cursor(i.from), "start", "start", i.top - t, e, !0)) } static domEventHandlers(t) { return a.define(() => ({}), { eventHandlers: t }) } static domEventObservers(t) { return a.define(() => ({}), { eventObservers: t }) } static theme(t, e) { var i = ue.newName(), i = [ps.of(i), ir.of(ys("." + i, t))]; return e && e.dark && i.push(ms.of(!0)), i } static baseTheme(t) { return wt.lowest(ir.of(ys("." + gs, t, bs))) } static findFromDOM(t) { var e = t.querySelector(".cm-content"), e = e && y.get(e) || y.get(t); return (null == (t = null == e ? void 0 : e.rootView) ? void 0 : t.view) || null } }, Rs = (T.styleModule = ir, T.inputHandler = Ii, T.focusChangeEffect = Vi, T.perLineTextDirection = Hi, T.exceptionSink = Li, T.updateListener = Ni, T.editable = _i, T.mouseSelectionStyle = Ei, T.dragMovesSelection = Bi, T.clickAddsSelectionRange = Ri, T.decorations = Xi, T.outerDecorations = Gi, T.atomicRanges = Yi, T.bidiIsolatedRanges = Ji, T.scrollMargins = tr, T.darkTheme = ms, T.cspNonce = d.define({ combine: t => t.length ? t[0] : "" }), T.contentAttributes = Ki, T.editorAttributes = $i, T.lineWrapping = T.contentAttributes.of({ class: "cm-lineWrapping" }), T.announce = c.define(), 4096), Bs = {}, Es = class Df { constructor(t, e, i, r, s, n) { this.from = t, this.to = e, this.dir = i, this.isolates = r, this.fresh = s, this.order = n } static update(e, i) { if (i.empty && !e.some(t => t.fresh)) return e; var r = [], s = e.length ? e[e.length - 1].dir : O.LTR; for (let t = Math.max(0, e.length - 10); t < e.length; t++) { var n = e[t]; n.dir != s || i.touchesRange(n.from, n.to) || r.push(new Df(i.mapPos(n.from, 1), i.mapPos(n.to, -1), n.dir, n.isolates, !1, n.order)) } return r } }; function Ls(i, r, s) { for (let t = i.state.facet(r), e = t.length - 1; 0 <= e; e--) { var n = t[e], n = "function" == typeof n ? n(i) : n; n && ii(n, s) } return s } var Ns = x.mac ? "mac" : x.windows ? "win" : x.linux ? "linux" : "key"; function Is(t, e, i) { return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), t = !1 !== i && e.shiftKey ? "Shift-" + t : t } var Ue = wt.default(T.domEventHandlers({ keydown(t, e) { return qs(Ws(e.state), t, e, "editor") } })), Vs = d.define({ enables: Ue }), Hs = new WeakMap; function Ws(t) { t = t.facet(Vs); let e = Hs.get(t); return e || Hs.set(t, e = ((t, l = Ns) => { let a = Object.create(null), r = Object.create(null), h = (t, e) => { var i = r[t]; if (null == i) r[t] = e; else if (i != e) throw new Error("Key binding " + t + " is used both as a regular binding and as a multi-stroke prefix") }, e = (r, t, e, i, s) => { var n = a[r] || (a[r] = Object.create(null)), o = t.split(/ (?!$)/).map(n => { { var o = l, a = n.split(/-(?!$)/); let t = a[a.length - 1]; "Space" == t && (t = " "); let e, i, r, s; for (let t = 0; t < a.length - 1; ++t) { var h = a[t]; if (/^(cmd|meta|m)$/i.test(h)) s = !0; else if (/^a(lt)?$/i.test(h)) e = !0; else if (/^(c|ctrl|control)$/i.test(h)) i = !0; else if (/^s(hift)?$/i.test(h)) r = !0; else { if (!/^mod$/i.test(h)) throw new Error("Unrecognized modifier name: " + h); "mac" == o ? s = !0 : i = !0 } } return e && (t = "Alt-" + t), i && (t = "Ctrl-" + t), s && (t = "Meta-" + t), t = r ? "Shift-" + t : t } }); for (let t = 1; t < o.length; t++) { let i = o.slice(0, t).join(" "); h(i, !0), n[i] || (n[i] = { preventDefault: !0, stopPropagation: !1, run: [t => { let e = zs = { view: t, prefix: i, scope: r }; return setTimeout(() => { zs == e && (zs = null) }, Fs), !0 }] }) } var t = o.join(" "), t = (h(t, !1), n[t] || (n[t] = { preventDefault: !1, stopPropagation: !1, run: (null == (t = null == (t = n._any) ? void 0 : t.run) ? void 0 : t.slice()) || [] })); e && t.run.push(e), i && (t.preventDefault = !0), s && (t.stopPropagation = !0) }; for (var i of t) { var s = i.scope ? i.scope.split(" ") : ["editor"]; if (i.any) for (var n of s) { var o, c = a[n] || (a[n] = Object.create(null)); for (o in c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] }), c) c[o].run.push(i.any) } var d = i[l] || i.key; if (d) for (var u of s) e(u, d, i.run, i.preventDefault, i.stopPropagation), i.shift && e(u, "Shift-" + d, i.shift, i.preventDefault, i.stopPropagation) } return a })(t.reduce((t, e) => t.concat(e), []))), e } var zs = null, Fs = 4e3; function qs(t, i, r, e) { s = i; var s = s = "Down" == (s = "Right" == (s = "Up" == (s = "Left" == (s = "Del" == (s = "Esc" == (s = !(ve && s.metaKey && s.shiftKey && !s.ctrlKey && !s.altKey || we && s.shiftKey && s.key && 1 == s.key.length || "Unidentified" == s.key) && s.key || (s.shiftKey ? ge : me)[s.keyCode] || s.key || "Unidentified") ? "Escape" : s) ? "Delete" : s) ? "ArrowLeft" : s) ? "ArrowUp" : s) ? "ArrowRight" : s) ? "ArrowDown" : s, n = Z(S(s, 0)) == s.length && " " != s; let o = "", a = !1, h = !1, l = !1, c = (zs && zs.view == r && zs.scope == e && (o = zs.prefix + " ", Ar.indexOf(i.keyCode) < 0) && (h = !0, zs = null), new Set); var d = t => { if (t) { for (var e of t.run) if (!c.has(e) && (c.add(e), e(r, i))) return t.stopPropagation && (l = !0), !0; t.preventDefault && (t.stopPropagation && (l = !0), h = !0) } return !1 }; let u = t[e], f, p; return u && (d(u[o + Is(s, i, !n)]) ? a = !0 : n && (i.altKey || i.metaKey || i.ctrlKey) && !(x.windows && i.ctrlKey && i.altKey) && (f = me[i.keyCode]) && f != s ? (d(u[o + Is(f, i, !0)]) || i.shiftKey && (p = ge[i.keyCode]) != s && p != f && d(u[o + Is(p, i, !1)])) && (a = !0) : n && i.shiftKey && d(u[o + Is(s, i, !0)]) && (a = !0), !a) && d(u._any) && (a = !0), (a = h ? !0 : a) && l && i.stopPropagation(), a } var _s = class Pf { constructor(t, e, i, r, s) { this.className = t, this.left = e, this.top = i, this.width = r, this.height = s } draw() { var t = document.createElement("div"); return t.className = this.className, this.adjust(t), t } update(t, e) { return e.className == this.className && (this.adjust(t), !0) } adjust(t) { t.style.left = this.left + "px", t.style.top = this.top + "px", null != this.width && (t.style.width = this.width + "px"), t.style.height = this.height + "px" } eq(t) { return this.left == t.left && this.top == t.top && this.width == t.width && this.height == t.height && this.className == t.className } static forRange(d, u, f) { var p; if (f.empty) return (p = d.coordsAtPos(f.head, f.assoc || 1)) ? (y = js(d), [new Pf(u, p.left - y.left, p.top - y.top, null, p.bottom - p.top)]) : []; { var b = d; var m = u; var y = f; if (y.to <= b.viewport.from || y.from >= b.viewport.to) return []; let t = Math.max(y.from, b.viewport.from), e = Math.min(y.to, b.viewport.to), g = b.textDirection == O.LTR, i = b.contentDOM, r = i.getBoundingClientRect(), s = js(b), n = i.querySelector(".cm-line"), o = n && window.getComputedStyle(n), v = r.left + (o ? parseInt(o.paddingLeft) + Math.min(0, parseInt(o.textIndent)) : 0), w = r.right - (o ? parseInt(o.paddingRight) : 0), a = vr(b, t), h = vr(b, e), l = a.type == A.Text ? a : null, c = h.type == A.Text ? h : null; return l && (b.lineWrapping || a.widgetLineBreaks) && (l = Us(b, t, l)), c && (b.lineWrapping || h.widgetLineBreaks) && (c = Us(b, e, c)), l && c && l.from == c.from ? k(S(y.from, y.to, l)) : (p = l ? S(y.from, null, l) : C(a, !1), y = c ? S(null, y.to, c) : C(h, !0), d = [], (l || a).to < (c || h).from - (l && c ? 1 : 0) || 1 < a.widgetLineBreaks && p.bottom + b.defaultLineHeight / 2 < y.top ? d.push(x(v, p.bottom, w, y.top)) : p.bottom < y.top && b.elementAtHeight((p.bottom + y.top) / 2).type == A.Text && (p.bottom = y.top = (p.bottom + y.top) / 2), k(p).concat(d).concat(k(y))); function x(t, e, i, r) { return new _s(m, t - s.left, e - s.top - .01, i - t, r - e + .01) } function k({ top: e, bottom: i, horizontal: r }) { var s = []; for (let t = 0; t < r.length; t += 2)s.push(x(r[t], e, r[t + 1], i)); return s } function S(i, r, n) { let o = 1e9, a = -1e9, h = []; function s(t, e, i, r, s) { t = b.coordsAtPos(t, t == n.to ? -2 : 2), i = b.coordsAtPos(i, i == n.from ? 2 : -2); t && i && (o = Math.min(t.top, i.top, o), a = Math.max(t.bottom, i.bottom, a), s == O.LTR ? h.push(g && e ? v : t.left, g && r ? w : i.right) : h.push(!g && r ? v : i.left, !g && e ? w : t.right)) } var l, c = null != i ? i : n.from, d = null != r ? r : n.to; for (l of b.visibleRanges) if (l.to > c && l.from < d) for (let t = Math.max(l.from, c), e = Math.min(l.to, d); ;) { var u, f = b.state.doc.lineAt(t); for (u of b.bidiSpans(f)) { var p = u.from + f.from, m = u.to + f.from; if (e <= p) break; m > t && s(Math.max(p, t), null == i && p <= c, Math.min(m, e), null == r && d <= m, u.dir) } if ((t = f.to + 1) >= e) break } return 0 == h.length && s(c, null == i, d, null == r, b.textDirection), { top: o, bottom: a, horizontal: h } } function C(t, e) { e = r.top + (e ? t.top : t.bottom); return { top: e, bottom: e, horizontal: [] } } return } } }; function js(t) { var e = t.scrollDOM.getBoundingClientRect(); return { left: (t.textDirection == O.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY } } function Us(t, e, i) { e = v.cursor(e); return { from: Math.max(i.from, t.moveToLineBoundary(e, !1, !0).from), to: Math.min(i.to, t.moveToLineBoundary(e, !0, !0).from), type: A.Text } } var Qs = class { constructor(t, e) { this.view = t, this.layer = e, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = t.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), e.above && this.dom.classList.add("cm-layer-above"), e.class && this.dom.classList.add(e.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(t.state), t.requestMeasure(this.measureReq), e.mount && e.mount(this.dom, t) } update(t) { t.startState.facet($s) != t.state.facet($s) && this.setOrder(t.state), (this.layer.update(t, this.dom) || t.geometryChanged) && (this.scale(), t.view.requestMeasure(this.measureReq)) } setOrder(t) { let e = 0, i = t.facet($s); for (; e < i.length && i[e] != this.layer;)e++; this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - e) } measure() { return this.layer.markers(this.view) } scale() { var { scaleX: t, scaleY: e } = this.view; t == this.scaleX && e == this.scaleY || (this.scaleX = t, this.scaleY = e, this.dom.style.transform = `scale(${1 / t}, ${1 / e})`) } draw(i) { if (i.length != this.drawn.length || i.some((t, e) => (t = t, e = this.drawn[e], !(t.constructor == e.constructor && t.eq(e))))) { let t = this.dom.firstChild, e = 0; for (var r of i) r.update && t && r.constructor && this.drawn[e].constructor && r.update(t, this.drawn[e]) ? (t = t.nextSibling, e++) : this.dom.insertBefore(r.draw(), t); for (; t;) { var s = t.nextSibling; t.remove(), t = s } this.drawn = i } } destroy() { this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove() } }, $s = d.define(); function Ks(e) { return [a.define(t => new Qs(t, e)), $s.of(e)] } var Xs = !x.ios, Gs = d.define({ combine(t) { return jt(t, { cursorBlinkRate: 1200, drawRangeCursor: !0 }, { cursorBlinkRate: (t, e) => Math.min(t, e), drawRangeCursor: (t, e) => t || e }) } }); function Ys(t) { return t.startState.facet(Gs) != t.state.facet(Gs) } var Js = Ks({ above: !0, markers(t) { var e, i = t.state, r = i.facet(Gs), s = []; for (e of i.selection.ranges) { var n = e == i.selection.main; if (e.empty ? !n || Xs : r.drawRangeCursor) { var o, n = n ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = e.empty ? e : v.cursor(e.head, e.head > e.anchor ? -1 : 1); for (o of _s.forRange(t, n, a)) s.push(o) } } return s }, update(t, e) { t.transactions.some(t => t.selection) && (e.style.animationName = "cm-blink" == e.style.animationName ? "cm-blink2" : "cm-blink"); var i = Ys(t); return i && Zs(t.state, e), t.docChanged || t.selectionSet || i }, mount(t, e) { Zs(e.state, t) }, class: "cm-cursorLayer" }); function Zs(t, e) { e.style.animationDuration = t.facet(Gs).cursorBlinkRate + "ms" } var tn = Ks({ above: !1, markers(e) { return e.state.selection.ranges.map(t => t.empty ? [] : _s.forRange(e, "cm-selectionBackground", t)).reduce((t, e) => t.concat(e)) }, update(t, e) { return t.docChanged || t.selectionSet || t.viewportChanged || Ys(t) }, class: "cm-selectionLayer" }), i = { ".cm-line": { "& ::selection": { backgroundColor: "transparent !important" }, "&::selection": { backgroundColor: "transparent !important" } } }, en = (Xs && (i[".cm-line"].caretColor = "transparent !important", i[".cm-content"] = { caretColor: "transparent !important" }), wt.highest(T.theme(i))), rn = c.define({ map(t, e) { return null == t ? null : e.mapPos(t) } }), sn = p.define({ create() { return null }, update(t, e) { return null != t && (t = e.changes.mapPos(t)), e.effects.reduce((t, e) => e.is(rn) ? e.value : t, t) } }), nn = a.fromClass(class { constructor(t) { this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) } } update(t) { var e, i = t.state.field(sn); null == i ? null != this.cursor && (null != (e = this.cursor) && e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(sn) != i || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq)) } readPos() { var t, e = this.view, i = e.state.field(sn), i = null != i && e.coordsAtPos(i); return i ? (t = e.scrollDOM.getBoundingClientRect(), { left: i.left - t.left + e.scrollDOM.scrollLeft * e.scaleX, top: i.top - t.top + e.scrollDOM.scrollTop * e.scaleY, height: i.bottom - i.top }) : null } drawCursor(t) { var e, i; this.cursor && ({ scaleX: e, scaleY: i } = this.view, t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / i + "px", this.cursor.style.height = t.height / i + "px") : this.cursor.style.left = "-100000px") } destroy() { this.cursor && this.cursor.remove() } setDropPos(t) { this.view.state.field(sn) != t && this.view.dispatch({ effects: rn.of(t) }) } }, { eventObservers: { dragover(t) { this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY })) }, dragleave(t) { t.target != this.view.contentDOM && this.view.contentDOM.contains(t.relatedTarget) || this.setDropPos(null) }, dragend() { this.setDropPos(null) }, drop() { this.setDropPos(null) } } }); function on(r, s, n, o, a) { s.lastIndex = 0; for (let t = r.iterRange(n, o), e = n, i; !t.next().done; e += t.value.length)if (!t.lineBreak) for (; i = s.exec(t.value);)a(e + i.index, i) } var an = class { constructor(t) { let { regexp: e, decoration: s, decorate: n, boundary: i, maxLength: r = 1e3 } = t; if (!e.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set"); if (this.regexp = e, n) this.addMatch = (t, e, i, r) => n(r, i, i + t[0].length, t, e); else if ("function" == typeof s) this.addMatch = (t, e, i, r) => { e = s(t, e, i); e && r(i, i + t[0].length, e) }; else { if (!s) throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator"); this.addMatch = (t, e, i, r) => r(i, i + t[0].length, s) } this.boundary = i, this.maxLength = r } createDeco(i) { let t = new Xt, r = t.add.bind(t); for (var { from: e, to: s } of ((t, e) => { var i = t.visibleRanges; if (1 == i.length && i[0].from == t.viewport.from && i[0].to == t.viewport.to) return i; var r, s, n = []; for ({ from: r, to: s } of i) r = Math.max(t.state.doc.lineAt(r).from, r - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), n.length && n[n.length - 1].to >= r ? n[n.length - 1].to = s : n.push({ from: r, to: s }); return n })(i, this.maxLength)) on(i.state.doc, this.regexp, e, s, (t, e) => this.addMatch(e, i, t, r)); return t.finish() } updateDeco(s, t) { let n = 1e9, o = -1; return s.docChanged && s.changes.iterChanges((t, e, i, r) => { r > s.view.viewport.from && i < s.view.viewport.to && (n = Math.min(i, n), o = Math.max(r, o)) }), s.viewportChanged || 1e3 < o - n ? this.createDeco(s.view) : -1 < o ? this.updateRange(s.view, t.map(s.changes), n, o) : t } updateRange(a, h, t, i) { for (var l of a.visibleRanges) { let e = Math.max(l.from, t), o = Math.min(l.to, i); if (o > e) { var c = a.state.doc.lineAt(e), d = c.to < o ? a.state.doc.lineAt(o) : c; let i = Math.max(l.from, c.from), r = Math.min(l.to, d.to); if (this.boundary) { for (; e > c.from; e--)if (this.boundary.test(c.text[e - 1 - c.from])) { i = e; break } for (; o < d.to; o++)if (this.boundary.test(d.text[o - d.from])) { r = o; break } } let s = [], t, n = (t, e, i) => s.push(i.range(t, e)); if (c == d) for (this.regexp.lastIndex = i - c.from; (t = this.regexp.exec(c.text)) && t.index < r - c.from;)this.addMatch(t, a, t.index + c.from, n); else on(a.state.doc, this.regexp, i, r, (t, e) => this.addMatch(e, a, t, n)); h = h.update({ filterFrom: i, filterTo: r, filter: (t, e) => t < i || e > r, add: s }) } } return h } }, hn = null != /x/.unicode ? "gu" : "g", ln = new RegExp("[\0-\b\n--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\ufeffï¿¹-ï¿¼]", hn), cn = { 0: "null", 7: "bell", 8: "backspace", 10: "newline", 11: "vertical tab", 13: "carriage return", 27: "escape", 8203: "zero width space", 8204: "zero width non-joiner", 8205: "zero width joiner", 8206: "left-to-right mark", 8207: "right-to-left mark", 8232: "line separator", 8237: "left-to-right override", 8238: "right-to-left override", 8294: "left-to-right isolate", 8295: "right-to-left isolate", 8297: "pop directional isolate", 8233: "paragraph separator", 65279: "zero width no-break space", 65532: "object replacement" }, dn = null; var un = d.define({ combine(t) { var e, i, t = jt(t, { render: null, specialChars: ln, addSpecialChars: null }); return (t.replaceTabs = (null == dn && "undefined" != typeof document && document.body && (i = document.body.style, dn = null != (null != (e = i.tabSize) ? e : i.MozTabSize)), !dn)) && (t.specialChars = new RegExp("\t|" + t.specialChars.source, hn)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, hn)), t } }); function fn(t = {}) { return [un.of(t), pn = pn || a.fromClass(class { constructor(t) { this.view = t, this.decorations = C.none, this.decorationCache = Object.create(null), this.decorator = this.makeDecorator(t.state.facet(un)), this.decorations = this.decorator.createDeco(t) } makeDecorator(s) { return new an({ regexp: s.specialChars, decoration: (t, e, i) => { var r = e.state.doc, t = S(t[0], 0); return 9 == t ? (r = r.lineAt(i), e = e.state.tabSize, i = oe(r.text, e, i - r.from), C.replace({ widget: new gn((e - i % e) * this.view.defaultCharacterWidth / this.view.scaleX) })) : this.decorationCache[t] || (this.decorationCache[t] = C.replace({ widget: new mn(s, t) })) }, boundary: s.replaceTabs ? void 0 : /[^]/ }) } update(t) { var e = t.state.facet(un); t.startState.facet(un) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations) } }, { decorations: t => t.decorations })] } var pn = null; var mn = class extends Qe { constructor(t, e) { super(), this.options = t, this.code = e } eq(t) { return t.code == this.code } toDOM(t) { var e = 32 <= (e = this.code) ? "â€¢" : 10 == e ? "â¤" : String.fromCharCode(9216 + e), t = t.state.phrase("Control character") + " " + (cn[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, t, e); return i || ((i = document.createElement("span")).textContent = e, i.title = t, i.setAttribute("aria-label", t), i.className = "cm-specialChar", i) } ignoreEvent() { return !1 } }, gn = class extends Qe { constructor(t) { super(), this.width = t } eq(t) { return t.width == this.width } toDOM() { var t = document.createElement("span"); return t.textContent = "\t", t.className = "cm-tab", t.style.width = this.width + "px", t } ignoreEvent() { return !1 } }; var vn = C.line({ class: "cm-activeLine" }), wn = a.fromClass(class { constructor(t) { this.decorations = this.getDeco(t) } update(t) { (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view)) } getDeco(t) { let e = -1, i = []; for (var r of t.state.selection.ranges) { r = t.lineBlockAt(r.head); r.from > e && (i.push(vn.range(r.from)), e = r.from) } return C.set(i) } }, { decorations: t => t.decorations }), bn = 2e3; function yn(t, e) { var i, r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), s = t.state.doc.lineAt(r), n = r - s.from, o = bn < n ? -1 : n == s.length ? (i = t, e = e.clientX, (o = i.coordsAtPos(i.viewport.from)) ? Math.round(Math.abs((o.left - e) / i.defaultCharacterWidth)) : -1) : oe(s.text, t.state.tabSize, r - s.from); return { line: s.number, col: o, off: n } } function xn(r, t) { let s = yn(r, t), n = r.state.selection; return s ? { update(t) { var e; t.docChanged && (e = t.changes.mapPos(t.startState.doc.line(s.line).from), e = t.state.doc.lineAt(e), s = { line: e.number, col: s.col, off: Math.min(s.off, e.length) }, n = n.map(t.changes)) }, get(t, e, i) { var t = yn(r, t); return t && (t = ((e, t, i) => { var r = Math.min(t.line, i.line), s = Math.max(t.line, i.line), n = []; if (t.off > bn || i.off > bn || t.col < 0 || i.col < 0) { var o = Math.min(t.off, i.off), a = Math.max(t.off, i.off); for (let t = r; t <= s; t++) { var h = e.doc.line(t); h.length <= a && n.push(v.range(h.from + o, h.to + a)) } } else { var l = Math.min(t.col, i.col), c = Math.max(t.col, i.col); for (let t = r; t <= s; t++) { var d, u = e.doc.line(t), f = ae(u.text, l, e.tabSize, !0); f < 0 ? n.push(v.cursor(u.to)) : (d = ae(u.text, c, e.tabSize), n.push(v.range(u.from + f, u.from + d))) } } return n })(r.state, s, t)).length ? i ? v.create(t.concat(n.ranges)) : v.create(t) : n } } : null } var kn = { Alt: [18, t => !!t.altKey], Control: [17, t => !!t.ctrlKey], Shift: [16, t => !!t.shiftKey], Meta: [91, t => !!t.metaKey] }, Sn = { style: "cursor: crosshair" }; var Cn = "-10000px", An = class { constructor(t, e, i) { this.facet = e, this.createTooltipView = i, this.input = t.state.facet(e), this.tooltips = this.input.filter(t => t), this.tooltipViews = this.tooltips.map(i) } update(r, s) { var t, e = r.state.facet(this.facet), n = e.filter(t => t); if (e === this.input) { for (var i of this.tooltipViews) i.update && i.update(r); return !1 } var o, a, h = [], l = s ? [] : null; for (let t = 0; t < n.length; t++) { let e = n[t], i = -1; if (e) { for (let t = 0; t < this.tooltips.length; t++) { var c = this.tooltips[t]; c && c.create == e.create && (i = t) } i < 0 ? (h[t] = this.createTooltipView(e), l && (l[t] = !!e.above)) : (o = h[t] = this.tooltipViews[i], l && (l[t] = s[i]), o.update && o.update(r)) } } for (a of this.tooltipViews) h.indexOf(a) < 0 && (a.dom.remove(), null != (t = a.destroy)) && t.call(a); return s && (l.forEach((t, e) => s[e] = t), s.length = l.length), this.input = e, this.tooltips = n, this.tooltipViews = h, !0 } }; function On(t) { t = t.win; return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth } } var Mn = d.define({ combine: t => { var e; return { position: x.ios ? "absolute" : (null == (e = t.find(t => t.position)) ? void 0 : e.position) || "fixed", parent: (null == (e = t.find(t => t.parent)) ? void 0 : e.parent) || null, tooltipSpace: (null == (e = t.find(t => t.tooltipSpace)) ? void 0 : e.tooltipSpace) || On } } }), Tn = new WeakMap, Dn = a.fromClass(class { constructor(t) { this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1; var e = t.state.facet(Mn); this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new An(t, Rn, t => this.createTooltip(t)), this.intersectionObserver = "function" == typeof IntersectionObserver ? new IntersectionObserver(t => { Date.now() > this.lastTransaction - 50 && 0 < t.length && t[t.length - 1].intersectionRatio < 1 && this.measureSoon() }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure() } createContainer() { this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom } observeIntersection() { if (this.intersectionObserver) { this.intersectionObserver.disconnect(); for (var t of this.manager.tooltipViews) this.intersectionObserver.observe(t.dom) } } measureSoon() { this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => { this.measureTimeout = -1, this.maybeMeasure() }, 50)) } update(t) { t.transactions.length && (this.lastTransaction = Date.now()); var e = this.manager.update(t, this.above); e && this.observeIntersection(); let i = e || t.geometryChanged; e = t.state.facet(Mn); if (e.position != this.position && !this.madeAbsolute) { this.position = e.position; for (var r of this.manager.tooltipViews) r.dom.style.position = this.position; i = !0 } if (e.parent != this.parent) { this.parent && this.container.remove(), this.parent = e.parent, this.createContainer(); for (var s of this.manager.tooltipViews) this.container.appendChild(s.dom); i = !0 } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses); i && this.maybeMeasure() } createTooltip(t) { var e = t.create(this.view); return e.dom.classList.add("cm-tooltip"), t.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow") && ((t = document.createElement("div")).className = "cm-tooltip-arrow", e.dom.appendChild(t)), e.dom.style.position = this.position, e.dom.style.top = Cn, e.dom.style.left = "0px", this.container.appendChild(e.dom), e.mount && e.mount(this.view), e } destroy() { var t, e, i; this.view.win.removeEventListener("resize", this.measureSoon); for (i of this.manager.tooltipViews) i.dom.remove(), null != (t = i.destroy) && t.call(i); this.parent && this.container.remove(), null != (e = this.intersectionObserver) && e.disconnect(), clearTimeout(this.measureTimeout) } readMeasure() { var t, e = this.view.dom.getBoundingClientRect(); let i = 1, r = 1, s = !1; return "fixed" == this.position && this.manager.tooltipViews.length && (t = this.manager.tooltipViews[0].dom, x.gecko ? s = t.offsetParent != this.container.ownerDocument.body : t.style.top == Cn && "0px" == t.style.left && (t = t.getBoundingClientRect(), s = 1 < Math.abs(t.top + 1e4) || 1 < Math.abs(t.left))), !s && "absolute" != this.position || (this.parent ? (t = this.parent.getBoundingClientRect()).width && t.height && (i = t.width / this.parent.offsetWidth, r = t.height / this.parent.offsetHeight) : { scaleX: i, scaleY: r } = this.view.viewState), { editor: e, parent: this.parent ? this.container.getBoundingClientRect() : e, pos: this.manager.tooltips.map((t, e) => { e = this.manager.tooltipViews[e]; return e.getCoords ? e.getCoords(t.pos) : this.view.coordsAtPos(t.pos) }), size: this.manager.tooltipViews.map(({ dom: t }) => t.getBoundingClientRect()), space: this.view.state.facet(Mn).tooltipSpace(this.view), scaleX: i, scaleY: r, makeAbsolute: s } } writeMeasure(n) { if (n.makeAbsolute) { this.madeAbsolute = !0, this.position = "absolute"; for (var t of this.manager.tooltipViews) t.dom.style.position = "absolute" } var { editor: e, space: o, scaleX: a, scaleY: h } = n, l = []; for (let s = 0; s < this.manager.tooltips.length; s++) { var c = this.manager.tooltips[s], d = this.manager.tooltipViews[s], u = d.dom, f = n.pos[s], p = n.size[s]; if (!f || f.bottom <= Math.max(e.top, o.top) || f.top >= Math.min(e.bottom, o.bottom) || f.right < Math.max(e.left, o.left) - .1 || f.left > Math.min(e.right, o.right) + .1) u.style.top = Cn; else { var m = c.arrow ? d.dom.querySelector(".cm-tooltip-arrow") : null, g = m ? 7 : 0; let t = p.right - p.left, e = null != (v = Tn.get(d)) ? v : p.bottom - p.top; var v = d.offset || Pn, w = this.view.textDirection == O.LTR, b = p.width > o.right - o.left ? w ? o.left : o.right - p.width : w ? Math.min(f.left - (m ? 14 : 0) + v.x, o.right - t) : Math.max(o.left, f.left - t + (m ? 14 : 0) - v.x); let i = this.above[s]; c = ((i = !c.strictSide && (i ? f.top - (p.bottom - p.top) - v.y < o.top : f.bottom + (p.bottom - p.top) + v.y > o.bottom) && i == o.bottom - f.bottom > f.top - o.top ? this.above[s] = !i : i) ? f.top - o.top : o.bottom - f.bottom) - g; if (c < e && !1 !== d.resize) { if (c < this.view.defaultLineHeight) { u.style.top = Cn; continue } Tn.set(d, e), u.style.height = (e = c) / h + "px" } else u.style.height && (u.style.height = ""); let r = i ? f.top - e - g - v.y : f.bottom + g + v.y; var y = b + t; if (!0 !== d.overlap) for (var x of l) x.left < y && x.right > b && x.top < r + e && x.bottom > r && (r = i ? x.top - e - 2 - g : x.bottom + g + 2); "absolute" == this.position ? (u.style.top = (r - n.parent.top) / h + "px", u.style.left = (b - n.parent.left) / a + "px") : (u.style.top = r / h + "px", u.style.left = b / a + "px"), m && (p = f.left + (w ? v.x : -v.x) - (b + 14 - 7), m.style.left = p / a + "px"), !0 !== d.overlap && l.push({ left: b, top: r, right: y, bottom: r + e }), u.classList.toggle("cm-tooltip-above", i), u.classList.toggle("cm-tooltip-below", !i), d.positioned && d.positioned(n.space) } } } maybeMeasure() { if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView) && (this.inView = this.view.inView, !this.inView)) for (var t of this.manager.tooltipViews) t.dom.style.top = Cn } }, { eventObservers: { scroll() { this.maybeMeasure() } } }), je = T.baseTheme({ ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" }, "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" }, "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" }, "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" }, ".cm-tooltip-arrow": { height: "7px", width: "14px", position: "absolute", zIndex: -1, overflow: "hidden", "&:before, &:after": { content: "''", position: "absolute", width: 0, height: 0, borderLeft: "7px solid transparent", borderRight: "7px solid transparent" }, ".cm-tooltip-above &": { bottom: "-7px", "&:before": { borderTop: "7px solid #bbb" }, "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" } }, ".cm-tooltip-below &": { top: "-7px", "&:before": { borderBottom: "7px solid #bbb" }, "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" } } }, "&dark .cm-tooltip .cm-tooltip-arrow": { "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" }, "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" } } }), Pn = { x: 0, y: 0 }, Rn = d.define({ enables: [Dn, je] }), Bn = d.define(), En = class Rf { static create(t) { return new Rf(t) } constructor(t) { this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new An(t, Bn, t => this.createHostedView(t)) } createHostedView(t) { t = t.create(this.view); return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t } mount(t) { for (var e of this.manager.tooltipViews) e.mount && e.mount(t); this.mounted = !0 } positioned(t) { for (var e of this.manager.tooltipViews) e.positioned && e.positioned(t) } update(t) { this.manager.update(t) } destroy() { var t, e; for (e of this.manager.tooltipViews) null != (t = e.destroy) && t.call(e) } passProp(t) { let e = void 0; for (var i of this.manager.tooltipViews) { i = i[t]; if (void 0 !== i) if (void 0 === e) e = i; else if (e !== i) return } return e } get offset() { return this.passProp("offset") } get getCoords() { return this.passProp("getCoords") } get overlap() { return this.passProp("overlap") } get resize() { return this.passProp("resize") } }, Ln = Rn.compute([Bn], t => { t = t.facet(Bn).filter(t => t); return 0 === t.length ? null : { pos: Math.min(...t.map(t => t.pos)), end: Math.max(...t.map(t => { var e; return null != (e = t.end) ? e : t.pos })), create: En.create, above: t[0].above, arrow: t.some(t => t.arrow) } }), Nn = class { constructor(t, e, i, r, s) { this.view = t, this.source = e, this.field = i, this.setHover = r, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this)) } update() { this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20)) } get active() { return this.view.state.field(this.field) } checkHover() { var t; this.hoverTimeout = -1, this.active || ((t = Date.now() - this.lastMove.time) < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover()) } startHover() { clearTimeout(this.restartTimeout); let { view: r, lastMove: e } = this; var s = r.docView.nearest(e.target); if (s) { let i, t = 1; if (s instanceof Je) i = s.posAtStart; else { if (null == (i = r.posAtCoords(e))) return; s = r.coordsAtPos(i); if (!s || e.y < s.top || e.y > s.bottom || e.x < s.left - r.defaultCharacterWidth || e.x > s.right + r.defaultCharacterWidth) return; var n = r.bidiSpans(r.state.doc.lineAt(i)).find(t => t.from <= i && t.to >= i), n = n && n.dir == O.RTL ? -1 : 1; t = e.x < s.left ? -n : n } s = this.source(r, i, t); if (null != s && s.then) { let e = this.pending = { pos: i }; s.then(t => { this.pending == e && (this.pending = null, t) && r.dispatch({ effects: this.setHover.of(t) }) }, t => qi(r.state, t, "hover tooltip")) } else s && r.dispatch({ effects: this.setHover.of(s) }) } } get tooltip() { var t = this.view.plugin(Dn), e = t ? t.manager.tooltips.findIndex(t => t.create == En.create) : -1; return -1 < e ? t.manager.tooltipViews[e] : null } mousemove(t) { this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime)); var { active: e, tooltip: i } = this; (e && i && !((t, e) => (t = t.getBoundingClientRect(), e.clientX >= t.left - In && e.clientX <= t.right + In && e.clientY >= t.top - In && e.clientY <= t.bottom + In))(i.dom, t) || this.pending) && (i = (e || this.pending).pos, i == (e = null != (e = null == e ? void 0 : e.end) ? e : i) ? this.view.posAtCoords(this.lastMove) != i : !((t, e, i, r, s) => { var n = t.scrollDOM.getBoundingClientRect(), o = t.documentTop + t.documentPadding.top + t.contentHeight; return !(n.left > r || n.right < r || n.top > s || Math.min(n.bottom, o) < s) && (n = t.posAtCoords({ x: r, y: s }, !1), e <= n) && n <= i })(this.view, i, e, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null) } mouseleave(t) { clearTimeout(this.hoverTimeout), this.hoverTimeout = -1; var e = this.active; e && (e = this.tooltip, e && e.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(e.dom) : this.view.dispatch({ effects: this.setHover.of(null) })) } watchTooltipLeave(e) { let i = t => { e.removeEventListener("mouseleave", i), this.active && !this.view.dom.contains(t.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) }) }; e.addEventListener("mouseleave", i) } destroy() { clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove) } }, In = 4; function Vn(e, n = {}) { let o = c.define(), i = p.define({ create() { return null }, update(t, e) { if (t && (n.hideOnChange && (e.docChanged || e.selection) || n.hideOn && n.hideOn(e, t))) return null; if (t && e.docChanged) { var i = e.changes.mapPos(t.pos, -1, l.TrackDel); if (null == i) return null; var r = Object.assign(Object.create(null), t); r.pos = i, null != t.end && (r.end = e.changes.mapPos(t.end)), t = r } for (var s of e.effects) s.is(o) && (t = s.value), s.is(Wn) && (t = null); return t }, provide: t => Bn.from(t) }); return [i, a.define(t => new Nn(t, e, i, o, n.hoverTime || 300)), Ln] } function Hn(t, e) { t = t.plugin(Dn); return !t || (e = t.manager.tooltips.indexOf(e)) < 0 ? null : t.manager.tooltipViews[e] } var Wn = c.define(), zn = d.define({ combine(t) { let e, i; for (var r of t) e = e || r.topContainer, i = i || r.bottomContainer; return { topContainer: e, bottomContainer: i } } }); function Fn(t, e) { t = t.plugin(qn), e = t ? t.specs.indexOf(e) : -1; return -1 < e ? t.panels[e] : null } var qn = a.fromClass(class { constructor(e) { this.input = e.state.facet(Un), this.specs = this.input.filter(t => t), this.panels = this.specs.map(t => t(e)); var t, i = e.state.facet(zn); this.top = new _n(e, !0, i.topContainer), this.bottom = new _n(e, !1, i.bottomContainer), this.top.sync(this.panels.filter(t => t.top)), this.bottom.sync(this.panels.filter(t => !t.top)); for (t of this.panels) t.dom.classList.add("cm-panel"), t.mount && t.mount() } update(i) { var t = i.state.facet(zn), t = (this.top.container != t.topContainer && (this.top.sync([]), this.top = new _n(i.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new _n(i.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses(), i.state.facet(Un)); if (t != this.input) { var r, e, t = t.filter(t => t), s = [], n = [], o = [], a = []; for (r of t) { let t = this.specs.indexOf(r), e; t < 0 ? (e = r(i.view), a.push(e)) : (e = this.panels[t]).update && e.update(i), s.push(e), (e.top ? n : o).push(e) } this.specs = t, this.panels = s, this.top.sync(n), this.bottom.sync(o); for (e of a) e.dom.classList.add("cm-panel"), e.mount && e.mount() } else for (var h of this.panels) h.update && h.update(i) } destroy() { this.top.sync([]), this.bottom.sync([]) } }, { provide: e => T.scrollMargins.of(t => { t = t.plugin(e); return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() } }) }), _n = class { constructor(t, e, i) { this.view = t, this.top = e, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses() } sync(t) { for (var e of this.panels) e.destroy && t.indexOf(e) < 0 && e.destroy(); this.panels = t, this.syncDOM() } syncDOM() { if (0 == this.panels.length) this.dom && (this.dom.remove(), this.dom = void 0); else { var e, i; this.dom || (this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0", (e = this.container || this.view.dom).insertBefore(this.dom, this.top ? e.firstChild : null)); let t = this.dom.firstChild; for (i of this.panels) if (i.dom.parentNode == this.dom) { for (; t != i.dom;)t = jn(t); t = t.nextSibling } else this.dom.insertBefore(i.dom, t); for (; t;)t = jn(t) } } scrollMargin() { return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top) } syncClasses() { if (this.container && this.classes != this.view.themeClasses) { for (var t of this.classes.split(" ")) t && this.container.classList.remove(t); for (var e of (this.classes = this.view.themeClasses).split(" ")) e && this.container.classList.add(e) } } }; function jn(t) { var e = t.nextSibling; return t.remove(), e } var Un = d.define({ enables: qn }), $e = class extends Ut { compare(t) { return this == t || this.constructor == t.constructor && this.eq(t) } eq(t) { return !1 } destroy(t) { } }, Qn = ($e.prototype.elementClass = "", $e.prototype.toDOM = void 0, $e.prototype.mapMode = l.TrackBefore, $e.prototype.startSide = $e.prototype.endSide = -1, d.define()), $n = { class: "", renderEmptyElements: !($e.prototype.point = !0), elementStyle: "", markers: () => b.empty, lineMarker: () => null, widgetMarker: () => null, lineMarkerChange: null, initialSpacer: null, updateSpacer: null, domEventHandlers: {} }, Kn = d.define(); var Xn = d.define({ combine: t => t.some(t => t) }); function Gn(t) { var e = [Yn]; return t && !1 === t.fixed && e.push(Xn.of(!0)), e } var Yn = a.fromClass(class { constructor(e) { this.view = e, this.prevViewport = e.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = e.state.facet(Kn).map(t => new eo(e, t)); for (var t of this.gutters) this.dom.appendChild(t.dom); this.fixed = !e.state.facet(Xn), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), e.scrollDOM.insertBefore(this.dom, e.contentDOM) } update(t) { var e, i; this.updateGutters(t) && (i = this.prevViewport, e = t.view.viewport, i = Math.min(i.to, e.to) - Math.max(i.from, e.from), this.syncGutters(i < .8 * (e.to - e.from))), t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Xn) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport } syncGutters(t) { var e = this.dom.nextSibling, i = (t && this.dom.remove(), b.iter(this.view.state.facet(Qn), this.view.viewport.from)); let r = []; var s, n, o = this.gutters.map(t => new to(t, this.view.viewport, -this.view.documentPadding.top)); for (s of this.view.viewportLineBlocks) if (r.length && (r = []), Array.isArray(s.type)) { let t = !0; for (var a of s.type) if (a.type == A.Text && t) { Zn(i, r, a.from); for (var h of o) h.line(this.view, a, r); t = !1 } else if (a.widget) for (var l of o) l.widget(this.view, a) } else if (s.type == A.Text) { Zn(i, r, s.from); for (var c of o) c.line(this.view, s, r) } else if (s.widget) for (var d of o) d.widget(this.view, s); for (n of o) n.finish(); t && this.view.scrollDOM.insertBefore(this.dom, e) } updateGutters(t) { var e = t.startState.facet(Kn), i = t.state.facet(Kn); let r = t.docChanged || t.heightChanged || t.viewportChanged || !b.eq(t.startState.facet(Qn), t.state.facet(Qn), t.view.viewport.from, t.view.viewport.to); if (e == i) for (var s of this.gutters) s.update(t) && (r = !0); else { r = !0; var n, o, a, h = []; for (n of i) { var l = e.indexOf(n); l < 0 ? h.push(new eo(this.view, n)) : (this.gutters[l].update(t), h.push(this.gutters[l])) } for (o of this.gutters) o.dom.remove(), h.indexOf(o) < 0 && o.destroy(); for (a of h) this.dom.appendChild(a.dom); this.gutters = h } return r } destroy() { for (var t of this.gutters) t.destroy(); this.dom.remove() } }, { provide: i => T.scrollMargins.of(t => { var e = t.plugin(i); return e && 0 != e.gutters.length && e.fixed ? t.textDirection == O.LTR ? { left: e.dom.offsetWidth * t.scaleX } : { right: e.dom.offsetWidth * t.scaleX } : null }) }); function Jn(t) { return Array.isArray(t) ? t : [t] } function Zn(t, e, i) { for (; t.value && t.from <= i;)t.from == i && e.push(t.value), t.next() } var to = class { constructor(t, e, i) { this.gutter = t, this.height = i, this.i = 0, this.cursor = b.iter(t.markers, e.from) } addElement(t, e, i) { var r, s = this.gutter, n = (e.top - this.height) / t.scaleY, o = e.height / t.scaleY; this.i == s.elements.length ? (r = new io(t, o, n, i), s.elements.push(r), s.dom.appendChild(r.dom)) : s.elements[this.i].update(t, o, n, i), this.height = e.bottom, this.i++ } line(t, e, i) { let r = []; Zn(this.cursor, r, e.from), i.length && (r = r.concat(i)); i = this.gutter.config.lineMarker(t, e, r), i && r.unshift(i), i = this.gutter; 0 == r.length && !i.config.renderEmptyElements || this.addElement(t, e, r) } widget(t, e) { var i = this.gutter.config.widgetMarker(t, e.widget, e); i && this.addElement(t, e, [i]) } finish() { for (var t = this.gutter; t.elements.length > this.i;) { var e = t.elements.pop(); t.dom.removeChild(e.dom), e.destroy() } } }, eo = class { constructor(n, o) { this.view = n, this.config = o, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""); for (let s in o.domEventHandlers) this.dom.addEventListener(s, t => { let e = t.target, i; if (e != this.dom && this.dom.contains(e)) { for (; e.parentNode != this.dom;)e = e.parentNode; var r = e.getBoundingClientRect(); i = (r.top + r.bottom) / 2 } else i = t.clientY; r = n.lineBlockAtHeight(i - n.documentTop); o.domEventHandlers[s](n, r, t) && t.preventDefault() }); this.markers = Jn(o.markers(n)), o.initialSpacer && (this.spacer = new io(n, 0, 0, [o.initialSpacer(n)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none") } update(t) { var e = this.markers, i = (this.markers = Jn(this.config.markers(t.view)), this.spacer && this.config.updateSpacer && (i = this.config.updateSpacer(this.spacer.markers[0], t)) != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [i]), t.view.viewport); return !b.eq(this.markers, e, i.from, i.to) || !!this.config.lineMarkerChange && this.config.lineMarkerChange(t) } destroy() { for (var t of this.elements) t.destroy() } }, io = class { constructor(t, e, i, r) { this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, e, i, r) } update(t, e, i, r) { this.height != e && (this.height = e, this.dom.style.height = e + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), ((e, i) => { if (e.length == i.length) { for (let t = 0; t < e.length; t++)if (!e[t].compare(i[t])) return; return 1 } })(this.markers, r) || this.setMarkers(t, r) } setMarkers(n, o) { let a = "cm-gutterElement", h = this.dom.firstChild; for (let t = 0, s = 0; ;) { let e = s, i = t < o.length ? o[t++] : null, r = !1; if (i) { var l = i.elementClass; l && (a += " " + l); for (let t = s; t < this.markers.length; t++)if (this.markers[t].compare(i)) { e = t, r = !0; break } } else e = this.markers.length; for (; s < e;) { var c = this.markers[s++]; c.toDOM && (c.destroy(h), c = h.nextSibling, h.remove(), h = c) } if (!i) break; i.toDOM && (r ? h = h.nextSibling : this.dom.insertBefore(i.toDOM(n), h)), r && s++ } this.dom.className = a, this.markers = o } destroy() { this.setMarkers(null, []) } }; var ro = d.define(), so = d.define({ combine(t) { return jt(t, { formatNumber: String, domEventHandlers: {} }, { domEventHandlers(t, e) { var i, n = Object.assign({}, t); for (i in e) { let r = n[i], s = e[i]; n[i] = r ? (t, e, i) => r(t, e, i) || s(t, e, i) : s } return n } }) } }), no = class extends $e { constructor(t) { super(), this.number = t } eq(t) { return this.number == t.number } toDOM() { return document.createTextNode(this.number) } }; function oo(t, e) { return t.state.facet(so).formatNumber(e, t.state) } var ao = Kn.compute([so], t => ({ class: "cm-lineNumbers", renderEmptyElements: !1, markers(t) { return t.state.facet(ro) }, lineMarker(t, e, i) { return i.some(t => t.toDOM) ? null : new no(oo(t, t.state.doc.lineAt(e.from).number)) }, widgetMarker: () => null, lineMarkerChange: t => t.startState.facet(so) != t.state.facet(so), initialSpacer(t) { return new no(oo(t, ho(t.state.doc.lines))) }, updateSpacer(t, e) { e = oo(e.view, ho(e.view.state.doc.lines)); return e == t.number ? t : new no(e) }, domEventHandlers: t.facet(so).domEventHandlers })); function ho(t) { let e = 9; for (; e < t;)e = 10 * e + 9; return e } var lo = new class extends $e { constructor() { super(...arguments), this.elementClass = "cm-activeLineGutter" } }, co = Qn.compute(["selection"], t => { let e = [], i = -1; for (var r of t.selection.ranges) { r = t.doc.lineAt(r.head).from; r > i && (i = r, e.push(lo.range(r))) } return b.of(e) }); var D, uo = 0, fo = class { constructor(t, e) { this.from = t, this.to = e } }, _ = class { constructor(t = {}) { this.id = uo++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => { throw new Error("This node type doesn't define a deserialize function") }) } add(e) { if (this.perNode) throw new RangeError("Can't add per-node props to node types"); return "function" != typeof e && (e = go.match(e)), t => { t = e(t); return void 0 === t ? null : [this, t] } } }, po = (_.closedBy = new _({ deserialize: t => t.split(" ") }), _.openedBy = new _({ deserialize: t => t.split(" ") }), _.group = new _({ deserialize: t => t.split(" ") }), _.isolate = new _({ deserialize: t => { if (t && "rtl" != t && "ltr" != t && "auto" != t) throw new RangeError("Invalid value for isolate: " + t); return t || "auto" } }), _.contextHash = new _({ perNode: !0 }), _.lookAhead = new _({ perNode: !0 }), _.mounted = new _({ perNode: !0 }), class { constructor(t, e, i) { this.tree = t, this.overlay = e, this.parser = i } static get(t) { return t && t.props && t.props[_.mounted.id] } }), mo = Object.create(null), go = class Bf { constructor(t, e, i, r = 0) { this.name = t, this.props = e, this.id = i, this.flags = r } static define(t) { var e = t.props && t.props.length ? Object.create(null) : mo, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (null == t.name ? 8 : 0), r = new Bf(t.name || "", e, t.id, i); if (t.props) for (var s of t.props) if (s = Array.isArray(s) ? s : s(r)) { if (s[0].perNode) throw new RangeError("Can't store a per-node prop on a node type"); e[s[0].id] = s[1] } return r } prop(t) { return this.props[t.id] } get isTop() { return 0 < (1 & this.flags) } get isSkipped() { return 0 < (2 & this.flags) } get isError() { return 0 < (4 & this.flags) } get isAnonymous() { return 0 < (8 & this.flags) } is(t) { var e; return "string" == typeof t ? this.name == t || !!(e = this.prop(_.group)) && -1 < e.indexOf(t) : this.id == t } static match(t) { let s = Object.create(null); for (var e in t) for (var i of e.split(" ")) s[i] = t[e]; return i => { for (let t = i.prop(_.group), e = -1; e < (t ? t.length : 0); e++) { var r = s[e < 0 ? i.name : t[e]]; if (r) return r } } } }, vo = (go.none = new go("", Object.create(null), 0, 8), class Ef { constructor(e) { this.types = e; for (let t = 0; t < e.length; t++)if (e[t].id != t) throw new RangeError("Node type ids should correspond to array positions when creating a node set") } extend(...e) { var i, r = []; for (i of this.types) { let t = null; for (var s of e) { s = s(i); s && ((t = t || Object.assign({}, i.props))[s[0].id] = s[1]) } r.push(t ? new go(i.name, t, i.id, i.flags) : i) } return new Ef(r) } }), wo = new WeakMap, bo = new WeakMap, j = ((r = D = D || {})[r.ExcludeBuffers = 1] = "ExcludeBuffers", r[r.IncludeAnonymous = 2] = "IncludeAnonymous", r[r.IgnoreMounts = 4] = "IgnoreMounts", r[r.IgnoreOverlays = 8] = "IgnoreOverlays", class Lf { constructor(t, e, i, r, s) { if (this.type = t, this.children = e, this.positions = i, this.length = r, this.props = null, s && s.length) { this.props = Object.create(null); for (var [n, o] of s) this.props["number" == typeof n ? n : n.id] = o } } toString() { var t, e = po.get(this); if (e && !e.overlay) return e.tree.toString(); let i = ""; for (t of this.children) { var r = t.toString(); r && (i && (i += ","), i += r) } return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (i.length ? "(" + i + ")" : "") : i } cursor(t = 0) { return new Ro(this.topNode, t) } cursorAt(t, e = 0, i) { var r = wo.get(this) || this.topNode, r = new Ro(r); return r.moveTo(t, e), wo.set(this, r._tree), r } get topNode() { return new Co(this, 0, 0, null) } resolve(t, e = 0) { t = So(wo.get(this) || this.topNode, t, e, !1); return wo.set(this, t), t } resolveInner(t, e = 0) { t = So(bo.get(this) || this.topNode, t, e, !0); return bo.set(this, t), t } resolveStack(t, r = 0) { { var s, n = t, o = r, a, h; let e = this.resolveInner(n, o), i = null; for (let t = e instanceof Co ? e : e.context.parent; t; t = t.parent)t.index < 0 ? (a = t.parent, (i = i || [e]).push(a.resolve(n, o)), t = a) : (a = po.get(t.tree)) && a.overlay && a.overlay[0].from <= n && a.overlay[a.overlay.length - 1].to >= n && (h = new Co(a.tree, a.overlay[0].from + t.from, -1, t), (i = i || [e]).push(So(h, n, o, !1))); return i ? Do(i) : e } } iterate(t) { for (var { enter: e, leave: i, from: r = 0, to: s = this.length } = t, t = t.mode || 0, n = 0 < (t & D.IncludeAnonymous), o = this.cursor(t | D.IncludeAnonymous); ;) { let t = !1; if (o.from <= s && o.to >= r && (!n && o.type.isAnonymous || !1 !== e(o))) { if (o.firstChild()) continue; t = !0 } for (; t && i && (n || !o.type.isAnonymous) && i(o), !o.nextSibling();) { if (!o.parent()) return; t = !0 } } } prop(t) { return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t) } get propValues() { var t = []; if (this.props) for (var e in this.props) t.push([+e, this.props[e]]); return t } balance(t = {}) { return this.children.length <= 8 ? this : No(go.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, e, i) => new Lf(this.type, t, e, i, this.propValues), t.makeTree || ((t, e, i) => new Lf(go.none, t, e, i))) } static build(i) { { var r = i; let t, { buffer: e, nodeSet: B, maxBufferLength: E = 1024, reused: L = [], minRepeatType: N = B.types.length } = r, I = Array.isArray(e) ? new yo(e, e.length) : e, V = B.types, H = 0, W = 0; function z(i, r, t, e, s, n) { for (var o, a, { id: h, start: l, end: c, size: d } = I, u = W; d < 0;) { if (I.next(), -1 == d) return o = L[h], t.push(o), void e.push(l - i); if (-3 == d) return void (H = h); if (-4 == d) return void (W = h); throw new RangeError("Unrecognized record size: " + d) } let f = V[h], p, m, g = l - i; if (c - l <= E && (m = ((t, e) => { let i = I.fork(), r = 0, s = 0, n = 0, o = i.end - E, a = { size: 0, start: 0, skip: 0 }; t: for (var h = i.pos - t; i.pos > h;) { var l = i.size; if (i.id == e && 0 <= l) a.size = r, a.start = s, a.skip = n, n += 4, r += 4, i.next(); else { var c = i.pos - l; if (l < 0 || c < h || i.start < o) break; let t = i.id >= N ? 4 : 0; var d = i.start; for (i.next(); i.pos > c;) { if (i.size < 0) { if (-3 != i.size) break t; t += 4 } else i.id >= N && (t += 4); i.next() } s = d, r += l, n += t } } return (e < 0 || r == t) && (a.size = r, a.start = s, a.skip = n), 4 < a.size ? a : void 0 })(I.pos - r, s))) { var v = new Uint16Array(m.size - m.skip); let t = I.pos - m.size, e = v.length; for (; I.pos > t;)e = function e(i, r, s) { let { id: n, start: o, end: a, size: h } = I; I.next(); if (0 <= h && n < N) { let t = s; if (4 < h) { let t = I.pos - (h - 4); for (; I.pos > t;)s = e(i, r, s) } r[--s] = t, r[--s] = a - i, r[--s] = o - i, r[--s] = n } else -3 == h ? H = n : -4 == h && (W = n); return s }(m.start, v, e); p = new xo(v, c - m.start, B), g = m.start - i } else { var w = I.pos - d, b = (I.next(), []), y = [], x = h >= N ? h : -1; let t = 0, e = c; for (; I.pos > w;)if (0 <= x && I.id == x && 0 <= I.size) I.end <= e - E && (F(b, y, l, t, I.end, e, x, u), t = b.length, e = I.end), I.next(); else if (2500 < n) { k = void 0; S = void 0; C = void 0; A = void 0; O = void 0; M = void 0; T = void 0; D = void 0; P = void 0; R = void 0; var k = l; var S = w; var C = b; var A = y; let i = [], t = 0, e = -1; for (; I.pos > S;) { var { id: O, start: M, end: T, size: D } = I; if (!(4 < D)) { if (-1 < e && M < e) break; e < 0 && (e = T - E), i.push(O, M, T), t++ } I.next() } if (t) { var P = new Uint16Array(4 * t), R = i[i.length - 2]; for (let t = i.length - 3, e = 0; 0 <= t; t -= 3)P[e++] = i[t], P[e++] = i[t + 1] - R, P[e++] = i[t + 2] - R, P[e++] = e; C.push(new xo(P, i[2] - R, B)), A.push(R - k) } } else z(l, w, b, y, x, n + 1); 0 <= x && 0 < t && t < b.length && F(b, y, l, t, l, e, x, u), b.reverse(), y.reverse(), p = -1 < x && 0 < t ? No(a = f, b, y, 0, b.length, 0, c - l, r = (t, e, i) => { let r = 0, s = t.length - 1, n, o; if (0 <= s && (n = t[s]) instanceof j) { if (!s && n.type == a && n.length == i) return n; (o = n.prop(_.lookAhead)) && (r = e[s] + n.length + o) } return q(a, t, e, i, r) }, r) : q(f, b, y, c - l, u - c) } t.push(p), e.push(g) } function F(t, e, i, r, s, n, o, a) { for (var h = [], l = []; t.length > r;)h.push(t.pop()), l.push(e.pop() + i - s); t.push(q(B.types[o], h, l, n - s, a - n)), e.push(s - i) } function q(t, e, i, r, s = 0, n) { var o; return H && (o = [_.contextHash, H], n = n ? [o].concat(n) : [o]), 25 < s && (o = [_.lookAhead, s], n = n ? [o].concat(n) : [o]), new j(t, e, i, r, n) } for (var s = [], n = []; 0 < I.pos;)z(r.start || 0, r.bufferStart || 0, s, n, -1, 0); return i = null != (t = r.length) ? t : s.length ? n[0] + s[0].length : 0, new j(V[r.topID], s.reverse(), n.reverse(), i) } } }), yo = (j.empty = new j(go.none, [], [], 0), class Nf { constructor(t, e) { this.buffer = t, this.index = e } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } get pos() { return this.index } next() { this.index -= 4 } fork() { return new Nf(this.buffer, this.index) } }), xo = class If { constructor(t, e, i) { this.buffer = t, this.length = e, this.set = i } get type() { return go.none } toString() { var e = []; for (let t = 0; t < this.buffer.length;)e.push(this.childString(t)), t = this.buffer[t + 3]; return e.join(",") } childString(t) { var e = this.buffer[t], i = this.buffer[t + 3]; let r = this.set.types[e], s = r.name; if (/\W/.test(s) && !r.isError && (s = JSON.stringify(s)), i == (t += 4)) return s; for (var n = []; t < i;)n.push(this.childString(t)), t = this.buffer[t + 3]; return s + "(" + n.join(",") + ")" } findChild(e, i, r, s, n) { let o = this.buffer, a = -1; for (let t = e; t != i && !(ko(n, s, o[t + 1], o[t + 2]) && (a = t, 0 < r)); t = o[t + 3]); return a } slice(i, r, s) { var n = this.buffer; let o = new Uint16Array(r - i), a = 0; for (let t = i, e = 0; t < r;) { o[e++] = n[t++], o[e++] = n[t++] - s; var h = o[e++] = n[t++] - s; o[e++] = n[t++] - i, a = Math.max(a, h) } return new If(o, a, this.set) } }; function ko(t, e, i, r) { switch (t) { case -2: return i < e; case -1: return e <= r && i < e; case 0: return i < e && e < r; case 1: return i <= e && e < r; case 2: return e < r; case 4: return 1 } } function So(i, r, s, t) { for (var n; i.from == i.to || (s < 1 ? i.from >= r : i.from > r) || (-1 < s ? i.to <= r : i.to < r);) { var e = !t && i instanceof Co && i.index < 0 ? null : i.parent; if (!e) return i; i = e } var o = t ? 0 : D.IgnoreOverlays; if (t) for (let t = i, e = t.parent; e; e = (t = e).parent)t instanceof Co && t.index < 0 && (null == (n = e.enter(r, s, o)) ? void 0 : n.from) != t.from && (i = e); for (; ;) { var a = i.enter(r, s, o); if (!a) return i; i = a } } var s = class { cursor(t = 0) { return new Ro(this, t) } getChild(t, e = null, i = null) { t = Ao(this, t, e, i); return t.length ? t[0] : null } getChildren(t, e = null, i = null) { return Ao(this, t, e, i) } resolve(t, e = 0) { return So(this, t, e, !1) } resolveInner(t, e = 0) { return So(this, t, e, !0) } matchContext(t) { return Oo(this, t) } enterUnfinishedNodesBefore(t) { let e = this.childBefore(t), i = this; for (; e;) { var r = e.lastChild; if (!r || r.to != e.to) break; e = r.type.isError && r.from == r.to ? (i = e, r.prevSibling) : r } return i } get node() { return this } get next() { return this.parent } }, Co = class Vf extends s { constructor(t, e, i, r) { super(), this._tree = t, this.from = e, this.index = i, this._parent = r } get type() { return this._tree.type } get name() { return this._tree.type.name } get to() { return this.from + this._tree.length } nextChild(i, r, s, n, o = 0) { for (let e = this; ;) { for (var { children: t, positions: a } = e._tree, h = 0 < r ? t.length : -1; i != h; i += r) { var l = t[i], c = a[i] + e.from; if (ko(n, s, c, c + l.length)) if (l instanceof xo) { if (!(o & D.ExcludeBuffers)) { var d = l.findChild(0, l.buffer.length, r, s - c, n); if (-1 < d) return new To(new Mo(e, l, i, c), null, d) } } else if (o & D.IncludeAnonymous || !l.type.isAnonymous || Bo(l)) { let t; return o & D.IgnoreMounts || !(t = po.get(l)) || t.overlay ? (d = new Vf(l, c, i, e), o & D.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(r < 0 ? l.children.length - 1 : 0, r, s, n)) : new Vf(t.tree, c, i, e) } } if (o & D.IncludeAnonymous || !e.type.isAnonymous) return null; if (i = 0 <= e.index ? e.index + r : r < 0 ? -1 : e._parent._tree.children.length, !(e = e._parent)) return null } } get firstChild() { return this.nextChild(0, 1, 0, 4) } get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4) } childAfter(t) { return this.nextChild(0, 1, t, 2) } childBefore(t) { return this.nextChild(this._tree.children.length - 1, -1, t, -2) } enter(t, e, i = 0) { let r; if (!(i & D.IgnoreOverlays) && (r = po.get(this._tree)) && r.overlay) { var s, n, o = t - this.from; for ({ from: s, to: n } of r.overlay) if ((0 < e ? s <= o : s < o) && (e < 0 ? n >= o : n > o)) return new Vf(r.tree, r.overlay[0].from + this.from, -1, this) } return this.nextChild(0, 1, t, e, i) } nextSignificantParent() { let t = this; for (; t.type.isAnonymous && t._parent;)t = t._parent; return t } get parent() { return this._parent ? this._parent.nextSignificantParent() : null } get nextSibling() { return this._parent && 0 <= this.index ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null } get prevSibling() { return this._parent && 0 <= this.index ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null } get tree() { return this._tree } toTree() { return this._tree } toString() { return this._tree.toString() } }; function Ao(t, e, i, r) { var s = t.cursor(), n = []; if (!s.firstChild()) return n; if (null != i) for (; !s.type.is(i);)if (!s.nextSibling()) return n; for (; ;) { if (null != r && s.type.is(r)) return n; if (s.type.is(e) && n.push(s.node), !s.nextSibling()) return null == r ? n : [] } } function Oo(e, i, r = i.length - 1) { for (let t = e.parent; 0 <= r; t = t.parent) { if (!t) return !1; if (!t.type.isAnonymous) { if (i[r] && i[r] != t.name) return !1; r-- } } return !0 } var Mo = class { constructor(t, e, i, r) { this.parent = t, this.buffer = e, this.index = i, this.start = r } }, To = class Hf extends s { get name() { return this.type.name } get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] } get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] } constructor(t, e, i) { super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]] } child(t, e, i) { var r = this.context.buffer, r = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.context.start, i); return r < 0 ? null : new Hf(this.context, this, r) } get firstChild() { return this.child(1, 0, 4) } get lastChild() { return this.child(-1, 0, 4) } childAfter(t) { return this.child(1, t, 2) } childBefore(t) { return this.child(-1, t, -2) } enter(t, e, i = 0) { return i & D.ExcludeBuffers || (i = this.context.buffer, (i = i.findChild(this.index + 4, i.buffer[this.index + 3], 0 < e ? 1 : -1, t - this.context.start, e)) < 0) ? null : new Hf(this.context, this, i) } get parent() { return this._parent || this.context.parent.nextSignificantParent() } externalSibling(t) { return this._parent ? null : this.context.parent.nextChild(this.context.index + t, t, 0, 4) } get nextSibling() { var t = this.context.buffer, e = t.buffer[this.index + 3]; return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Hf(this.context, this._parent, e) : this.externalSibling(1) } get prevSibling() { var t = this.context.buffer, e = this._parent ? this._parent.index + 4 : 0; return this.index == e ? this.externalSibling(-1) : new Hf(this.context, this._parent, t.findChild(e, this.index, -1, 0, 4)) } get tree() { return null } toTree() { var t, e = [], i = [], r = this.context.buffer, s = this.index + 4, n = r.buffer[this.index + 3]; return s < n && (t = r.buffer[this.index + 1], e.push(r.slice(s, n, t)), i.push(0)), new j(this.type, e, i, this.to - this.from) } toString() { return this.context.buffer.childString(this.index) } }; function Do(e) { if (!e.length) return null; let i = 0, r = e[0]; for (let t = 1; t < e.length; t++) { var s = e[t]; (s.from > r.from || s.to < r.to) && (r = s, i = t) } var t = r instanceof Co && r.index < 0 ? null : r.parent, n = e.slice(); return t ? n[i] = t : n.splice(i, 1), new Po(n, r) } var Po = class { constructor(t, e) { this.heads = t, this.node = e } get next() { return Do(this.heads) } }; var Ro = class { get name() { return this.type.name } constructor(e, t = 0) { if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Co) this.yieldNode(e); else { this._tree = e.context.parent, this.buffer = e.context; for (let t = e._parent; t; t = t._parent)this.stack.unshift(t.index); this.bufferNode = e, this.yieldBuf(e.index) } } yieldNode(t) { return !!t && (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) } yieldBuf(t, e) { this.index = t; var { start: i, buffer: r } = this.buffer; return this.type = e || r.set.types[r.buffer[t]], this.from = i + r.buffer[t + 1], this.to = i + r.buffer[t + 2], !0 } yield(t) { return !!t && (t instanceof Co ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type))) } toString() { return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString() } enterChild(t, e, i) { var r; return this.buffer ? (r = this.buffer.buffer, !((r = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.buffer.start, i)) < 0) && (this.stack.push(this.index), this.yieldBuf(r))) : this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode)) } firstChild() { return this.enterChild(1, 0, 4) } lastChild() { return this.enterChild(-1, 0, 4) } childAfter(t) { return this.enterChild(1, t, 2) } childBefore(t) { return this.enterChild(-1, t, -2) } enter(t, e, i = this.mode) { return this.buffer ? !(i & D.ExcludeBuffers) && this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i)) } parent() { var t; return this.buffer ? this.stack.length ? this.yieldBuf(this.stack.pop()) : (t = this.mode & D.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent(), this.buffer = null, this.yieldNode(t)) : this.yieldNode(this.mode & D.IncludeAnonymous ? this._tree._parent : this._tree.parent) } sibling(t) { if (!this.buffer) return !!this._tree._parent && this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)); var e = this.buffer.buffer, i = this.stack.length - 1; if (t < 0) { var r = i < 0 ? 0 : this.stack[i] + 4; if (this.index != r) return this.yieldBuf(e.findChild(r, this.index, -1, 0, 4)) } else { r = e.buffer[this.index + 3]; if (r < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3])) return this.yieldBuf(r) } return i < 0 && this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) } nextSibling() { return this.sibling(1) } prevSibling() { return this.sibling(-1) } atLastNode(i) { let r, s, e = this.buffer; if (e) { if (0 < i) { if (this.index < e.buffer.buffer.length) return !1 } else for (let t = 0; t < this.index; t++)if (e.buffer.buffer[t + 3] < this.index) return !1; ({ index: r, parent: s } = e) } else ({ index: r, _parent: s } = this._tree); for (; s; { index: r, _parent: s } = s)if (-1 < r) for (let t = r + i, e = i < 0 ? -1 : s._tree.children.length; t != e; t += i) { var n = s._tree.children[t]; if (this.mode & D.IncludeAnonymous || n instanceof xo || !n.type.isAnonymous || Bo(n)) return !1 } return !0 } move(t, e) { if (e && this.enterChild(t, 0, 4)) return !0; for (; ;) { if (this.sibling(t)) return !0; if (this.atLastNode(t) || !this.parent()) return !1 } } next(t = !0) { return this.move(1, t) } prev(t = !0) { return this.move(-1, t) } moveTo(t, e = 0) { for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (-1 < e ? this.to <= t : this.to < t)) && this.parent();); for (; this.enterChild(1, t, e);); return this } get node() { if (!this.buffer) return this._tree; let r = this.bufferNode, s = null, n = 0; if (r && r.context == this.buffer) t: for (let e = this.index, i = this.stack.length; 0 <= i;) { for (let t = r; t; t = t._parent)if (t.index == e) { if (e == this.index) return t; s = t, n = i + 1; break t } e = this.stack[--i] } for (let t = n; t < this.stack.length; t++)s = new To(this.buffer, s, this.stack[t]); return this.bufferNode = new To(this.buffer, s, this.index) } get tree() { return this.buffer ? null : this._tree._tree } iterate(i, r) { for (let e = 0; ;) { let t = !1; if (this.type.isAnonymous || !1 !== i(this)) { if (this.firstChild()) { e++; continue } this.type.isAnonymous || (t = !0) } for (; t && r && r(this), t = this.type.isAnonymous, !this.nextSibling();) { if (!e) return; this.parent(), e--, t = !0 } } } matchContext(i) { if (!this.buffer) return Oo(this.node, i); var r = this.buffer.buffer, s = r.set.types; for (let t = i.length - 1, e = this.stack.length - 1; 0 <= t; e--) { if (e < 0) return Oo(this.node, i, t); var n = s[r.buffer[this.stack[e]]]; if (!n.isAnonymous) { if (i[t] && i[t] != n.name) return !1; t-- } } return !0 } }; function Bo(t) { return t.children.some(t => t instanceof xo || !t.type.isAnonymous || Bo(t)) } var Eo = new WeakMap; function Lo(t, e) { if (!t.isAnonymous || e instanceof xo || e.type != t) return 1; let i = Eo.get(e); if (null == i) { i = 1; for (var r of e.children) { if (r.type != t || !(r instanceof j)) { i = 1; break } i += Lo(t, r) } Eo.set(e, i) } return i } function No(d, e, t, i, r, u, s, n, f) { let o = 0; for (let t = i; t < r; t++)o += Lo(d, e[t]); let p = Math.ceil(1.5 * o / 8), m = [], g = []; return function s(n, o, t, a, h) { for (let r = t; r < a;) { let t = r, e = o[r], i = Lo(d, n[r]); for (r++; r < a; r++) { var l = Lo(d, n[r]); if (i + l >= p) break; i += l } if (r == t + 1) { if (i > p) { var c = n[t]; s(c.children, c.positions, 0, c.children.length, o[t] + h); continue } m.push(n[t]) } else c = o[r - 1] + n[r - 1].length - e, m.push(No(d, n, o, t, r, e, c, null, f)); g.push(e + h - u) } }(e, t, i, r, 0), (n || f)(m, g, s) } var Io = class Wf { constructor(t, e, i, r, s = !1, n = !1) { this.from = t, this.to = e, this.tree = i, this.offset = r, this.open = (s ? 1 : 0) | (n ? 2 : 0) } get openStart() { return 0 < (1 & this.open) } get openEnd() { return 0 < (2 & this.open) } static addTree(t, e = [], i = !1) { var r, s = [new Wf(0, t.length, t, 0, !1, i)]; for (r of e) r.to > t.length && s.push(r); return s } static applyChanges(s, t, n = 128) { if (!t.length) return s; var o = []; let a = 1, h = s.length ? s[0] : null; for (let e = 0, i = 0, r = 0; ; e++) { var l, c, d = e < t.length ? t[e] : null, u = d ? d.fromA : 1e9; if (u - i >= n) for (; h && h.from < u;) { let t = h; if ((i >= t.from || u <= t.to || r) && (l = Math.max(t.from, i) - r, c = Math.min(t.to, u) - r, t = c <= l ? null : new Wf(l, c, t.tree, t.offset + r, 0 < e, !!d)), t && o.push(t), h.to > u) break; h = a < s.length ? s[a++] : null } if (!d) break; i = d.toA, r = d.toA - d.toB } return o } }, Vo = class { startParse(t, e, i) { return "string" == typeof t && (t = new Ho(t)), i = i ? i.length ? i.map(t => new fo(t.from, t.to)) : [new fo(0, 0)] : [new fo(0, t.length)], this.createParse(t, e || [], i) } parse(t, e, i) { for (var r = this.startParse(t, e, i); ;) { var s = r.advance(); if (s) return s } } }, Ho = class { constructor(t) { this.string = t } get length() { return this.string.length } chunk(t) { return this.string.slice(t) } get lineChunks() { return !1 } read(t, e) { return this.string.slice(t, e) } }, Wo = (new _({ perNode: !0 }), 0), zo = class zf { constructor(t, e, i) { this.set = t, this.base = e, this.modified = i, this.id = Wo++ } static define(t) { if (null != t && t.base) throw new Error("Can not derive from a modified tag"); var e = new zf([], null, []); if (e.set.push(e), t) for (var i of t.set) e.set.push(i); return e } static defineModifier() { let e = new qo; return t => -1 < t.modified.indexOf(e) ? t : qo.get(t.base || t, t.modified.concat(e).sort((t, e) => t.id - e.id)) } }, Fo = 0, qo = class Ff { constructor() { this.instances = [], this.id = Fo++ } static get(r, s) { if (!s.length) return r; var t = s[0].instances.find(t => { return t.base == r && (e = s, i = t.modified, e.length == i.length) && e.every((t, e) => t == i[e]); var e, i }); if (t) return t; var e, i = [], n = new zo(i, r, s); for (e of s) e.instances.push(n); var o, a = (r => { var s = [[]]; for (let i = 0; i < r.length; i++)for (let t = 0, e = s.length; t < e; t++)s.push(s[t].concat(r[i])); return s.sort((t, e) => e.length - t.length) })(s); for (o of r.set) if (!o.modified.length) for (var h of a) i.push(Ff.get(o, h)); return n } }; function _o(e) { var i, s = Object.create(null); for (i in e) { let t = e[i]; Array.isArray(t) || (t = [t]); for (var n of i.split(" ")) if (n) { let e = [], i = 2, r = n; for (let t = 0; ;) { if ("..." == r && 0 < t && t + 3 == n.length) { i = 1; break } var o = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(r); if (!o) throw new RangeError("Invalid path: " + n); if (e.push("*" == o[0] ? "" : '"' == o[0][0] ? JSON.parse(o[0]) : o[0]), (t += o[0].length) == n.length) break; o = n[t++]; if (t == n.length && "!" == o) { i = 0; break } if ("/" != o) throw new RangeError("Invalid path: " + n); r = n.slice(t) } var a = e.length - 1, h = e[a]; if (!h) throw new RangeError("Invalid path: " + n); a = new Uo(t, i, 0 < a ? e.slice(0, a) : null); s[h] = a.sort(s[h]) } } return jo.add(s) } var jo = new _, Uo = class { constructor(t, e, i, r) { this.tags = t, this.mode = e, this.context = i, this.next = r } get opaque() { return 0 == this.mode } get inherit() { return 1 == this.mode } sort(t) { return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t) } get depth() { return this.context ? this.context.length : 0 } }; function Qo(t, e) { let s = Object.create(null); for (var i of t) if (Array.isArray(i.tag)) for (var r of i.tag) s[r.id] = i.class; else s[i.tag.id] = i.class; let { scope: n, all: o = null } = e || {}; return { style: t => { let e = o; for (var i of t) for (var r of i.set) { r = s[r.id]; if (r) { e = e ? e + " " + r : r; break } } return e }, scope: n } } function $o(t, e, i, r = 0, s = t.length) { e = new Ko(r, Array.isArray(e) ? e : [e], i); e.highlightRange(t.cursor(), r, s, "", e.highlighters), e.flush(s) } Uo.empty = new Uo([], 2, null); var Ko = class { constructor(t, e, i) { this.at = t, this.highlighters = e, this.span = i, this.class = "" } startSpan(t, e) { e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e) } flush(t) { t > this.at && this.class && this.span(this.at, t, this.class) } highlightRange(s, n, o, a, h) { let { type: e, from: l, to: c } = s; if (!(o <= l || c <= n)) { e.isTop && (h = this.highlighters.filter(t => !t.scope || t.scope(e))); let r = a; var t = (t => { let e = t.type.prop(jo); for (; e && e.context && !t.matchContext(e.context);)e = e.next; return e || null })(s) || Uo.empty, i = ((t, e) => { let i = null; for (var r of t) { r = r.style(e); r && (i = i ? i + " " + r : r) } return i })(h, t.tags); if (i && (r && (r += " "), r += i, 1 == t.mode) && (a += (a ? " " : "") + i), this.startSpan(Math.max(n, l), r), !t.opaque) { let i = s.tree && s.tree.prop(_.mounted); if (i && i.overlay) { var d = s.node.enter(i.overlay[0].from + l, 1), u = this.highlighters.filter(t => !t.scope || t.scope(i.tree.type)), f = s.firstChild(); for (let t = 0, e = l; ; t++) { var p = t < i.overlay.length ? i.overlay[t] : null, m = p ? p.from + l : c, g = Math.max(n, e), v = Math.min(o, m); if (g < v && f) for (; s.from < v && (this.highlightRange(s, g, v, a, h), this.startSpan(Math.min(v, s.to), r), !(s.to >= m)) && s.nextSibling();); if (!p || o < m) break; (e = p.to + l) > n && (this.highlightRange(d.cursor(), Math.max(n, p.from + l), Math.min(o, e), "", u), this.startSpan(Math.min(o, e), r)) } f && s.parent() } else if (s.firstChild()) { i && (a = ""); do { if (!(s.to <= n)) { if (o <= s.from) break; this.highlightRange(s, n, o, a, h), this.startSpan(Math.min(o, s.to), r) } } while (s.nextSibling()); s.parent() } } } } }; var e = zo.define, Xe = e(), Ke = e(), _e = e(Ke), Ue = e(Ke), i = e(), je = e(i), r = e(i), s = e(), Xo = e(s), Go = e(), n = e(), Yo = e(), Jo = e(Yo), Zo = e(), h = { comment: Xe, lineComment: e(Xe), blockComment: e(Xe), docComment: e(Xe), name: Ke, variableName: e(Ke), typeName: _e, tagName: e(_e), propertyName: Ue, attributeName: e(Ue), className: e(Ke), labelName: e(Ke), namespace: e(Ke), macroName: e(Ke), literal: i, string: je, docString: e(je), character: e(je), attributeValue: e(je), number: r, integer: e(r), float: e(r), bool: e(i), regexp: e(i), escape: e(i), color: e(i), url: e(i), keyword: Go, self: e(Go), null: e(Go), atom: e(Go), unit: e(Go), modifier: e(Go), operatorKeyword: e(Go), controlKeyword: e(Go), definitionKeyword: e(Go), moduleKeyword: e(Go), operator: n, derefOperator: e(n), arithmeticOperator: e(n), logicOperator: e(n), bitwiseOperator: e(n), compareOperator: e(n), updateOperator: e(n), definitionOperator: e(n), typeOperator: e(n), controlOperator: e(n), punctuation: Yo, separator: e(Yo), bracket: Jo, angleBracket: e(Jo), squareBracket: e(Jo), paren: e(Jo), brace: e(Jo), content: s, heading: Xo, heading1: e(Xo), heading2: e(Xo), heading3: e(Xo), heading4: e(Xo), heading5: e(Xo), heading6: e(Xo), contentSeparator: e(s), list: e(s), quote: e(s), emphasis: e(s), strong: e(s), link: e(s), monospace: e(s), strikethrough: e(s), inserted: e(), deleted: e(), changed: e(), invalid: e(), meta: Zo, documentMeta: e(Zo), annotation: e(Zo), processingInstruction: e(Zo), definition: zo.defineModifier(), constant: zo.defineModifier(), function: zo.defineModifier(), standard: zo.defineModifier(), local: zo.defineModifier(), special: zo.defineModifier() }, ta = (Qo([{ tag: h.link, class: "tok-link" }, { tag: h.heading, class: "tok-heading" }, { tag: h.emphasis, class: "tok-emphasis" }, { tag: h.strong, class: "tok-strong" }, { tag: h.keyword, class: "tok-keyword" }, { tag: h.atom, class: "tok-atom" }, { tag: h.bool, class: "tok-bool" }, { tag: h.url, class: "tok-url" }, { tag: h.labelName, class: "tok-labelName" }, { tag: h.inserted, class: "tok-inserted" }, { tag: h.deleted, class: "tok-deleted" }, { tag: h.literal, class: "tok-literal" }, { tag: h.string, class: "tok-string" }, { tag: h.number, class: "tok-number" }, { tag: [h.regexp, h.escape, h.special(h.string)], class: "tok-string2" }, { tag: h.variableName, class: "tok-variableName" }, { tag: h.local(h.variableName), class: "tok-variableName tok-local" }, { tag: h.definition(h.variableName), class: "tok-variableName tok-definition" }, { tag: h.special(h.variableName), class: "tok-variableName2" }, { tag: h.definition(h.propertyName), class: "tok-propertyName tok-definition" }, { tag: h.typeName, class: "tok-typeName" }, { tag: h.namespace, class: "tok-namespace" }, { tag: h.className, class: "tok-className" }, { tag: h.macroName, class: "tok-macroName" }, { tag: h.propertyName, class: "tok-propertyName" }, { tag: h.operator, class: "tok-operator" }, { tag: h.comment, class: "tok-comment" }, { tag: h.meta, class: "tok-meta" }, { tag: h.invalid, class: "tok-invalid" }, { tag: h.punctuation, class: "tok-punctuation" }]), new _); var ea = new _, ia = class { constructor(t, e, i = [], r = "") { this.data = t, this.name = r, w.prototype.hasOwnProperty("tree") || Object.defineProperty(w.prototype, "tree", { get() { return P(this) } }), this.parser = e, this.extension = [fa.of(this), w.languageData.of((t, e, i) => { var r = ra(t, e, i), s = r.type.prop(ta); if (!s) return []; var n = t.facet(s), s = r.type.prop(ea); if (s) { var o, a, h = r.resolve(e - r.from, i); for (o of s) if (o.test(h, t)) return a = t.facet(o.facet), "replace" == o.type ? a : a.concat(n) } return n })].concat(i) } isActiveAt(t, e, i = -1) { return ra(t, e, i).type.prop(ta) == this.data } findRegions(t) { var e = t.facet(fa); if ((null == e ? void 0 : e.data) == this.data) return [{ from: 0, to: t.doc.length }]; if (!e || !e.allowsNesting) return []; let o = [], a = (e, i) => { if (e.prop(ta) == this.data) o.push({ from: i, to: i + e.length }); else { var t = e.prop(_.mounted); if (t) { if (t.tree.prop(ta) == this.data) { if (t.overlay) for (var r of t.overlay) o.push({ from: r.from + i, to: r.to + i }); else o.push({ from: i, to: i + e.length }); return } if (t.overlay) { var s = o.length; if (a(t.tree, t.overlay[0].from + i), o.length > s) return } } for (let t = 0; t < e.children.length; t++) { var n = e.children[t]; n instanceof j && a(n, e.positions[t] + i) } } }; return a(P(t), 0), o } get allowsNesting() { return !0 } }; function ra(t, e, i) { let r = t.facet(fa), s = P(t).topNode; if (!r || r.allowsNesting) for (let t = s; t; t = t.enter(e, i, D.ExcludeBuffers))t.type.isTop && (s = t); return s } ia.setState = c.define(); var sa = class qf extends ia { constructor(t, e, i) { super(t, e, [], i), this.parser = e } static define(t) { i = t.languageData; let e = d.define({ combine: i ? t => t.concat(i) : void 0 }); var i; return new qf(e, t.parser.configure({ props: [ta.add(t => t.isTop ? e : void 0)] }), t.name) } configure(t, e) { return new qf(this.data, this.parser.configure(t), e || this.name) } get allowsNesting() { return this.parser.hasWrappers() } }; function P(t) { t = t.field(ia.state, !1); return t ? t.tree : j.empty } var na = class { constructor(t) { this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter() } get length() { return this.doc.length } syncTo(t) { return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length } chunk(t) { return this.syncTo(t), this.string } get lineChunks() { return !0 } read(t, e) { var i = this.cursorPos - this.string.length; return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i) } }, oa = null, aa = class _f { constructor(t, e, i = [], r, s, n, o, a) { this.parser = t, this.state = e, this.fragments = i, this.tree = r, this.treeLen = s, this.viewport = n, this.skipped = o, this.scheduleOn = a, this.parse = null, this.tempSkipped = [] } static create(t, e, i) { return new _f(t, e, [], j.empty, 0, i, [], null) } startParse() { return this.parser.startParse(new na(this.state.doc), this.fragments) } work(i, r) { return null != r && r >= this.state.doc.length && (r = void 0), this.tree != j.empty && this.isDone(null != r ? r : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => { var t; if ("number" == typeof i) { let t = Date.now() + i; i = () => Date.now() > t } for (this.parse || (this.parse = this.startParse()), null != r && (null == this.parse.stoppedAt || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ;) { var e = this.parse.advance(); if (e) { if (this.fragments = this.withoutTempSkipped(Io.addTree(e, this.fragments, null != this.parse.stoppedAt)), this.treeLen = null != (t = this.parse.stoppedAt) ? t : this.state.doc.length, this.tree = e, this.parse = null, !(this.treeLen < (null != r ? r : this.state.doc.length))) return !0; this.parse = this.startParse() } if (i()) return !1 } }) } takeTree() { let t, e; this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((null == this.parse.stoppedAt || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => { for (; !(e = this.parse.advance());); }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(Io.addTree(this.tree, this.fragments, !0)), this.parse = null) } withContext(t) { var e = oa; oa = this; try { return t() } finally { oa = e } } withoutTempSkipped(t) { for (var e; e = this.tempSkipped.pop();)t = ha(t, e.from, e.to); return t } changes(t, e) { let { fragments: i, tree: r, treeLen: n, viewport: o, skipped: a } = this; if (this.takeTree(), !t.empty) { let s = []; if (t.iterChangedRanges((t, e, i, r) => s.push({ fromA: t, toA: e, fromB: i, toB: r })), i = Io.applyChanges(i, s), r = j.empty, n = 0, o = { from: t.mapPos(o.from, -1), to: t.mapPos(o.to, 1) }, this.skipped.length) { a = []; for (var h of this.skipped) { var l = t.mapPos(h.from, 1), h = t.mapPos(h.to, -1); l < h && a.push({ from: l, to: h }) } } } return new _f(this.parser, e, i, r, n, o, a, this.scheduleOn) } updateViewport(e) { if (this.viewport.from == e.from && this.viewport.to == e.to) return !1; this.viewport = e; var t = this.skipped.length; for (let t = 0; t < this.skipped.length; t++) { var { from: i, to: r } = this.skipped[t]; i < e.to && r > e.from && (this.fragments = ha(this.fragments, i, r), this.skipped.splice(t--, 1)) } return !(this.skipped.length >= t || (this.reset(), 0)) } reset() { this.parse && (this.takeTree(), this.parse = null) } skipUntilInView(t, e) { this.skipped.push({ from: t, to: e }) } static getSkippingParser(n) { return new class extends Vo { createParse(t, e, i) { let r = i[0].from, s = i[i.length - 1].to; return { parsedPos: r, advance() { var t = oa; if (t) { for (var e of i) t.tempSkipped.push(e); n && (t.scheduleOn = t.scheduleOn ? Promise.all([t.scheduleOn, n]) : n) } return this.parsedPos = s, new j(go.none, [], [], s - r) }, stoppedAt: null, stopAt() { } } } } } isDone(t) { t = Math.min(t, this.state.doc.length); var e = this.fragments; return this.treeLen >= t && e.length && 0 == e[0].from && e[0].to >= t } static get() { return oa } }; function ha(t, e, i) { return Io.applyChanges(t, [{ fromA: e, toA: i, fromB: e, toB: i }]) } var la = class jf { constructor(t) { this.context = t, this.tree = t.tree } apply(t) { var e; return t.docChanged || this.tree != this.context.tree ? (e = this.context.changes(t.changes, t.state), t = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to), e.work(20, t) || e.takeTree(), new jf(e)) : this } static init(t) { var e = Math.min(3e3, t.doc.length), t = aa.create(t.facet(fa).parser, t, { from: 0, to: e }); return t.work(20, e) || t.takeTree(), new jf(t) } }, ca = (ia.state = p.define({ create: la.init, update(t, e) { for (var i of e.effects) if (i.is(ia.setState)) return i.value; return e.startState.facet(fa) != e.state.facet(fa) ? la.init(e.state) : t.apply(e) } }), t => { let e = setTimeout(() => t(), 500); return () => clearTimeout(e) }), da = ("undefined" != typeof requestIdleCallback && (ca = t => { let e = -1, i = setTimeout(() => { e = requestIdleCallback(t, { timeout: 400 }) }, 100); return () => e < 0 ? clearTimeout(i) : cancelIdleCallback(e) }), "undefined" != typeof navigator && null != (Xe = navigator.scheduling) && Xe.isInputPending ? () => navigator.scheduling.isInputPending() : null), ua = a.fromClass(class { constructor(t) { this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork() } update(t) { var e = this.view.state.field(ia.state).context; (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e) } scheduleWork() { var t, e; this.working || (t = this.view.state, (e = t.field(ia.state)).tree == e.context.tree && e.context.isDone(t.doc.length)) || (this.working = ca(this.work)) } work(e) { this.working = null; var i = Date.now(); if (this.chunkEnd < i && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = i + 3e4, this.chunkBudget = 3e3), !(this.chunkBudget <= 0)) { var { state: r, viewport: { to: s } } = this.view, n = r.field(ia.state); if (n.tree != n.context.tree || !n.context.isDone(s + 1e5)) { let t = Date.now() + Math.min(this.chunkBudget, 100, e && !da ? Math.max(25, e.timeRemaining() - 5) : 1e9); e = n.context.treeLen < s && r.doc.length > s + 1e3, r = n.context.work(() => da && da() || Date.now() > t, s + (e ? 0 : 1e5)); this.chunkBudget -= Date.now() - i, (r || this.chunkBudget <= 0) && (n.context.takeTree(), this.view.dispatch({ effects: ia.setState.of(new la(n.context)) })), 0 < this.chunkBudget && (!r || e) && this.scheduleWork(), this.checkAsyncSchedule(n.context) } } } checkAsyncSchedule(t) { t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch(t => qi(this.view.state, t)).then(() => this.workScheduled--), t.scheduleOn = null) } destroy() { this.working && this.working() } isWorking() { return !!(this.working || 0 < this.workScheduled) } }, { eventHandlers: { focus() { this.scheduleWork() } } }), fa = d.define({ combine(t) { return t.length ? t[0] : null }, enables: e => [ia.state, ua, T.contentAttributes.compute([e], t => { t = t.facet(e); return t && t.name ? { "data-language": t.name } : {} })] }), pa = class { constructor(t, e = []) { this.language = t, this.support = e, this.extension = [t, e] } }, ma = d.define(), ga = d.define({ combine: t => { if (!t.length) return "  "; let e = t[0]; if (!e || /\S/.test(e) || Array.from(e).some(t => t != e[0])) throw new Error("Invalid indent unit: " + JSON.stringify(t[0])); return e } }); function va(t) { var e = t.facet(ga); return 9 == e.charCodeAt(0) ? t.tabSize * e.length : e.length } function wa(t, e) { let i = "", r = t.tabSize, s = t.facet(ga)[0]; if ("\t" == s) { for (; r <= e;)i += "\t", e -= r; s = " " } for (let t = 0; t < e; t++)i += s; return i } function ba(t, r) { for (var e of (t = t instanceof w ? new ya(t) : t).state.facet(ma)) { e = e(t, r); if (void 0 !== e) return e } var s = P(t.state); if (s.length >= r) { var n = t, o = r; let e = s.resolveStack(o), i = e.node.enterUnfinishedNodesBefore(o); if (i != e.node) { var a = []; for (let t = i; t != e.node; t = t.parent)a.push(t); for (let t = a.length - 1; 0 <= t; t--)e = { node: a[t], next: e } } return ka(e, n, o) } return null } var ya = class { constructor(t, e = {}) { this.state = t, this.options = e, this.unit = va(t) } lineAt(t, e = 1) { var i = this.state.doc.lineAt(t), { simulateBreak: r, simulateDoubleBreak: s } = this.options; return null != r && r >= i.from && r <= i.to ? s && r == t ? { text: "", from: t } : (e < 0 ? r < t : r <= t) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i } textAfterPos(t, e = 1) { var i; return this.options.simulateDoubleBreak && t == this.options.simulateBreak ? "" : ({ text: e, from: i } = this.lineAt(t, e), e.slice(t - i, Math.min(e.length, t + 100 - i))) } column(t, e = 1) { var { text: e, from: i } = this.lineAt(t, e); let r = this.countColumn(e, t - i); t = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1; return -1 < t && (r += t - this.countColumn(e, e.search(/\S|$/))), r } countColumn(t, e = t.length) { return oe(t, this.state.tabSize, e) } lineIndent(t, e = 1) { var { text: t, from: e } = this.lineAt(t, e), i = this.options.overrideIndentation; if (i) { i = i(e); if (-1 < i) return i } return this.countColumn(t, t.search(/\S|$/)) } get simulatedBreak() { return this.options.simulateBreak || null } }, xa = new _; function ka(e, i, r) { for (let t = e; t; t = t.next) { var s = (t => { var e = t.type.prop(xa); if (e) return e; let i = t.firstChild, r; if (i && (r = i.type.prop(_.closedBy))) { let a = t.lastChild, h = a && -1 < r.indexOf(a.name); return t => { return e = t, i = !0, r = 1, s = void 0, t = h && ((t = t).pos != t.options.simulateBreak || !t.options.simulateDoubleBreak) ? a.from : void 0, n = e.textAfter, o = n.match(/^\s*/)[0].length, n = s && n.slice(o, o + s.length) == s || t == e.pos + o, (s = i ? (t => { var e = t.node, i = e.childAfter(e.from), r = e.lastChild; if (!i) return null; var s = t.options.simulateBreak, t = t.state.doc.lineAt(i.from), n = null == s || s <= t.from ? t.to : Math.min(t.to, s); for (let t = i.to; ;) { var o = e.childAfter(t); if (!o || o == r) return null; if (!o.type.isSkipped) return o.from < n ? i : null; t = o.to } })(e) : null) ? n ? e.column(s.from) : e.column(s.to) : e.baseIndent + (n ? 0 : e.unit * r); var e, i, r, s, n, o } } return null == t.parent ? Sa : null })(t.node); if (s) return s(Ca.create(i, r, t)) } return 0 } function Sa() { return 0 } var Ca = class Uf extends ya { constructor(t, e, i) { super(t.state, t.options), this.base = t, this.pos = e, this.context = i } get node() { return this.context.node } static create(t, e, i) { return new Uf(t, e, i) } get textAfter() { return this.textAfterPos(this.pos) } get baseIndent() { return this.baseIndentFor(this.node) } baseIndentFor(e) { let i = this.state.doc.lineAt(e.from); for (; ;) { let t = e.resolve(i.from); for (; t.parent && t.parent.from == t.from;)t = t.parent; if (((e, i) => { for (let t = i; t; t = t.parent)if (e == t) return 1 })(t, e)) break; i = this.state.doc.lineAt(t.from) } return this.lineIndent(i.from) } continue() { return ka(this.context.next, this.base, this.pos) } }; function Aa({ except: i, units: r = 1 } = {}) { return t => { var e = i && i.test(t.textAfter); return t.baseIndent + (e ? 0 : r * t.unit) } } var Oa = d.define(), Ma = new _; function Ta(t, i, r) { for (var e of t.facet(Oa)) { e = e(t, i, r); if (e) return e } { var s = t, n = i, o = r, a, h = P(s); if (h.length < o) return null; let e = null; for (let t = h.resolveStack(o, 1); t; t = t.next) { var l = t.node; if (!(l.to <= o || l.from > o)) { if (e && l.from < n) break; var c, d = l.type.prop(Ma); d && (l.to < h.length - 50 || h.length == s.doc.length || (a = void 0, !(a = (c = l).lastChild)) || a.to != c.to || !a.type.isError) && (c = d(l, s)) && c.from <= o && c.from >= n && c.to > o && (e = c) } } return e } } function Da(t, e) { var i = e.mapPos(t.from, 1), e = e.mapPos(t.to, -1); return e <= i ? void 0 : { from: i, to: e } } var Pa = c.define({ map: Da }), Ra = c.define({ map: Da }); function Ba(t) { var i = []; for (let { head: e } of t.state.selection.ranges) i.some(t => t.from <= e && t.to >= e) || i.push(t.lineBlockAt(e)); return i } var Ea = p.define({ create() { return C.none }, update(t, e) { t = t.map(e.changes); for (let i of e.effects) { var r; i.is(Pa) && !((t, i, r) => { let s = !1; return t.between(i, i, (t, e) => { t == i && e == r && (s = !0) }), s })(t, i.value.from, i.value.to) ? (r = e.state.facet(Wa).preparePlaceholder, r = r ? C.replace({ widget: new _a(r(e.state, i.value)) }) : qa, t = t.update({ add: [r.range(i.value.from, i.value.to)] })) : i.is(Ra) && (t = t.update({ filter: (t, e) => i.value.from != t || i.value.to != e, filterFrom: i.value.from, filterTo: i.value.to })) } if (e.selection) { let i = !1, r = e.selection.main.head; t.between(r, r, (t, e) => { t < r && e > r && (i = !0) }), i && (t = t.update({ filterFrom: r, filterTo: r, filter: (t, e) => e <= r || t >= r })) } return t }, provide: t => T.decorations.from(t), toJSON(t, e) { let i = []; return t.between(0, e.doc.length, (t, e) => { i.push(t, e) }), i }, fromJSON(e) { if (!Array.isArray(e) || e.length % 2) throw new RangeError("Invalid JSON for fold state"); var i = []; for (let t = 0; t < e.length;) { var r = e[t++], s = e[t++]; if ("number" != typeof r || "number" != typeof s) throw new RangeError("Invalid JSON for fold state"); i.push(qa.range(r, s)) } return C.set(i, !0) } }); function La(t, e, i) { let r, s = null; return null != (r = t.field(Ea, !1)) && r.between(e, i, (t, e) => { (!s || s.from > t) && (s = { from: t, to: e }) }), s } function Na(t, e) { return t.field(Ea, !1) ? e : e.concat(c.appendConfig.of(za())) } function Ia(t, e, i = !0) { var r = t.state.doc.lineAt(e.from).number, e = t.state.doc.lineAt(e.to).number; return T.announce.of(`${t.state.phrase(i ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${e}.`) } var Va = [{ key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: t => { for (var e of Ba(t)) { e = Ta(t.state, e.from, e.to); if (e) return t.dispatch({ effects: Na(t.state, [Pa.of(e), Ia(t, e)]) }), !0 } return !1 } }, { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: t => { if (!t.state.field(Ea, !1)) return !1; var e, i = []; for (e of Ba(t)) { var r = La(t.state, e.from, e.to); r && i.push(Ra.of(r), Ia(t, r, !1)) } return i.length && t.dispatch({ effects: i }), 0 < i.length } }, { key: "Ctrl-Alt-[", run: e => { var i = e.state, r = []; for (let t = 0; t < i.doc.length;) { var s = e.lineBlockAt(t), n = Ta(i, s.from, s.to); n && r.push(Pa.of(n)), t = (n ? e.lineBlockAt(n.to) : s).to + 1 } return r.length && e.dispatch({ effects: Na(e.state, r) }), !!r.length } }, { key: "Ctrl-Alt-]", run: t => { var e = t.state.field(Ea, !1); if (!e || !e.size) return !1; let i = []; return e.between(0, t.state.doc.length, (t, e) => { i.push(Ra.of({ from: t, to: e })) }), t.dispatch({ effects: i }), !0 } }], Ha = { placeholderDOM: null, preparePlaceholder: null, placeholderText: "â€¦" }, Wa = d.define({ combine(t) { return jt(t, Ha) } }); function za(t) { var e = [Ea, $a]; return t && e.push(Wa.of(t)), e } function Fa(i, t) { var e = i.state, r = e.facet(Wa), s = t => { var e = i.lineBlockAt(i.posAtDOM(t.target)), e = La(i.state, e.from, e.to); e && i.dispatch({ effects: Ra.of(e) }), t.preventDefault() }; return r.placeholderDOM ? r.placeholderDOM(i, s, t) : ((t = document.createElement("span")).textContent = r.placeholderText, t.setAttribute("aria-label", e.phrase("folded code")), t.title = e.phrase("unfold"), t.className = "cm-foldPlaceholder", t.onclick = s, t) } var qa = C.replace({ widget: new class extends Qe { toDOM(t) { return Fa(t, null) } } }), _a = class extends Qe { constructor(t) { super(), this.value = t } eq(t) { return this.value == t.value } toDOM(t) { return Fa(t, this.value) } }, ja = { openText: "âŒ„", closedText: "â€º", markerDOM: null, domEventHandlers: {}, foldingChanged: () => !1 }, Ua = class extends $e { constructor(t, e) { super(), this.config = t, this.open = e } eq(t) { return this.config == t.config && this.open == t.open } toDOM(t) { var e; return this.config.markerDOM ? this.config.markerDOM(this.open) : ((e = document.createElement("span")).textContent = this.open ? this.config.openText : this.config.closedText, e.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), e) } }; function Qa(t = {}) { let e = Object.assign(Object.assign({}, ja), t), s = new Ua(e, !0), n = new Ua(e, !1), i = a.fromClass(class { constructor(t) { this.from = t.viewport.from, this.markers = this.buildMarkers(t) } update(t) { (t.docChanged || t.viewportChanged || t.startState.facet(fa) != t.state.facet(fa) || t.startState.field(Ea, !1) != t.state.field(Ea, !1) || P(t.startState) != P(t.state) || e.foldingChanged(t)) && (this.markers = this.buildMarkers(t.view)) } buildMarkers(t) { var e, i = new Xt; for (e of t.viewportLineBlocks) { var r = La(t.state, e.from, e.to) ? n : Ta(t.state, e.from, e.to) ? s : null; r && i.add(e.from, e.from, r) } return i.finish() } }), r = e.domEventHandlers; return [i, (t = { class: "cm-foldGutter", markers(t) { return (null == (t = t.plugin(i)) ? void 0 : t.markers) || b.empty }, initialSpacer() { return new Ua(e, !1) }, domEventHandlers: Object.assign(Object.assign({}, r), { click: (t, e, i) => !((!r.click || !r.click(t, e, i)) && ((i = La(t.state, e.from, e.to)) ? (t.dispatch({ effects: Ra.of(i) }), 0) : !(i = Ta(t.state, e.from, e.to)) || (t.dispatch({ effects: Pa.of(i) }), 0))) }) }, [Gn(), Kn.of(Object.assign(Object.assign({}, $n), t))]), za()] } var $a = T.baseTheme({ ".cm-foldPlaceholder": { backgroundColor: "#eee", border: "1px solid #ddd", color: "#888", borderRadius: ".2em", margin: "0 1px", padding: "0 1px", cursor: "pointer" }, ".cm-foldGutter span": { padding: "0 1px", cursor: "pointer" } }), Ka = class Qf { constructor(t, e) { this.specs = t; let i; function r(t) { var e = ue.newName(); return (i = i || Object.create(null))["." + e] = t, e } var s = "string" == typeof e.all ? e.all : e.all ? r(e.all) : void 0; let n = e.scope; this.scope = n instanceof ia ? t => t.prop(ta) == n.data : n ? t => t == n : void 0, this.style = Qo(t.map(t => ({ tag: t.tag, class: t.class || r(Object.assign({}, t, { tag: null })) })), { all: s }).style, this.module = i ? new ue(i) : null, this.themeType = e.themeType } static define(t, e) { return new Qf(t, e || {}) } }, Xa = d.define(), Ga = d.define({ combine(t) { return t.length ? [t[0]] : null } }); function Ya(t) { var e = t.facet(Xa); return e.length ? e : t.facet(Ga) } function Ja(e, t) { let i = [Za], r; return e instanceof Ka && (e.module && i.push(T.styleModule.of(e.module)), r = e.themeType), null != t && t.fallback ? i.push(Ga.of(e)) : r ? i.push(Xa.computeN([T.darkTheme], t => t.facet(T.darkTheme) == ("dark" == r) ? [e] : [])) : i.push(Xa.of(e)), i } var Za = wt.high(a.fromClass(class { constructor(t) { this.markCache = Object.create(null), this.tree = P(t.state), this.decorations = this.buildDeco(t, Ya(t.state)) } update(t) { var e = P(t.state), i = Ya(t.state), r = i != Ya(t.startState); e.length < t.view.viewport.to && !r && e.type == this.tree.type ? this.decorations = this.decorations.map(t.changes) : (e != this.tree || t.viewportChanged || r) && (this.tree = e, this.decorations = this.buildDeco(t.view, i)) } buildDeco(t, e) { if (!e || !this.tree.length) return C.none; let r = new Xt; for (var { from: i, to: s } of t.visibleRanges) $o(this.tree, e, (t, e, i) => { r.add(t, e, this.markCache[i] || (this.markCache[i] = C.mark({ class: i }))) }, i, s); return r.finish() } }, { decorations: t => t.decorations })), th = Ka.define([{ tag: h.meta, color: "#404740" }, { tag: h.link, textDecoration: "underline" }, { tag: h.heading, textDecoration: "underline", fontWeight: "bold" }, { tag: h.emphasis, fontStyle: "italic" }, { tag: h.strong, fontWeight: "bold" }, { tag: h.strikethrough, textDecoration: "line-through" }, { tag: h.keyword, color: "#708" }, { tag: [h.atom, h.bool, h.url, h.contentSeparator, h.labelName], color: "#219" }, { tag: [h.literal, h.inserted], color: "#164" }, { tag: [h.string, h.deleted], color: "#a11" }, { tag: [h.regexp, h.escape, h.special(h.string)], color: "#e40" }, { tag: h.definition(h.variableName), color: "#00f" }, { tag: h.local(h.variableName), color: "#30a" }, { tag: [h.typeName, h.namespace], color: "#085" }, { tag: h.className, color: "#167" }, { tag: [h.special(h.variableName), h.macroName], color: "#256" }, { tag: h.definition(h.propertyName), color: "#00c" }, { tag: h.comment, color: "#940" }, { tag: h.invalid, color: "#f00" }]), _e = T.baseTheme({ "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" }, "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" } }), eh = 1e4, ih = "()[]{}", rh = d.define({ combine(t) { return jt(t, { afterCursor: !0, brackets: ih, maxScanDistance: eh, renderMatch: oh }) } }), sh = C.mark({ class: "cm-matchingBracket" }), nh = C.mark({ class: "cm-nonmatchingBracket" }); function oh(t) { var e = [], i = t.matched ? sh : nh; return e.push(i.range(t.start.from, t.start.to)), t.end && e.push(i.range(t.end.from, t.end.to)), e } var ah = [p.define({ create() { return C.none }, update(t, e) { if (!e.docChanged && !e.selection) return t; let i = []; var r, s, n = e.state.facet(rh); for (r of e.state.selection.ranges) r.empty && (s = dh(e.state, r.head, -1, n) || 0 < r.head && dh(e.state, r.head - 1, 1, n) || n.afterCursor && (dh(e.state, r.head, 1, n) || r.head < e.state.doc.length && dh(e.state, r.head + 1, -1, n))) && (i = i.concat(n.renderMatch(s, e.state))); return C.set(i, !0) }, provide: t => T.decorations.from(t) }), _e]; var hh = new _; function lh(t, e, i) { var r = t.prop(e < 0 ? _.openedBy : _.closedBy); if (r) return r; if (1 == t.name.length) { r = i.indexOf(t.name); if (-1 < r && r % 2 == (e < 0 ? 1 : 0)) return [i[r + e]] } return null } function ch(t) { var e = t.type.prop(hh); return e ? e(t.node) : t } function dh(t, n, o, s = {}) { var a = s.maxScanDistance || eh, h = s.brackets || ih, s = P(t), l = s.resolveInner(n, o); for (let s = l; s; s = s.parent) { var c = lh(s.type, o, h); if (c && s.from < s.to) { var d, u = ch(s); if (u && (0 < o ? n >= u.from && n < u.to : n > u.from && n <= u.to)) { var f = o; var p = s; var m = c; var g = h; let t = p.parent, e = { from: u.from, to: u.to }, i = 0, r = null == t ? void 0 : t.cursor(); if (r && (f < 0 ? r.childBefore(p.from) : r.childAfter(p.to))) do { if (f < 0 ? r.to <= p.from : r.from >= p.to) { if (0 == i && -1 < m.indexOf(r.type.name) && r.from < r.to) return d = ch(r), { start: e, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 }; if (lh(r.type, f, g)) i++; else if (lh(r.type, -f, g)) { if (0 == i) return d = ch(r), { start: e, end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0, matched: !1 }; i-- } } } while (f < 0 ? r.prevSibling() : r.nextSibling()); return { start: e, matched: !1 }; return } } } { var v = n, w = o, b = s, y = l.type, x = a, k = h, s = w < 0 ? t.sliceDoc(v - 1, v) : t.sliceDoc(v, v + 1), S = k.indexOf(s); if (S < 0 || S % 2 == 0 != 0 < w) return null; let i = { from: w < 0 ? v - 1 : v, to: 0 < w ? v + 1 : v }, e = t.doc.iterRange(v, 0 < w ? t.doc.length : 0), r = 0; for (let t = 0; !e.next().done && t <= x;) { var C = e.value, A = (w < 0 && (t += C.length), v + t * w); for (let t = 0 < w ? 0 : C.length - 1, e = 0 < w ? C.length : -1; t != e; t += w) { var O = k.indexOf(C[t]); if (!(O < 0 || b.resolveInner(A + t, 1).type != y)) if (O % 2 == 0 == 0 < w) r++; else { if (1 == r) return { start: i, end: { from: A + t, to: A + t + 1 }, matched: O >> 1 == S >> 1 }; r-- } } 0 < w && (t += C.length) } return e.done ? { start: i, matched: !1 } : null } } var uh, fh, ph = Object.create(null), mh = [go.none], gh = [], vh = Object.create(null), wh = Object.create(null); for ([uh, fh] of [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]]) wh[uh] = yh(ph, fh); function bh(t, e) { -1 < gh.indexOf(t) || (gh.push(t), console.warn(e)) } function yh(e, t) { var i, r, s = []; for (i of t.split(" ")) { let t = []; for (var n of i.split(".")) { var o = e[n] || h[n]; o ? "function" == typeof o ? t.length ? t = t.map(o) : bh(n, `Modifier ${n} used at start of tag`) : t.length ? bh(n, `Tag ${n} used as modifier`) : t = Array.isArray(o) ? o : [o] : bh(n, "Unknown highlighting tag " + n) } for (var a of t) s.push(a) } return s.length ? (r = (t = t.replace(/ /g, "_")) + " " + s.map(t => t.id), (vh[r] || (r = vh[r] = go.define({ id: mh.length, name: t, props: [_o({ [t]: s })] }), mh.push(r), r)).id) : 0 } O.RTL, O.LTR; function xh(r, s) { return ({ state: t, dispatch: e }) => { var i; return !t.readOnly && !!(i = r(s, t)) && (e(t.update(i)), !0) } } var kh = xh(Mh, 0), Ue = xh(Oh, 0), Sh = xh((t, e) => Oh(t, e, (t => { var e = []; for (r of t.selection.ranges) { var i = t.doc.lineAt(r.from), r = r.to <= i.to ? i : t.doc.lineAt(r.to), s = e.length - 1; 0 <= s && e[s].to > i.from ? e[s].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to }) } return e })(e)), 0); function Ch(t, e) { t = t.languageDataAt("commentTokens", e); return t.length ? t[0] : {} } var Ah = 50; function Oh(t, u, e = u.selection.ranges) { let f = e.map(t => Ch(u, t.from).block); if (f.every(t => t)) { let i = e.map((i, r) => { { var [r, { open: i, close: s }, n, o] = [u, f[r], i.from, i.to], a = r.sliceDoc(n - Ah, n), h = r.sliceDoc(o, o + Ah), l = /\s*$/.exec(a)[0].length, c = /^\s*/.exec(h)[0].length, d = a.length - l; if (a.slice(d - i.length, d) == i && h.slice(c, c + s.length) == s) return { open: { pos: n - l, margin: l && 1 }, close: { pos: o + c, margin: c && 1 } }; let t, e; return o - n <= 2 * Ah ? t = e = r.sliceDoc(n, o) : (t = r.sliceDoc(n, n + Ah), e = r.sliceDoc(o - Ah, o)), a = /^\s*/.exec(t)[0].length, d = /\s*$/.exec(e)[0].length, h = e.length - d - s.length, t.slice(a, a + i.length) == i && e.slice(h, h + s.length) == s ? { open: { pos: n + a + i.length, margin: /\s/.test(t.charAt(a + i.length)) ? 1 : 0 }, close: { pos: o - d - s.length, margin: /\s/.test(e.charAt(h - 1)) ? 1 : 0 } } : null } }); if (2 != t && !i.every(t => t)) return { changes: u.changes(e.map((t, e) => i[e] ? [] : [{ from: t.from, insert: f[e].open + " " }, { from: t.to, insert: " " + f[e].close }])) }; if (1 != t && i.some(t => t)) { var r, s, n, o = []; for (let t = 0, e; t < i.length; t++)(e = i[t]) && (r = f[t], { open: s, close: n } = e, o.push({ from: s.pos - r.open.length, to: s.pos + s.margin }, { from: n.pos - n.margin, to: n.pos + r.close.length })); return { changes: o } } } return null } function Mh(t, r, e = r.selection.ranges) { var s, n, o = []; let a = -1; for ({ from: s, to: n } of e) { let e = o.length, i = 1e9; var h = Ch(r, s).line; if (h) { for (let t = s; t <= n;) { var l, c, d, u = r.doc.lineAt(t); u.from > a && (s == n || n > u.from) && (a = u.from, c = (l = /^\s*/.exec(u.text)[0].length) == u.length, d = u.text.slice(l, l + h.length) == h ? l : -1, l < u.text.length && l < i && (i = l), o.push({ line: u, comment: d, token: h, indent: l, empty: c, single: !1 })), t = u.to + 1 } if (i < 1e9) for (let t = e; t < o.length; t++)o[t].indent < o[t].line.text.length && (o[t].indent = i); o.length == e + 1 && (o[e].single = !0) } } if (2 != t && o.some(t => t.comment < 0 && (!t.empty || t.single))) { var i, f, p, m, g, v = []; for ({ line: i, token: f, indent: p, empty: m, single: g } of o) !g && m || v.push({ from: i.from + p, insert: f + " " }); e = r.changes(v); return { changes: e, selection: r.selection.map(e, 1) } } if (1 != t && o.some(t => 0 <= t.comment)) { var w, b, y, x = []; for ({ line: w, comment: b, token: y } of o) if (0 <= b) { let t = w.from + b, e = t + y.length; " " == w.text[e - w.from] && e++, x.push({ from: t, to: e }) } return { changes: x } } return null } var Th = Bt.define(), Dh = Bt.define(), Ph = d.define(), Rh = d.define({ combine(t) { return jt(t, { minDepth: 100, newGroupDelay: 500, joinToEvent: (t, e) => e }, { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (i, r) => (t, e) => i(t, e) || r(t, e) }) } }), Bh = p.define({ create() { return jh.empty }, update(e, i) { var r = i.state.facet(Rh), s = i.annotation(Th); if (s) { var n = Ih.fromTransaction(i, s.selection), o = s.side; let t = 0 == o ? e.undone : e.done; return t = n ? Vh(t, t.length, r.minDepth, n) : Fh(t, i.startState.selection), new jh(0 == o ? s.rest : t, 0 == o ? t : s.rest) } var t, n = i.annotation(Dh); return "full" != n && "before" != n || (e = e.isolate()), !1 === i.annotation(Nt.addToHistory) ? i.changes.empty ? e : e.addMapping(i.changes.desc) : (o = Ih.fromTransaction(i), s = i.annotation(Nt.time), t = i.annotation(Nt.userEvent), o ? e = e.addChanges(o, s, t, r, i) : i.selection && (e = e.addSelection(i.startState.selection, s, t, r.newGroupDelay)), "full" != n && "after" != n ? e : e.isolate()) }, toJSON(t) { return { done: t.done.map(t => t.toJSON()), undone: t.undone.map(t => t.toJSON()) } }, fromJSON(t) { return new jh(t.done.map(Ih.fromJSON), t.undone.map(Ih.fromJSON)) } }); function Eh(r, s) { return function({ state: t, dispatch: e }) { var i; return !(!s && t.readOnly || !(i = t.field(Bh, !1)) || !(i = i.pop(r, t, s)) || (e(i), 0)) } } var Lh = Eh(0, !1), Nh = Eh(1, !1), Ke = Eh(0, !0), je = Eh(1, !0), Ih = class $f { constructor(t, e, i, r, s) { this.changes = t, this.effects = e, this.mapped = i, this.startSelection = r, this.selectionsAfter = s } setSelAfter(t) { return new $f(this.changes, this.effects, this.mapped, this.startSelection, t) } toJSON() { var t; return { changes: null == (t = this.changes) ? void 0 : t.toJSON(), mapped: null == (t = this.mapped) ? void 0 : t.toJSON(), startSelection: null == (t = this.startSelection) ? void 0 : t.toJSON(), selectionsAfter: this.selectionsAfter.map(t => t.toJSON()) } } static fromJSON(t) { return new $f(t.changes && it.fromJSON(t.changes), [], t.mapped && et.fromJSON(t.mapped), t.startSelection && v.fromJSON(t.startSelection), t.selectionsAfter.map(v.fromJSON)) } static fromTransaction(t, e) { let i = Wh; for (var r of t.startState.facet(Ph)) { r = r(t); r.length && (i = i.concat(r)) } return !i.length && t.changes.empty ? null : new $f(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, Wh) } static selection(t) { return new $f(void 0, Wh, void 0, void 0, t) } }; function Vh(t, e, i, r) { t = t.slice(i + 20 < e + 1 ? e - i - 1 : 0, e); return t.push(r), t } function Hh(t, e) { return t.length ? e.length ? t.concat(e) : t : e } var Wh = [], zh = 200; function Fh(t, e) { var i, r; return t.length ? (r = (i = t[t.length - 1]).selectionsAfter.slice(Math.max(0, i.selectionsAfter.length - zh))).length && r[r.length - 1].eq(e) ? t : (r.push(e), Vh(t, t.length - 1, 1e9, i.setSelAfter(r))) : [Ih.selection([e])] } function qh(t, e) { if (!t.length) return t; let i = t.length, r = Wh; for (; i;) { var s, n = ((t, e, i) => { var r, s, n; return i = Hh(t.selectionsAfter.length ? t.selectionsAfter.map(t => t.map(e)) : Wh, i), t.changes ? (r = t.changes.map(e), s = e.mapDesc(t.changes, !0), n = t.mapped ? t.mapped.composeDesc(s) : s, new Ih(r, c.mapEffects(t.effects, e), n, t.startSelection.map(s), i)) : Ih.selection(i) })(t[i - 1], e, r); if (n.changes && !n.changes.empty || n.effects.length) return (s = t.slice(0, i))[i - 1] = n, s; e = n.mapped, i--, r = n.selectionsAfter } return r.length ? [Ih.selection(r)] : Wh } var _h = /^(input\.type|delete)($|\.)/, jh = class Kf { constructor(t, e, i = 0, r = void 0) { this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = r } isolate() { return this.prevTime ? new Kf(this.done, this.undone) : this } addChanges(t, e, i, r, s) { let n = this.done, o = n[n.length - 1]; return n = o && o.changes && !o.changes.empty && t.changes && (!i || _h.test(i)) && (!o.selectionsAfter.length && e - this.prevTime < r.newGroupDelay && r.joinToEvent(s, ((t, e) => { let o = [], a = !1; return t.iterChangedRanges((t, e) => o.push(t, e)), e.iterChangedRanges((t, e, i, r) => { for (let t = 0; t < o.length;) { var s = o[t++], n = o[t++]; s <= r && i <= n && (a = !0) } }), a })(o.changes, t.changes)) || "input.type.compose" == i) ? Vh(n, n.length - 1, r.minDepth, new Ih(t.changes.compose(o.changes), Hh(t.effects, o.effects), o.mapped, o.startSelection, Wh)) : Vh(n, n.length, r.minDepth, t), new Kf(n, Wh, e, i) } addSelection(t, e, i, r) { var s, n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Wh; return 0 < n.length && e - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && (r = n[n.length - 1], s = t, r.ranges.length == s.ranges.length) && 0 === r.ranges.filter((t, e) => t.empty != s.ranges[e].empty).length ? this : new Kf(Fh(this.done, t), this.undone, e, i) } addMapping(t) { return new Kf(qh(this.done, t), qh(this.undone, t), this.prevTime, this.prevUserEvent) } pop(e, i, t) { var r, s, n = 0 == e ? this.done : this.undone; if (0 != n.length) { var o = n[n.length - 1], a = o.selectionsAfter[0] || i.selection; if (t && o.selectionsAfter.length) return i.update({ selection: o.selectionsAfter[o.selectionsAfter.length - 1], annotations: Th.of({ side: e, rest: (r = (t = n)[t.length - 1], (s = t.slice())[t.length - 1] = r.setSelAfter(r.selectionsAfter.slice(0, r.selectionsAfter.length - 1)), s), selection: a }), userEvent: 0 == e ? "select.undo" : "select.redo", scrollIntoView: !0 }); if (o.changes) { let t = 1 == n.length ? Wh : n.slice(0, n.length - 1); return o.mapped && (t = qh(t, o.mapped)), i.update({ changes: o.changes, selection: o.startSelection, effects: o.effects, annotations: Th.of({ side: e, rest: t, selection: a }), filter: !1, userEvent: 0 == e ? "undo" : "redo", scrollIntoView: !0 }) } } return null } }, Uh = (jh.empty = new jh(Wh, Wh), [{ key: "Mod-z", run: Lh, preventDefault: !0 }, { key: "Mod-y", mac: "Mod-Shift-z", run: Nh, preventDefault: !0 }, { linux: "Ctrl-Shift-z", run: Nh, preventDefault: !0 }, { key: "Mod-u", run: Ke, preventDefault: !0 }, { key: "Alt-u", mac: "Mod-Shift-u", run: je, preventDefault: !0 }]); function Qh(t, e) { return v.create(t.ranges.map(e), t.mainIndex) } function $h(t, e) { return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" }) } function Kh({ state: t, dispatch: e }, i) { i = Qh(t.selection, i); return !i.eq(t.selection, !0) && (e($h(t, i)), !0) } function Xh(t, e) { return v.cursor(e ? t.to : t.from) } function Gh(e, i) { return Kh(e, t => t.empty ? e.moveByChar(t, i) : Xh(t, i)) } function o(t) { return t.textDirectionAt(t.state.selection.main.head) == O.LTR } r = t => Gh(t, !o(t)), i = t => Gh(t, o(t)); function Yh(e, i) { return Kh(e, t => t.empty ? e.moveByGroup(t, i) : Xh(t, i)) } function Jh(e, i, r) { let s = P(e).resolveInner(i.head); var n, o, a, h = r ? _.closedBy : _.openedBy; for (let t = i.head; ;) { var l = r ? s.childAfter(t) : s.childBefore(t); if (!l) break; n = e, a = h, (o = l).type.prop(a) || (a = o.to - o.from) && (2 < a || /[^\s,.;:]/.test(n.sliceDoc(o.from, o.to))) || o.firstChild ? s = l : t = r ? l.to : l.from } let t = s.type.prop(h), c, d; return d = t && (c = r ? dh(e, s.from, 1) : dh(e, s.to, -1)) && c.matched ? r ? c.end.to : c.end.from : r ? s.to : s.from, v.cursor(d, r ? -1 : 1) } function Zh(i, r) { return Kh(i, t => { var e; return t.empty ? (e = i.moveVertically(t, r)).head != t.head ? e : i.moveToLineBoundary(t, r) : Xh(t, r) }) } Go = t => Zh(t, !1), n = t => Zh(t, !0); function tl(t) { var e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2; let i = 0, r = 0, s; if (e) { for (var n of t.state.facet(T.scrollMargins)) { n = n(t); null != n && n.top && (i = Math.max(null == n ? void 0 : n.top, i)), null != n && n.bottom && (r = Math.max(null == n ? void 0 : n.bottom, r)) } s = t.scrollDOM.clientHeight - i - r } else s = (t.dom.ownerDocument.defaultView || window).innerHeight; return { marginTop: i, marginBottom: r, selfScroll: e, height: Math.max(t.defaultLineHeight, s - 5) } } function el(e, i) { let r = tl(e); var t, s, n, o = e.state, a = Qh(o.selection, t => t.empty ? e.moveVertically(t, i, r.height) : Xh(t, i)); if (a.eq(o.selection)) return !1; let h; return r.selfScroll && (t = e.coordsAtPos(o.selection.main.head), s = (n = e.scrollDOM.getBoundingClientRect()).top + r.marginTop, n = n.bottom - r.marginBottom, t) && t.top > s && t.bottom < n && (h = T.scrollIntoView(a.main.head, { y: "start", yMargin: t.top - s })), e.dispatch($h(o, a), { effects: h }), !0 } Yo = t => el(t, !1), Jo = t => el(t, !0); function il(t, e, i) { let r = t.lineBlockAt(e.head), s = t.moveToLineBoundary(e, i); return s.head == e.head && s.head != (i ? r.to : r.from) && (s = t.moveToLineBoundary(e, i, !1)), s = !i && s.head == r.from && r.length && (i = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length) && e.head != r.from + i ? v.cursor(r.from + i) : s } function rl(t, i) { var e = Qh(t.state.selection, t => { var e = i(t); return v.range(t.anchor, e.head, e.goalColumn, e.bidiLevel || void 0) }); return !e.eq(t.state.selection) && (t.dispatch($h(t.state, e)), !0) } function sl(e, i) { return rl(e, t => e.moveByChar(t, i)) } Xo = t => sl(t, !o(t)), s = t => sl(t, o(t)); function nl(e, i) { return rl(e, t => e.moveByGroup(t, i)) } function ol(e, i) { return rl(e, t => e.moveVertically(t, i)) } e = t => ol(t, !1), Zo = t => ol(t, !0); function al(e, i) { return rl(e, t => e.moveVertically(t, i, tl(e).height)) } var Xe = t => al(t, !1), $e = t => al(t, !0), _e = ({ state: t, dispatch: e }) => (e($h(t, { anchor: 0 })), !0), Ke = ({ state: t, dispatch: e }) => (e($h(t, { anchor: t.doc.length })), !0), je = ({ state: t, dispatch: e }) => (e($h(t, { anchor: t.selection.main.anchor, head: 0 })), !0), hl = ({ state: t, dispatch: e }) => (e($h(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0); function ll(s, n) { if (s.state.readOnly) return !1; let o = "delete.selection", t = s.state; var e = t.changeByRange(e => { let { from: i, to: r } = e; if (i == r) { let t = n(e); t < i ? (o = "delete.backward", t = cl(s, t, !1)) : t > i && (o = "delete.forward", t = cl(s, t, !0)), i = Math.min(i, t), r = Math.max(r, t) } else i = cl(s, i, !1), r = cl(s, r, !0); return i == r ? { range: e } : { changes: { from: i, to: r }, range: v.cursor(i, i < e.head ? -1 : 1) } }); return !e.changes.empty && (s.dispatch(t.update(e, { scrollIntoView: !0, userEvent: o, effects: "delete.selection" == o ? T.announce.of(t.phrase("Selection deleted")) : void 0 })), !0) } function cl(e, i, r) { if (e instanceof T) for (var t of e.state.facet(T.atomicRanges).map(t => t(e))) t.between(i, i, (t, e) => { t < i && i < e && (i = r ? e : t) }); return i } var dl = (a, h) => ll(a, t => { let e = t.from, i = a.state, r = i.doc.lineAt(e), s, n; if (!h && e > r.from && e < r.from + 200 && !/[^ \t]/.test(s = r.text.slice(0, e - r.from))) { if ("\t" == s[s.length - 1]) return e - 1; var o = oe(s, i.tabSize) % va(i) || va(i); for (let t = 0; t < o && " " == s[s.length - 1 - t]; t++)e--; n = e } else (n = u(r.text, e - r.from, h, h) + r.from) == e && r.number != (h ? i.doc.lines : 1) ? n += h ? 1 : -1 : !h && /[\ufe00-\ufe0f]/.test(r.text.slice(n - r.from, e - r.from)) && (n = u(r.text, n - r.from, !1, !1) + r.from); return n }), ul = t => dl(t, !1), fl = t => dl(t, !0), pl = (t, l) => ll(t, e => { let i = e.head, r = t.state, s = r.doc.lineAt(i); var n = r.charCategorizer(i); for (let t = null; ;) { if (i == (l ? s.to : s.from)) { i == e.head && s.number != (l ? r.doc.lines : 1) && (i += l ? 1 : -1); break } var o = u(s.text, i - s.from, l) + s.from, a = s.text.slice(Math.min(i, o) - s.from, Math.max(i, o) - s.from), h = n(a); if (null != t && h != t) break; " " == a && i == e.head || (t = h), i = o } return i }), ml = t => pl(t, !1); function gl(i) { let r = [], s = -1; for (var n of i.selection.ranges) { let t = i.doc.lineAt(n.from), e = i.doc.lineAt(n.to); var o; n.empty || n.to != e.from || (e = i.doc.lineAt(n.to - 1)), s >= t.number ? ((o = r[r.length - 1]).to = e.to, o.ranges.push(n)) : r.push({ from: t.from, to: e.to, ranges: [n] }), s = e.number + 1 } return r } function vl(t, e, i) { if (t.readOnly) return !1; var r, s = [], n = []; for (r of gl(t)) if (i ? r.to != t.doc.length : 0 != r.from) { var o = t.doc.lineAt(i ? r.to + 1 : r.from - 1), a = o.length + 1; if (i) { s.push({ from: r.to, to: o.to }, { from: r.from, insert: o.text + t.lineBreak }); for (var h of r.ranges) n.push(v.range(Math.min(t.doc.length, h.anchor + a), Math.min(t.doc.length, h.head + a))) } else { s.push({ from: o.from, to: r.from }, { from: r.to, insert: t.lineBreak + o.text }); for (var l of r.ranges) n.push(v.range(l.anchor - a, l.head - a)) } } return !!s.length && (e(t.update({ changes: s, scrollIntoView: !0, selection: v.create(n, t.selection.mainIndex), userEvent: "move.line" })), !0) } function wl(t, e, i) { if (t.readOnly) return !1; var r, s = []; for (r of gl(t)) s.push(i ? { from: r.from, insert: t.doc.slice(r.from, r.to) + t.lineBreak } : { from: r.to, insert: t.lineBreak + t.doc.slice(r.from, r.to) }); return e(t.update({ changes: s, scrollIntoView: !0, userEvent: "input.copyline" })), !0 } function bl(h) { return ({ state: a, dispatch: t }) => { var e; return !a.readOnly && (e = a.changeByRange(t => { let { from: e, to: i } = t, r = a.doc.lineAt(e); var t = !h && e == i && ((t, e) => { if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1))) return { from: e, to: e }; var i = P(t).resolveInner(e); let r = i.childBefore(e), s = i.childAfter(e), n; return r && s && r.to <= e && s.from >= e && (n = r.type.prop(_.closedBy)) && -1 < n.indexOf(s.name) && t.doc.lineAt(r.to).from == t.doc.lineAt(s.from).from && !/\S/.test(t.sliceDoc(r.to, s.from)) ? { from: r.to, to: s.from } : null })(a, e), s = (h && (e = i = (i <= r.to ? r : a.doc.lineAt(i)).to), new ya(a, { simulateBreak: e, simulateDoubleBreak: !!t })); let n = ba(s, e); for (null == n && (n = oe(/^\s*/.exec(a.doc.lineAt(e).text)[0], a.tabSize)); i < r.to && /\s/.test(r.text[i - r.from]);)i++; t ? { from: e, to: i } = t : e > r.from && e < r.from + 100 && !/\S/.test(r.text.slice(0, e)) && (e = r.from); var o = ["", wa(a, n)]; return t && o.push(wa(a, s.lineIndent(r.from, -1))), { changes: { from: e, to: i, insert: g.of(o) }, range: v.cursor(e + 1 + o[1].length) } }), t(a.update(e, { scrollIntoView: !0, userEvent: "input" })), !0) } } function yl(s, n) { let o = -1; return s.changeByRange(e => { var i = []; for (let t = e.from; t <= e.to;) { var r = s.doc.lineAt(t); r.number > o && (e.empty || e.to > r.from) && (n(r, i, e), o = r.number), t = r.to + 1 } var t = s.changes(i); return { changes: i, range: v.range(t.mapPos(e.anchor, 1), t.mapPos(e.head, 1)) } }) } var xl = ({ state: i, dispatch: t }) => !i.readOnly && (t(i.update(yl(i, (t, e) => { e.push({ from: t.from, insert: i.facet(ga) }) }), { userEvent: "input.indent" })), !0), kl = ({ state: o, dispatch: t }) => !o.readOnly && (t(o.update(yl(o, (i, r) => { var s = /^\s*/.exec(i.text)[0]; if (s) { let t = oe(s, o.tabSize), e = 0; for (var n = wa(o, Math.max(0, t - va(o))); e < s.length && e < n.length && s.charCodeAt(e) == n.charCodeAt(e);)e++; r.push({ from: i.from + e, to: i.from + s.length, insert: n.slice(e) }) } }), { userEvent: "delete.dedent" })), !0), Sl = [{ key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: e => Kh(e, t => Jh(e.state, t, !o(e))), shift: e => rl(e, t => Jh(e.state, t, !o(e))) }, { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: e => Kh(e, t => Jh(e.state, t, o(e))), shift: e => rl(e, t => Jh(e.state, t, o(e))) }, { key: "Alt-ArrowUp", run: ({ state: t, dispatch: e }) => vl(t, e, !1) }, { key: "Shift-Alt-ArrowUp", run: ({ state: t, dispatch: e }) => wl(t, e, !1) }, { key: "Alt-ArrowDown", run: ({ state: t, dispatch: e }) => vl(t, e, !0) }, { key: "Shift-Alt-ArrowDown", run: ({ state: t, dispatch: e }) => wl(t, e, !0) }, { key: "Escape", run: ({ state: t, dispatch: e }) => { let i = t.selection, r = null; return 1 < i.ranges.length ? r = v.create([i.main]) : i.main.empty || (r = v.create([v.cursor(i.main.head)])), !!r && (e($h(t, r)), !0) } }, { key: "Mod-Enter", run: bl(!0) }, { key: "Alt-l", mac: "Ctrl-l", run: ({ state: i, dispatch: t }) => { var e = gl(i).map(({ from: t, to: e }) => v.range(t, Math.min(e + 1, i.doc.length))); return t(i.update({ selection: v.create(e), userEvent: "select" })), !0 } }, { key: "Mod-i", run: ({ state: s, dispatch: t }) => { var e = Qh(s.selection, e => { var i; for (let t = P(s).resolveStack(e.from, 1); t; t = t.next) { var r = t.node; if ((r.from < e.from && r.to >= e.to || r.to > e.to && r.from <= e.from) && null != (i = r.parent) && i.parent) return v.range(r.to, r.from) } return e }); return t($h(s, e)), !0 }, preventDefault: !0 }, { key: "Mod-[", run: kl }, { key: "Mod-]", run: xl }, { key: "Mod-Alt-\\", run: ({ state: o, dispatch: t }) => { if (o.readOnly) return !1; let a = Object.create(null), h = new ya(o, { overrideIndentation: t => { t = a[t]; return null == t ? -1 : t } }); var e = yl(o, (t, e, i) => { let r = ba(h, t.from); var s, n; null != r && (/\S/.test(t.text) || (r = 0), (s = /^\s*/.exec(t.text)[0]) != (n = wa(o, r)) || i.from < t.from + s.length) && (a[t.from] = r, e.push({ from: t.from, to: t.from + s.length, insert: n })) }); return e.changes.empty || t(o.update(e, { userEvent: "indent" })), !0 } }, { key: "Shift-Mod-k", run: e => { if (e.state.readOnly) return !1; let i = e.state, t = i.changes(gl(i).map(({ from: t, to: e }) => (0 < t ? t-- : e < i.doc.length && e++, { from: t, to: e }))); var r = Qh(i.selection, t => e.moveVertically(t, !0)).map(t); return e.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0 } }, { key: "Shift-Mod-\\", run: ({ state: e, dispatch: r }) => { { var s = e, n = (e = r, !1); let i = !1, t = Qh(s.selection, t => { var e = dh(s, t.head, -1) || dh(s, t.head, 1) || 0 < t.head && dh(s, t.head - 1, 1) || t.head < s.doc.length && dh(s, t.head + 1, -1); if (!e || !e.end) return t; i = !0; e = e.start.from == t.head ? e.end.to : e.end.from; return n ? v.range(t.anchor, e) : v.cursor(e) }); return !!i && (e($h(s, t)), !0) } } }, { key: "Mod-/", run: t => { var e = t.state, e = e.doc.lineAt(e.selection.main.from), e = Ch(t.state, e.from); return e.line ? kh(t) : !!e.block && Sh(t) } }, { key: "Alt-A", run: Ue }].concat([{ key: "ArrowLeft", run: r, shift: Xo, preventDefault: !0 }, { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: t => Yh(t, !o(t)), shift: t => nl(t, !o(t)), preventDefault: !0 }, { mac: "Cmd-ArrowLeft", run: e => Kh(e, t => il(e, t, !o(e))), shift: e => rl(e, t => il(e, t, !o(e))), preventDefault: !0 }, { key: "ArrowRight", run: i, shift: s, preventDefault: !0 }, { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: t => Yh(t, o(t)), shift: t => nl(t, o(t)), preventDefault: !0 }, { mac: "Cmd-ArrowRight", run: e => Kh(e, t => il(e, t, o(e))), shift: e => rl(e, t => il(e, t, o(e))), preventDefault: !0 }, { key: "ArrowUp", run: Go, shift: e, preventDefault: !0 }, { mac: "Cmd-ArrowUp", run: _e, shift: je }, { mac: "Ctrl-ArrowUp", run: Yo, shift: Xe }, { key: "ArrowDown", run: n, shift: Zo, preventDefault: !0 }, { mac: "Cmd-ArrowDown", run: Ke, shift: hl }, { mac: "Ctrl-ArrowDown", run: Jo, shift: $e }, { key: "PageUp", run: Yo, shift: Xe }, { key: "PageDown", run: Jo, shift: $e }, { key: "Home", run: e => Kh(e, t => il(e, t, !1)), shift: e => rl(e, t => il(e, t, !1)), preventDefault: !0 }, { key: "Mod-Home", run: _e, shift: je }, { key: "End", run: e => Kh(e, t => il(e, t, !0)), shift: e => rl(e, t => il(e, t, !0)), preventDefault: !0 }, { key: "Mod-End", run: Ke, shift: hl }, { key: "Enter", run: bl(!1) }, { key: "Mod-a", run: ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0) }, { key: "Backspace", run: ul, shift: ul }, { key: "Delete", run: fl }, { key: "Mod-Backspace", mac: "Alt-Backspace", run: ml }, { key: "Mod-Delete", mac: "Alt-Delete", run: t => pl(t, !0) }, { mac: "Mod-Backspace", run: i => ll(i, t => { var e = i.moveToLineBoundary(t, !1).head; return t.head > e ? e : Math.max(0, t.head - 1) }) }, { mac: "Mod-Delete", run: i => ll(i, t => { var e = i.moveToLineBoundary(t, !0).head; return t.head < e ? e : Math.min(i.state.doc.length, t.head + 1) }) }].concat([{ key: "Ctrl-b", run: r, shift: Xo, preventDefault: !0 }, { key: "Ctrl-f", run: i, shift: s }, { key: "Ctrl-p", run: Go, shift: e }, { key: "Ctrl-n", run: n, shift: Zo }, { key: "Ctrl-a", run: e => Kh(e, t => v.cursor(e.lineBlockAt(t.head).from, 1)), shift: e => rl(e, t => v.cursor(e.lineBlockAt(t.head).from)) }, { key: "Ctrl-e", run: e => Kh(e, t => v.cursor(e.lineBlockAt(t.head).to, -1)), shift: e => rl(e, t => v.cursor(e.lineBlockAt(t.head).to)) }, { key: "Ctrl-d", run: fl }, { key: "Ctrl-h", run: ul }, { key: "Ctrl-k", run: i => ll(i, t => { var e = i.lineBlockAt(t.head).to; return t.head < e ? e : Math.min(i.state.doc.length, t.head + 1) }) }, { key: "Ctrl-Alt-h", run: ml }, { key: "Ctrl-o", run: ({ state: t, dispatch: e }) => { var i; return !t.readOnly && (i = t.changeByRange(t => ({ changes: { from: t.from, to: t.to, insert: g.of(["", ""]) }, range: v.cursor(t.from) })), e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0) } }, { key: "Ctrl-t", run: ({ state: s, dispatch: t }) => { var e; return !s.readOnly && !(e = s.changeByRange(t => { var e, i, r; return t.empty && 0 != t.from && t.from != s.doc.length ? { changes: { from: i = (e = t.from) == (r = s.doc.lineAt(e)).from ? e - 1 : u(r.text, e - r.from, !1) + r.from, to: r = e == r.to ? e + 1 : u(r.text, e - r.from, !0) + r.from, insert: s.doc.slice(e, r).append(s.doc.slice(i, e)) }, range: v.cursor(r) } : { range: t } })).changes.empty && (t(s.update(e, { scrollIntoView: !0, userEvent: "move.character" })), !0) } }, { key: "Ctrl-v", run: Jo }].map(t => ({ mac: t.key, run: t.run, shift: t.shift })))), Cl = { key: "Tab", run: xl, shift: kl }; function R(t, e) { var i, r = t, s = ("string" == typeof r && (r = document.createElement(r)), 1), n = e; if (n && "object" == typeof n && null == n.nodeType && !Array.isArray(n)) { for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && ("string" == typeof (i = n[o]) ? r.setAttribute(o, i) : null != i && (r[o] = i)); s++ } for (; s < arguments.length; s++)!function t(e, i) { if ("string" == typeof i) e.appendChild(document.createTextNode(i)); else if (null != i) if (null != i.nodeType) e.appendChild(i); else { if (!Array.isArray(i)) throw new RangeError("Unsupported child node: " + i); for (var r = 0; r < i.length; r++)t(e, i[r]) } }(r, arguments[s]); return r } var Al = "function" == typeof String.prototype.normalize ? t => t.normalize("NFKD") : t => t, Ol = class { constructor(t, e, i = 0, r = t.length, s, n) { this.test = n, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = t.iterRange(i, r), this.bufferStart = i, this.normalize = s ? t => s(Al(t)) : Al, this.query = this.normalize(e) } peek() { if (this.bufferPos == this.buffer.length) { if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done) return -1; this.bufferPos = 0, this.buffer = this.iter.value } return S(this.buffer, this.bufferPos) } next() { for (; this.matches.length;)this.matches.pop(); return this.nextOverlapping() } nextOverlapping() { for (; ;) { var t = this.peek(); if (t < 0) return this.done = !0, this; var i = J(t), r = this.bufferStart + this.bufferPos, s = (this.bufferPos += Z(t), this.normalize(i)); for (let t = 0, e = r; ; t++) { var n = s.charCodeAt(t), o = this.match(n, e); if (t == s.length - 1) { if (o) return this.value = o, this; break } e == r && t < i.length && i.charCodeAt(t) == n && e++ } } } match(r, s) { let n = null; for (let i = 0; i < this.matches.length; i += 2) { let t = this.matches[i], e = !1; this.query.charCodeAt(t) == r && (t == this.query.length - 1 ? n = { from: this.matches[i + 1], to: s + 1 } : (this.matches[i]++, e = !0)), e || (this.matches.splice(i, 2), i -= 2) } return this.query.charCodeAt(0) == r && (1 == this.query.length ? n = { from: s, to: s + 1 } : this.matches.push(1, s)), n = n && this.test && !this.test(n.from, n.to, this.buffer, this.bufferStart) ? null : n } }, Ml = ("undefined" != typeof Symbol && (Ol.prototype[Symbol.iterator] = function() { return this }), { from: -1, to: -1, match: /.*/.exec("") }), Tl = "gm" + (null == /x/.unicode ? "" : "u"), Dl = class { constructor(t, e, i, r = 0, s = t.length) { if (this.text = t, this.to = s, this.curLine = "", this.done = !1, this.value = Ml, /\\[sWDnr]|\n|\r|\[\^/.test(e)) return new Bl(t, e, i, r, s); this.re = new RegExp(e, Tl + (null != i && i.ignoreCase ? "i" : "")), this.test = null == i ? void 0 : i.test, this.iter = t.iter(); s = t.lineAt(r); this.curLineStart = s.from, this.matchPos = El(t, r), this.getLine(this.curLineStart) } getLine(t) { this.iter.next(t), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next()) } nextLine() { this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0) } next() { for (let t = this.matchPos - this.curLineStart; ;) { this.re.lastIndex = t; var e = this.matchPos <= this.to && this.re.exec(this.curLine); if (e) { var i = this.curLineStart + e.index, r = i + e[0].length; if (this.matchPos = El(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, e))) return this.value = { from: i, to: r, match: e }, this; t = this.matchPos - this.curLineStart } else { if (!(this.curLineStart + this.curLine.length < this.to)) return this.done = !0, this; this.nextLine(), t = 0 } } } }, Pl = new WeakMap, Rl = class Xf { constructor(t, e) { this.from = t, this.text = e } get to() { return this.from + this.text.length } static get(t, e, i) { var r, s = Pl.get(t); if (!s || s.from >= i || s.to <= e) return r = new Xf(e, t.sliceString(e, i)), Pl.set(t, r), r; if (s.from == e && s.to == i) return s; let { text: n, from: o } = s; return o > e && (n = t.sliceString(e, o) + n, o = e), s.to < i && (n += t.sliceString(s.to, i)), Pl.set(t, new Xf(o, n)), new Xf(e, n.slice(e - o, i - o)) } }, Bl = class { constructor(t, e, i, r, s) { this.text = t, this.to = s, this.done = !1, this.value = Ml, this.matchPos = El(t, r), this.re = new RegExp(e, Tl + (null != i && i.ignoreCase ? "i" : "")), this.test = null == i ? void 0 : i.test, this.flat = Rl.get(t, r, this.chunkEnd(r + 5e3)) } chunkEnd(t) { return (t >= this.to ? this : this.text.lineAt(t)).to } next() { for (; ;) { var e = this.re.lastIndex = this.matchPos - this.flat.from; let t = this.re.exec(this.flat.text); if (t && !t[0] && t.index == e && (this.re.lastIndex = 1 + e, t = this.re.exec(this.flat.text)), t) { var e = this.flat.from + t.index, i = e + t[0].length; if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(e, i, t))) return this.value = { from: e, to: i, match: t }, this.matchPos = El(this.text, i + (e == i ? 1 : 0)), this } if (this.flat.to == this.to) return this.done = !0, this; this.flat = Rl.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + 2 * this.flat.text.length)) } } }; function El(i, r) { if (!(r >= i.length)) { let t = i.lineAt(r), e; for (; r < t.to && 56320 <= (e = t.text.charCodeAt(r - t.from)) && e < 57344;)r++ } return r } function Ll(a) { let e = R("input", { class: "cm-textfield", name: "line", value: String(a.state.doc.lineAt(a.state.selection.main.head).number) }); function i() { var i = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value); if (i) { var r = a.state, s = r.doc.lineAt(r.selection.main.head), [, i, t, n, o] = i, n = n ? +n.slice(1) : 0; let e = t ? +t : s.number; if (t && o) { let t = e / 100; i && (t = t * ("-" == i ? -1 : 1) + s.number / r.doc.lines), e = Math.round(r.doc.lines * t) } else t && i && (e = e * ("-" == i ? -1 : 1) + s.number); o = r.doc.line(Math.max(1, Math.min(r.doc.lines, e))), t = v.cursor(o.from + Math.max(0, Math.min(n, o.length))); a.dispatch({ effects: [Nl.of(!1), T.scrollIntoView(t.from, { y: "center" })], selection: t }), a.focus() } } return { dom: R("form", { class: "cm-gotoLine", onkeydown: t => { 27 == t.keyCode ? (t.preventDefault(), a.dispatch({ effects: Nl.of(!1) }), a.focus()) : 13 == t.keyCode && (t.preventDefault(), i()) }, onsubmit: t => { t.preventDefault(), i() } }, R("label", a.state.phrase("Go to line"), ": ", e), " ", R("button", { class: "cm-button", type: "submit" }, a.state.phrase("go"))) } } "undefined" != typeof Symbol && (Dl.prototype[Symbol.iterator] = Bl.prototype[Symbol.iterator] = function() { return this }); var Nl = c.define(), Il = p.define({ create() { return !0 }, update(t, e) { for (var i of e.effects) i.is(Nl) && (t = i.value); return t }, provide: t => Un.from(t, t => t ? Ll : null) }), Vl = T.baseTheme({ ".cm-panel.cm-gotoLine": { padding: "2px 6px 4px", "& label": { fontSize: "80%" } } }), Hl = { highlightWordAroundCursor: !1, minSelectionLength: 1, maxMatches: 100, wholeWords: !1 }, Wl = d.define({ combine(t) { return jt(t, Hl, { highlightWordAroundCursor: (t, e) => t || e, minSelectionLength: Math.min, maxMatches: Math.min }) } }); var zl = C.mark({ class: "cm-selectionMatch" }), Fl = C.mark({ class: "cm-selectionMatch cm-selectionMatch-main" }); function ql(t, e, i, r) { return !(0 != i && t(e.sliceDoc(i - 1, i)) == m.Word || r != e.doc.length && t(e.sliceDoc(r, r + 1)) == m.Word) } var _l = a.fromClass(class { constructor(t) { this.decorations = this.getDeco(t) } update(t) { (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view)) } getDeco(t) { var e, i, r, s = t.state.facet(Wl), n = t.state, o = n.selection; if (1 < o.ranges.length) return C.none; let a = o.main, h, l = null; if (a.empty) { if (!s.highlightWordAroundCursor) return C.none; var o = n.wordAt(a.head); if (!o) return C.none; l = n.charCategorizer(a.head), h = n.sliceDoc(o.from, o.to) } else { o = a.to - a.from; if (o < s.minSelectionLength || 200 < o) return C.none; if (s.wholeWords) { if (h = n.sliceDoc(a.from, a.to), !ql(l = n.charCategorizer(a.head), n, a.from, a.to) || (o = l, e = n, i = a.from, r = a.to, o(e.sliceDoc(i, i + 1)) != m.Word) || o(e.sliceDoc(r - 1, r)) != m.Word) return C.none } else if (!(h = n.sliceDoc(a.from, a.to).trim())) return C.none } var c, d = []; for (c of t.visibleRanges) for (var u = new Ol(n.doc, h, c.from, c.to); !u.next().done;) { var { from: f, to: p } = u.value; if ((!l || ql(l, n, f, p)) && (a.empty && f <= a.from && p >= a.to ? d.push(Fl.range(f, p)) : (f >= a.to || p <= a.from) && d.push(zl.range(f, p)), d.length > s.maxMatches)) return C.none } return C.set(d) } }, { decorations: t => t.decorations }), jl = T.baseTheme({ ".cm-selectionMatch": { backgroundColor: "#99ff7780" }, ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" } }); var Ul = d.define({ combine(t) { return jt(t, { top: !1, caseSensitive: !1, literal: !1, regexp: !1, wholeWord: !1, createPanel: t => new wc(t), scrollToMatch: t => T.scrollIntoView(t) }) } }), Ql = class { constructor(t) { this.search = t.search, this.caseSensitive = !!t.caseSensitive, this.literal = !!t.literal, this.regexp = !!t.regexp, this.replace = t.replace || "", this.valid = !!this.search && (!this.regexp || (t => { try { return new RegExp(t, Tl), !0 } catch (t) { return !1 } })(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!t.wholeWord } unquote(t) { return this.literal ? t : t.replace(/\\([nrt\\])/g, (t, e) => "n" == e ? "\n" : "r" == e ? "\r" : "t" == e ? "\t" : "\\") } eq(t) { return this.search == t.search && this.replace == t.replace && this.caseSensitive == t.caseSensitive && this.regexp == t.regexp && this.wholeWord == t.wholeWord } create() { return new (this.regexp ? Jl : Kl)(this) } getCursor(t, e = 0, i) { t = t.doc ? t : w.create({ doc: t }); return null == i && (i = t.doc.length), (this.regexp ? Xl : $l)(this, t, e, i) } }, Ue = class { constructor(t) { this.spec = t } }; function $l(t, e, i, r) { return new Ol(e.doc, t.unquoted, i, r, t.caseSensitive ? void 0 : t => t.toLowerCase(), t.wholeWord ? (s = e.doc, n = e.charCategorizer(e.selection.main.head), (t, e, i, r) => ((t < r || r + i.length < e) && (r = Math.max(0, t - 2), i = s.sliceString(r, Math.min(s.length, e + 2))), !(n(Gl(i, t - r)) == m.Word && n(Yl(i, t - r)) == m.Word || n(Yl(i, e - r)) == m.Word && n(Gl(i, e - r)) == m.Word))) : void 0); var s, n } var Kl = class extends Ue { constructor(t) { super(t) } nextMatch(t, e, i) { let r = $l(this.spec, t, i, t.doc.length).nextOverlapping(); return (r = r.done ? $l(this.spec, t, 0, e).nextOverlapping() : r).done ? null : r.value } prevMatchInRange(r, s, t) { for (let i = t; ;) { var n = Math.max(s, i - 1e4 - this.spec.unquoted.length); let t = $l(this.spec, r, n, i), e = null; for (; !t.nextOverlapping().done;)e = t.value; if (e) return e; if (n == s) return null; i -= 1e4 } } prevMatch(t, e, i) { return this.prevMatchInRange(t, 0, e) || this.prevMatchInRange(t, i, t.doc.length) } getReplacement(t) { return this.spec.unquote(this.spec.replace) } matchAll(t, e) { for (var i = $l(this.spec, t, 0, t.doc.length), r = []; !i.next().done;) { if (e <= r.length) return null; r.push(i.value) } return r } highlight(t, e, i, r) { for (var s = $l(this.spec, t, Math.max(0, e - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, t.doc.length)); !s.next().done;)r(s.value.from, s.value.to) } }; function Xl(t, e, i, r) { return new Dl(e.doc, t.search, { ignoreCase: !t.caseSensitive, test: t.wholeWord ? (s = e.charCategorizer(e.selection.main.head), (t, e, i) => !i[0].length || (s(Gl(i.input, i.index)) != m.Word || s(Yl(i.input, i.index)) != m.Word) && (s(Yl(i.input, i.index + i[0].length)) != m.Word || s(Gl(i.input, i.index + i[0].length)) != m.Word)) : void 0 }, i, r); var s } function Gl(t, e) { return t.slice(u(t, e, !1), e) } function Yl(t, e) { return t.slice(e, u(t, e)) } var Jl = class extends Ue { nextMatch(t, e, i) { let r = Xl(this.spec, t, i, t.doc.length).next(); return (r = r.done ? Xl(this.spec, t, 0, e).next() : r).done ? null : r.value } prevMatchInRange(r, s, n) { for (let i = 1; ; i++) { var o = Math.max(s, n - 1e4 * i); let t = Xl(this.spec, r, o, n), e = null; for (; !t.next().done;)e = t.value; if (e && (o == s || e.from > o + 10)) return e; if (o == s) return null } } prevMatch(t, e, i) { return this.prevMatchInRange(t, 0, e) || this.prevMatchInRange(t, i, t.doc.length) } getReplacement(i) { return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (t, e) => "$" == e ? "$" : "&" == e ? i.match[0] : "0" != e && +e < i.match.length ? i.match[e] : t) } matchAll(t, e) { for (var i = Xl(this.spec, t, 0, t.doc.length), r = []; !i.next().done;) { if (e <= r.length) return null; r.push(i.value) } return r } highlight(t, e, i, r) { for (var s = Xl(this.spec, t, Math.max(0, e - 250), Math.min(i + 250, t.doc.length)); !s.next().done;)r(s.value.from, s.value.to) } }, Zl = c.define(), tc = c.define(), ec = p.define({ create(t) { return new ic(uc(t).create(), null) }, update(t, e) { for (var i of e.effects) i.is(Zl) ? t = new ic(i.value.create(), t.panel) : i.is(tc) && (t = new ic(t.query, i.value ? dc : null)); return t }, provide: t => Un.from(t, t => t.panel) }), ic = class { constructor(t, e) { this.query = t, this.panel = e } }, rc = C.mark({ class: "cm-searchMatch" }), sc = C.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Yo = a.fromClass(class { constructor(t) { this.view = t, this.decorations = this.highlight(t.state.field(ec)) } update(t) { var e = t.state.field(ec); (e != t.startState.field(ec) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e)) } highlight({ query: n, panel: t }) { if (!t || !n.spec.valid) return C.none; let o = this.view, a = new Xt; for (let i = 0, r = o.visibleRanges, s = r.length; i < s; i++) { let { from: t, to: e } = r[i]; for (; i < s - 1 && e > r[i + 1].from - 500;)e = r[++i].to; n.highlight(o.state, t, e, (e, i) => { var t = o.state.selection.ranges.some(t => t.from == e && t.to == i); a.add(e, i, t ? sc : rc) }) } return a.finish() } }, { decorations: t => t.decorations }); function nc(i) { return t => { var e = t.state.field(ec, !1); return e && e.query.spec.valid ? i(t, e) : mc(t) } } var oc = nc((t, { query: e }) => { var i, r = t.state.selection.main.to, e = e.nextMatch(t.state, r, r); return !!e && (r = v.single(e.from, e.to), i = t.state.facet(Ul), t.dispatch({ selection: r, effects: [kc(t, e), i.scrollToMatch(r.main, t)], userEvent: "select.search" }), pc(t), !0) }), ac = nc((t, { query: e }) => { var i = t.state, r = i.selection.main.from, e = e.prevMatch(i, r, r); return !!e && (i = v.single(e.from, e.to), r = t.state.facet(Ul), t.dispatch({ selection: i, effects: [kc(t, e), r.scrollToMatch(i.main, t)], userEvent: "select.search" }), pc(t), !0) }), hc = nc((t, { query: e }) => { e = e.matchAll(t.state, 1e3); return !(!e || !e.length || (t.dispatch({ selection: v.create(e.map(t => v.range(t.from, t.to))), userEvent: "select.search.matches" }), 0)) }), lc = nc((t, { query: e }) => { var i = t.state, { from: r, to: s } = i.selection.main; if (i.readOnly) return !1; let n = e.nextMatch(i, r, r); if (!n) return !1; let o = [], a, h; var l = []; return n.from == r && n.to == s && (h = i.toText(e.getReplacement(n)), o.push({ from: n.from, to: n.to, insert: h }), n = e.nextMatch(i, n.from, n.to), l.push(T.announce.of(i.phrase("replaced match on line $", i.doc.lineAt(r).number) + "."))), n && (s = 0 == o.length || o[0].from >= n.to ? 0 : n.to - n.from - h.length, a = v.single(n.from - s, n.to - s), l.push(kc(t, n)), l.push(i.facet(Ul).scrollToMatch(a.main, t))), t.dispatch({ changes: o, selection: a, effects: l, userEvent: "input.replace" }), !0 }), cc = nc((t, { query: r }) => { var e, i; return !t.state.readOnly && !!(e = r.matchAll(t.state, 1e9).map(t => { var { from: e, to: i } = t; return { from: e, to: i, insert: r.getReplacement(t) } })).length && (i = t.state.phrase("replaced $ matches", e.length) + ".", t.dispatch({ changes: e, effects: T.announce.of(i), userEvent: "input.replace.all" }), !0) }); function dc(t) { return t.state.facet(Ul).createPanel(t) } function uc(t, e) { var i, r = t.selection.main, r = r.empty || r.to > r.from + 100 ? "" : t.sliceDoc(r.from, r.to); return e && !r ? e : (t = t.facet(Ul), new Ql({ search: (null != (i = null == e ? void 0 : e.literal) ? i : t.literal) ? r : r.replace(/\n/g, "\\n"), caseSensitive: null != (i = null == e ? void 0 : e.caseSensitive) ? i : t.caseSensitive, literal: null != (r = null == e ? void 0 : e.literal) ? r : t.literal, regexp: null != (i = null == e ? void 0 : e.regexp) ? i : t.regexp, wholeWord: null != (r = null == e ? void 0 : e.wholeWord) ? r : t.wholeWord })) } function fc(t) { t = Fn(t, dc); return t && t.dom.querySelector("[main-field]") } function pc(t) { var e = fc(t); e && e == t.root.activeElement && e.select() } var mc = t => { var e, i, r = t.state.field(ec, !1); return r && r.panel ? (e = fc(t)) && e != t.root.activeElement && ((i = uc(t.state, r.query.spec)).valid && t.dispatch({ effects: Zl.of(i) }), e.focus(), e.select()) : t.dispatch({ effects: [tc.of(!0), r ? Zl.of(uc(t.state, r.query.spec)) : c.appendConfig.of(Sc)] }), !0 }, gc = t => { var e = t.state.field(ec, !1); return !(!e || !e.panel || ((e = Fn(t, dc)) && e.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: tc.of(!1) }), 0)) }, vc = [{ key: "Mod-f", run: mc, scope: "editor search-panel" }, { key: "F3", run: oc, shift: ac, scope: "editor search-panel", preventDefault: !0 }, { key: "Mod-g", run: oc, shift: ac, scope: "editor search-panel", preventDefault: !0 }, { key: "Escape", run: gc, scope: "editor search-panel" }, { key: "Mod-Shift-l", run: ({ state: t, dispatch: e }) => { var i = t.selection; if (1 < i.ranges.length || i.main.empty) return !1; var { from: r, to: i } = i.main; let s = [], n = 0; for (var o = new Ol(t.doc, t.sliceDoc(r, i)); !o.next().done;) { if (1e3 < s.length) return !1; o.value.from == r && (n = s.length), s.push(v.range(o.value.from, o.value.to)) } return e(t.update({ selection: v.create(s, n), userEvent: "select.search.matches" })), !0 } }, { key: "Mod-Alt-g", run: t => { let e = Fn(t, Ll); var i; return e || (i = [Nl.of(!0)], null == t.state.field(Il, !1) && i.push(c.appendConfig.of([Il, Vl])), t.dispatch({ effects: i }), e = Fn(t, Ll)), e && e.dom.querySelector("input").select(), !0 } }, { key: "Mod-d", run: ({ state: e, dispatch: t }) => { var i, r, s, n, o = e.selection.ranges; if (o.some(t => t.from === t.to)) return { state: i, dispatch: r } = [{ state: e, dispatch: t }][0], n = i.selection, !(s = v.create(n.ranges.map(t => i.wordAt(t.head) || v.cursor(t.head)), n.mainIndex)).eq(n) && (r(i.update({ selection: s })), !0); let a = e.sliceDoc(o[0].from, o[0].to); return !e.selection.ranges.some(t => e.sliceDoc(t.from, t.to) != a) && !!(n = ((i, r) => { var { main: t, ranges: s } = i.selection, e = i.wordAt(t.head), n = e && e.from == t.from && e.to == t.to; for (let t = !1, e = new Ol(i.doc, r, s[s.length - 1].to); ;)if (e.next(), e.done) { if (t) return null; e = new Ol(i.doc, r, 0, Math.max(0, s[s.length - 1].from - 1)), t = !0 } else if (!t || !s.some(t => t.from == e.value.from)) { if (n) { var o = i.wordAt(e.value.from); if (!o || o.from != e.value.from || o.to != e.value.to) continue } return e.value } })(e, a)) && (t(e.update({ selection: e.selection.addRange(v.range(n.from, n.to), !1), effects: T.scrollIntoView(n.to) })), !0) }, preventDefault: !0 }], wc = class { constructor(t) { this.view = t; var e = this.query = t.state.field(ec).query.spec; function i(t, e, i) { return R("button", { class: "cm-button", name: t, onclick: e, type: "button" }, i) } this.commit = this.commit.bind(this), this.searchField = R("input", { value: e.search, placeholder: bc(t, "Find"), "aria-label": bc(t, "Find"), class: "cm-textfield", name: "search", form: "", "main-field": "true", onchange: this.commit, onkeyup: this.commit }), this.replaceField = R("input", { value: e.replace, placeholder: bc(t, "Replace"), "aria-label": bc(t, "Replace"), class: "cm-textfield", name: "replace", form: "", onchange: this.commit, onkeyup: this.commit }), this.caseField = R("input", { type: "checkbox", name: "case", form: "", checked: e.caseSensitive, onchange: this.commit }), this.reField = R("input", { type: "checkbox", name: "re", form: "", checked: e.regexp, onchange: this.commit }), this.wordField = R("input", { type: "checkbox", name: "word", form: "", checked: e.wholeWord, onchange: this.commit }), this.dom = R("div", { onkeydown: t => this.keydown(t), class: "cm-search" }, [this.searchField, i("next", () => oc(t), [bc(t, "next")]), i("prev", () => ac(t), [bc(t, "previous")]), i("select", () => hc(t), [bc(t, "all")]), R("label", null, [this.caseField, bc(t, "match case")]), R("label", null, [this.reField, bc(t, "regexp")]), R("label", null, [this.wordField, bc(t, "by word")]), ...t.state.readOnly ? [] : [R("br"), this.replaceField, i("replace", () => lc(t), [bc(t, "replace")]), i("replaceAll", () => cc(t), [bc(t, "replace all")])], R("button", { name: "close", onclick: () => gc(t), "aria-label": bc(t, "close"), type: "button" }, ["Ã—"])]) } commit() { var t = new Ql({ search: this.searchField.value, caseSensitive: this.caseField.checked, regexp: this.reField.checked, wholeWord: this.wordField.checked, replace: this.replaceField.value }); t.eq(this.query) || (this.query = t, this.view.dispatch({ effects: Zl.of(t) })) } keydown(t) { var e, i, r; e = this.view, i = t, r = "search-panel", qs(Ws(e.state), i, e, r) ? t.preventDefault() : 13 == t.keyCode && t.target == this.searchField ? (t.preventDefault(), (t.shiftKey ? ac : oc)(this.view)) : 13 == t.keyCode && t.target == this.replaceField && (t.preventDefault(), lc(this.view)) } update(t) { for (var e of t.transactions) for (var i of e.effects) i.is(Zl) && !i.value.eq(this.query) && this.setQuery(i.value) } setQuery(t) { this.query = t, this.searchField.value = t.search, this.replaceField.value = t.replace, this.caseField.checked = t.caseSensitive, this.reField.checked = t.regexp, this.wordField.checked = t.wholeWord } mount() { this.searchField.select() } get pos() { return 80 } get top() { return this.view.state.facet(Ul).top } }; function bc(t, e) { return t.state.phrase(e) } var yc = 30, xc = /[\s\.,:;?!]/; function kc(t, { from: e, to: i }) { var r = t.state.doc.lineAt(e), s = t.state.doc.lineAt(i).to, e = Math.max(r.from, e - yc), i = Math.min(s, i + yc); let n = t.state.sliceDoc(e, i); if (e != r.from) for (let t = 0; t < yc; t++)if (!xc.test(n[t + 1]) && xc.test(n[t])) { n = n.slice(t); break } if (i != s) for (let t = n.length - 1; t > n.length - yc; t--)if (!xc.test(n[t - 1]) && xc.test(n[t])) { n = n.slice(0, t); break } return T.announce.of(`${t.state.phrase("current match")}. ${n} ${t.state.phrase("on line")} ${r.number}.`) } var Xe = T.baseTheme({ ".cm-panel.cm-search": { padding: "2px 6px 4px", position: "relative", "& [name=close]": { position: "absolute", top: "0", right: "4px", backgroundColor: "inherit", border: "none", font: "inherit", padding: 0, margin: 0 }, "& input, & button, & label": { margin: ".2em .6em .2em 0" }, "& input[type=checkbox]": { marginRight: ".2em" }, "& label": { fontSize: "80%", whiteSpace: "pre" } }, "&light .cm-searchMatch": { backgroundColor: "#ffff0054" }, "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" }, "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" }, "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" } }), Sc = [ec, wt.low(Yo), Xe], Cc = class { constructor(t, e, i) { this.state = t, this.pos = e, this.explicit = i, this.abortListeners = [] } tokenBefore(t) { let e = P(this.state).resolveInner(this.pos, -1); for (; e && t.indexOf(e.name) < 0;)e = e.parent; return e ? { from: e.from, to: this.pos, text: this.state.sliceDoc(e.from, this.pos), type: e.type } : null } matchBefore(t) { var e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), e = e.text.slice(i - e.from, this.pos - e.from), t = e.search(Dc(t, !1)); return t < 0 ? null : { from: i + t, to: this.pos, text: e.slice(t) } } get aborted() { return null == this.abortListeners } addEventListener(t, e) { "abort" == t && this.abortListeners && this.abortListeners.push(e) } }; function Ac(t) { let e = Object.keys(t).join(""); t = /\w/.test(e); return `[${t ? "\\w" : ""}${(e = t ? e.replace(/\w/g, "") : e).replace(/[^\w\s]/g, "\\$&")}]` } function Oc(t) { let i = t.map(t => "string" == typeof t ? { label: t } : t), [r, s] = i.every(t => /^\w+$/.test(t.label)) ? [/\w*$/, /\w+$/] : (t => { var e, i = Object.create(null), r = Object.create(null); for ({ label: e } of t) { i[e[0]] = !0; for (let t = 1; t < e.length; t++)r[e[t]] = !0 } return t = Ac(i) + Ac(r) + "*$", [new RegExp("^" + t), new RegExp(t)] })(i); return t => { var e = t.matchBefore(s); return e || t.explicit ? { from: e ? e.from : t.pos, options: i, validFor: r } : null } } var Mc = class { constructor(t, e, i, r) { this.completion = t, this.source = e, this.match = i, this.score = r } }; function Tc(t) { return t.selection.main.from } function Dc(t, e) { var i = t.source, e = e && "^" != i[0], r = "$" != i[i.length - 1]; return e || r ? new RegExp(`${e ? "^" : ""}(?:${i})` + (r ? "$" : ""), null != (e = t.flags) ? e : t.ignoreCase ? "i" : "") : t } var Pc = Bt.define(); var Rc = new WeakMap; function Bc(t) { if (!Array.isArray(t)) return t; let e = Rc.get(t); return e || Rc.set(t, e = Oc(t)), e } var Ec = c.define(), Lc = c.define(), Nc = class { constructor(e) { this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = []; for (let t = 0; t < e.length;) { var i = S(e, t), r = Z(i), i = (this.chars.push(i), e.slice(t, t + r)), s = i.toUpperCase(); this.folded.push(S(s == i ? i.toLowerCase() : s, 0)), t += r } this.astral = e.length != this.chars.length } ret(t, e) { return this.score = t, this.matched = e, !0 } match(r) { if (0 == this.pattern.length) return this.ret(-100, []); if (r.length < this.pattern.length) return !1; var { chars: s, folded: n, any: i, precise: o, byWord: a } = this; if (1 == s.length) { var e = S(r, 0), h = Z(e); let t = h == r.length ? 0 : -100; if (e != s[0]) { if (e != n[0]) return !1; t += -200 } return this.ret(t, [0, h]) } var l = r.indexOf(this.pattern); if (0 == l) return this.ret(r.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]); let c = s.length, d = 0; if (l < 0) { for (let t = 0, e = Math.min(r.length, 200); t < e && d < c;) { var u = S(r, t); u != s[d] && u != n[d] || (i[d++] = t), t += Z(u) } if (d < c) return !1 } let f = 0, p = 0, m = !1, g = 0, v = -1, w = -1, b = /[a-z]/.test(r), y = !0; for (let t = 0, e = Math.min(r.length, 200), i = 0; t < e && p < c;) { var x = S(r, t); l < 0 && (f < c && x == s[f] && (o[f++] = t), g < c) && (x == s[g] || x == n[g] ? (0 == g && (v = t), w = t + 1, g++) : g = 0); var k = x < 255 ? 48 <= x && x <= 57 || 97 <= x && x <= 122 ? 2 : 65 <= x && x <= 90 ? 1 : 0 : (k = J(x)) != k.toLowerCase() ? 1 : k != k.toUpperCase() ? 2 : 0; (!t || 1 == k && b || 0 == i && 0 != k) && (s[p] == x || n[p] == x && (m = !0) ? a[p++] = t : a.length && (y = !1)), i = k, t += Z(x) } return p == c && 0 == a[0] && y ? this.result((m ? -200 : 0) - 100, a, r) : g == c && 0 == v ? this.ret(-200 - r.length + (w == r.length ? 0 : -100), [0, w]) : -1 < l ? this.ret(-700 - r.length, [l, l + this.pattern.length]) : g == c ? this.ret(-900 - r.length, [v, w]) : p == c ? this.result((m ? -200 : 0) - 100 - 700 + (y ? 0 : -1100), a, r) : 2 != s.length && this.result((i[0] ? -700 : 0) - 200 - 1100, i, r) } result(t, e, i) { let r = [], s = 0; for (var n of e) { var o = n + (this.astral ? Z(S(i, n)) : 1); s && r[s - 1] == n ? r[s - 1] = o : (r[s++] = n, r[s++] = o) } return this.ret(t - i.length, r) } }, B = d.define({ combine(t) { return jt(t, { activateOnTyping: !0, selectOnOpen: !0, override: null, closeOnBlur: !0, maxRenderedOptions: 100, defaultKeymap: !0, tooltipClass: () => "", optionClass: () => "", aboveCursor: !1, icons: !0, addToOptions: [], positionInfo: Vc, compareCompletions: (t, e) => t.label.localeCompare(e.label), interactionDelay: 75, updateSyncTime: 100 }, { defaultKeymap: (t, e) => t && e, closeOnBlur: (t, e) => t && e, icons: (t, e) => t && e, tooltipClass: (e, i) => t => Ic(e(t), i(t)), optionClass: (e, i) => t => Ic(e(t), i(t)), addToOptions: (t, e) => t.concat(e) }) } }); function Ic(t, e) { return t ? e ? t + " " + e : t : e } function Vc(t, e, i, r, s, n) { let o = t.textDirection == O.RTL, a = o, h = !1, l = "top", c, d; var t = e.left - s.left, u = s.right - e.right, f = r.right - r.left, r = r.bottom - r.top, t = (a && t < Math.min(f, u) ? a = !1 : !a && u < Math.min(f, t) && (a = !0), f <= (a ? t : u) ? (c = Math.max(s.top, Math.min(i.top, s.bottom - r)) - e.top, d = Math.min(400, a ? t : u)) : (h = !0, d = Math.min(400, (o ? e.right : s.right - e.left) - 30), f = s.bottom - e.bottom, c = r <= f || f > e.top ? i.bottom - e.top : (l = "bottom", e.bottom - i.top)), (e.bottom - e.top) / n.offsetHeight); return { style: `${l}: ${c / t}px; max-width: ${d / ((e.right - e.left) / n.offsetWidth)}px`, class: "cm-completionInfo-" + (h ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right") } } function Hc(t, e, i) { var r; return t <= i ? { from: 0, to: t } : (e = e < 0 ? 0 : e) <= t >> 1 ? { from: (r = Math.floor(e / i)) * i, to: (r + 1) * i } : { from: t - ((r = Math.floor((t - e) / i)) + 1) * i, to: t - r * i } } var Wc = class { constructor(s, t, e) { this.view = s, this.stateField = t, this.applyCompletion = e, this.info = null, this.infoDestroy = null, this.placeInfoReq = { read: () => this.measureInfo(), write: t => this.placeInfo(t), key: this }, this.space = null, this.currentClass = ""; var i, r, e = s.state.field(t), { options: n, selected: o } = e.open, a = s.state.facet(B); this.optionContent = (r = (i = a).addToOptions.slice(), i.icons && r.push({ render(t) { var e = document.createElement("div"); return e.classList.add("cm-completionIcon"), t.type && e.classList.add(...t.type.split(/\s+/g).map(t => "cm-completionIcon-" + t)), e.setAttribute("aria-hidden", "true"), e }, position: 20 }), r.push({ render(t, e, i, r) { var s = document.createElement("span"); s.className = "cm-completionLabel"; let n = t.displayLabel || t.label, o = 0; for (let t = 0; t < r.length;) { var a = r[t++], h = r[t++], l = (a > o && s.appendChild(document.createTextNode(n.slice(o, a))), s.appendChild(document.createElement("span"))); l.appendChild(document.createTextNode(n.slice(a, h))), l.className = "cm-completionMatchedText", o = h } return o < n.length && s.appendChild(document.createTextNode(n.slice(o))), s }, position: 50 }, { render(t) { var e; return t.detail ? ((e = document.createElement("span")).className = "cm-completionDetail", e.textContent = t.detail, e) : null }, position: 80 }), r.sort((t, e) => t.position - e.position).map(t => t.render)), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Hc(n.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(s.state), this.dom.addEventListener("mousedown", i => { var r = s.state.field(t).open.options; for (let t = i.target, e; t && t != this.dom; t = t.parentNode)if ("LI" == t.nodeName && (e = /-(\d+)$/.exec(t.id)) && +e[1] < r.length) return this.applyCompletion(s, r[+e[1]]), void i.preventDefault() }), this.dom.addEventListener("focusout", t => { var e = s.state.field(this.stateField, !1); e && e.tooltip && s.state.facet(B).closeOnBlur && t.relatedTarget != s.contentDOM && s.dispatch({ effects: Lc.of(null) }) }), this.showOptions(n, e.id) } mount() { this.updateSel() } showOptions(t, e) { this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => { this.info && this.view.requestMeasure(this.placeInfoReq) }) } update(t) { var e, i, r, s = t.state.field(this.stateField), n = t.startState.field(this.stateField); this.updateTooltipClass(t.state), s != n && ({ options: e, selected: i, disabled: r } = s.open, n.open && n.open.options == e || (this.range = Hc(e.length, i, t.state.facet(B).maxRenderedOptions), this.showOptions(e, s.id)), this.updateSel(), r != (null == (i = n.open) ? void 0 : i.disabled)) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!r) } updateTooltipClass(t) { t = this.tooltipClass(t); if (t != this.currentClass) { for (var e of this.currentClass.split(" ")) e && this.dom.classList.remove(e); for (var i of t.split(" ")) i && this.dom.classList.add(i); this.currentClass = t } } positioned(t) { this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq) } updateSel() { let i = this.view.state.field(this.stateField), t = i.open; if ((-1 < t.selected && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Hc(t.options.length, t.selected, this.view.state.facet(B).maxRenderedOptions), this.showOptions(t.options, i.id)), this.updateSelectedOption(t.selected)) { this.destroyInfo(); let e = t.options[t.selected].completion; var r = e.info; r && (r = "string" == typeof r ? document.createTextNode(r) : r(e)) && ("then" in r ? r.then(t => { t && this.view.state.field(this.stateField, !1) == i && this.addInfoPane(t, e) }).catch(t => qi(this.view.state, t, "completion info")) : this.addInfoPane(r, e)) } } addInfoPane(t, e) { this.destroyInfo(); var i, r = this.info = document.createElement("div"); r.className = "cm-tooltip cm-completionInfo", null != t.nodeType ? (r.appendChild(t), this.infoDestroy = null) : ({ dom: t, destroy: i } = t, r.appendChild(t), this.infoDestroy = i || null), this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq) } updateSelectedOption(i) { let r = null; for (let t = this.list.firstChild, e = this.range.from; t; t = t.nextSibling, e++)"LI" == t.nodeName && t.id ? e == i ? t.hasAttribute("aria-selected") || (t.setAttribute("aria-selected", "true"), r = t) : t.hasAttribute("aria-selected") && t.removeAttribute("aria-selected") : e--; var t, e, s, n; return r && (t = this.list, e = r, s = t.getBoundingClientRect(), e = e.getBoundingClientRect(), n = s.height / t.offsetHeight, e.top < s.top ? t.scrollTop -= (s.top - e.top) / n : e.bottom > s.bottom && (t.scrollTop += (e.bottom - s.bottom) / n)), r } measureInfo() { var t = this.dom.querySelector("[aria-selected]"); if (!t || !this.info) return null; var e, i = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), t = t.getBoundingClientRect(); let s = this.space; return s || (e = this.dom.ownerDocument.defaultView || window, s = { left: 0, top: 0, right: e.innerWidth, bottom: e.innerHeight }), t.top > Math.min(s.bottom, i.bottom) - 10 || t.bottom < Math.max(s.top, i.top) + 10 ? null : this.view.state.facet(B).positionInfo(this.view, i, t, r, s, this.dom) } placeInfo(t) { this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px") } createListBox(e, i, r) { var s = document.createElement("ul"); s.id = i, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")); let n = null; for (let t = r.from; t < r.to; t++) { var o, a, { completion: h, match: l } = e[t], c = h.section, d = (c && (o = "string" == typeof c ? c : c.name) != n && (t > r.from || 0 == r.from) && (n = o, "string" != typeof c && c.header ? s.appendChild(c.header(c)) : s.appendChild(document.createElement("completion-section")).textContent = o), s.appendChild(document.createElement("li"))), c = (d.id = i + "-" + t, d.setAttribute("role", "option"), this.optionClass(h)); c && (d.className = c); for (a of this.optionContent) { var u = a(h, this.view.state, this.view, l); u && d.appendChild(u) } } return r.from && s.classList.add("cm-completionListIncompleteTop"), r.to < e.length && s.classList.add("cm-completionListIncompleteBottom"), s } destroyInfo() { this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null) } destroy() { this.destroyInfo() } }; function zc(e, i) { return t => new Wc(t, e, i) } function Fc(t) { return 100 * (t.boost || 0) + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0) } var qc = class Gf { constructor(t, e, i, r, s, n) { this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = r, this.selected = s, this.disabled = n } setSelected(t, e) { return t == this.selected || t >= this.options.length ? this : new Gf(this.options, Uc(e, t), this.tooltip, this.timestamp, t, this.disabled) } static build(t, e, i, r, s) { var n = ((t, e) => { let i = [], r = null; var s, n, o, a, h = t => { i.push(t); t = t.completion.section; if (t) { r = r || []; let e = "string" == typeof t ? t : t.name; r.some(t => t.name == e) || r.push("string" == typeof t ? { name: e } : t) } }; for (s of t) if (s.hasResult()) { var l = s.result.getMatch; if (!1 === s.result.filter) for (var c of s.result.options) h(new Mc(c, s.source, l ? l(c) : [], 1e9 - i.length)); else { var d, u, f = new Nc(e.sliceDoc(s.from, s.to)); for (d of s.result.options) f.match(d.label) && (u = d.displayLabel ? l ? l(d, f.matched) : [] : f.matched, h(new Mc(d, s.source, u, f.score + (d.boost || 0)))) } } if (r) { let t = Object.create(null), e = 0; for (o of r.sort((t, e) => { var i; return (null != (i = t.rank) ? i : 1e9) - (null != (i = e.rank) ? i : 1e9) || (t.name < e.name ? -1 : 1) })) e -= 1e5, t[o.name] = e; for (a of i) { var p = a.completion.section; p && (a.score += t["string" == typeof p ? p : p.name]) } } let m = [], g = null, v = e.facet(B).compareCompletions; for (n of i.sort((t, e) => e.score - t.score || v(t.completion, e.completion))) { var w = n.completion; !g || g.label != w.label || g.detail != w.detail || null != g.type && null != w.type && g.type != w.type || g.apply != w.apply || g.boost != w.boost ? m.push(n) : Fc(n.completion) > Fc(g) && (m[m.length - 1] = n), g = n.completion } return m })(t, e); if (!n.length) return r && t.some(t => 1 == t.state) ? new Gf(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0) : null; let o = e.facet(B).selectOnOpen ? 0 : -1; if (r && r.selected != o && -1 != r.selected) { var a = r.options[r.selected].completion; for (let t = 0; t < n.length; t++)if (n[t].completion == a) { o = t; break } } return new Gf(n, Uc(i, o), { pos: t.reduce((t, e) => e.hasResult() ? Math.min(t, e.from) : t, 1e8), create: td, above: s.aboveCursor }, r ? r.timestamp : Date.now(), o, !1) } map(t) { return new Gf(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled) } }, _c = class Yf { constructor(t, e, i) { this.active = t, this.id = e, this.open = i } static start() { return new Yf(Qc, "cm-ac-" + Math.floor(2e6 * Math.random()).toString(36), null) } update(i) { let t = i.state, r = t.facet(B); var e; let s = (r.override || t.languageDataAt("autocomplete", Tc(t)).map(Bc)).map(e => (this.active.find(t => t.source == e) || new Kc(e, this.active.some(t => 0 != t.state) ? 1 : 0)).update(i, r)), n = (s.length == this.active.length && s.every((t, e) => t == this.active[e]) && (s = this.active), this.open); n && i.docChanged && (n = n.map(i.changes)), i.selection || s.some(t => t.hasResult() && i.changes.touchesRange(t.from, t.to)) || !((i, r) => { if (i == r) return 1; for (let t = 0, e = 0; ;) { for (; t < i.length && !i[t].hasResult;)t++; for (; e < r.length && !r[e].hasResult;)e++; var s = t == i.length, n = e == r.length; if (s || n) return s == n; if (i[t++].result != r[e++].result) return } })(s, this.active) ? n = qc.build(s, t, this.id, n, r) : n && n.disabled && !s.some(t => 1 == t.state) && (n = null), !n && s.every(t => 1 != t.state) && s.some(t => t.hasResult()) && (s = s.map(t => t.hasResult() ? new Kc(t.source, 0) : t)); for (e of i.effects) e.is(Yc) && (n = n && n.setSelected(e.value, this.id)); return s == this.active && n == this.open ? this : new Yf(s, this.id, n) } get tooltip() { return this.open ? this.open.tooltip : null } get attrs() { return this.open ? this.open.attrs : jc } }; var jc = { "aria-autocomplete": "list" }; function Uc(t, e) { var i = { "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-controls": t }; return -1 < e && (i["aria-activedescendant"] = t + "-" + e), i } var Qc = []; function $c(t) { return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null } var Kc = class Jf { constructor(t, e, i = -1) { this.source = t, this.state = e, this.explicitPos = i } hasResult() { return !1 } update(t, e) { let i = $c(t), r = this; i ? r = r.handleUserEvent(t, i, e) : t.docChanged ? r = r.handleChange(t) : t.selection && 0 != r.state && (r = new Jf(r.source, 0)); for (var s of t.effects) if (s.is(Ec)) r = new Jf(r.source, 1, s.value ? Tc(t.state) : -1); else if (s.is(Lc)) r = new Jf(r.source, 0); else if (s.is(Gc)) for (var n of s.value) n.source == r.source && (r = n); return r } handleUserEvent(t, e, i) { return "delete" != e && i.activateOnTyping ? new Jf(this.source, 1) : this.map(t.changes) } handleChange(t) { return t.changes.touchesRange(Tc(t.startState)) ? new Jf(this.source, 0) : this.map(t.changes) } map(t) { return t.empty || this.explicitPos < 0 ? this : new Jf(this.source, this.state, t.mapPos(this.explicitPos)) } }, Xc = class Zf extends Kc { constructor(t, e, i, r, s) { super(t, 2, e), this.result = i, this.from = r, this.to = s } hasResult() { return !0 } handleUserEvent(t, e, i) { var r = t.changes.mapPos(this.from), s = t.changes.mapPos(this.to, 1), n = Tc(t.state); if ((this.explicitPos < 0 ? n <= r : n < this.from) || s < n || "delete" == e && Tc(t.startState) == this.from) return new Kc(this.source, "input" == e && i.activateOnTyping ? 1 : 0); let o = this.explicitPos < 0 ? -1 : t.changes.mapPos(this.explicitPos), a; return ((t, e, i, r) => { var s; if (t) return s = e.sliceDoc(i, r), "function" == typeof t ? t(s, i, r, e) : Dc(t, !0).test(s) })(this.result.validFor, t.state, r, s) ? new Zf(this.source, o, this.result, r, s) : this.result.update && (a = this.result.update(this.result, r, s, new Cc(t.state, n, 0 <= o))) ? new Zf(this.source, o, a, a.from, null != (e = a.to) ? e : Tc(t.state)) : new Kc(this.source, 1, o) } handleChange(t) { return t.changes.touchesRange(this.from, this.to) ? new Kc(this.source, 0) : this.map(t.changes) } map(t) { return t.empty ? this : new Zf(this.source, this.explicitPos < 0 ? -1 : t.mapPos(this.explicitPos), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) } }; var Gc = c.define({ map(t, e) { return t.map(t => t.map(e)) } }), Yc = c.define(), Jc = p.define({ create() { return _c.start() }, update(t, e) { return t.update(e) }, provide: t => [Rn.from(t, t => t.tooltip), T.contentAttributes.from(t, t => t.attrs)] }); function Zc(t, e) { var i = e.completion.apply || e.completion.label, r = t.state.field(Jc).active.find(t => t.source == e.source); return r instanceof Xc && ("string" == typeof i ? t.dispatch(Object.assign(Object.assign({}, ((e, i, r, s) => { let n = e.selection.main, o = r - n.from, a = s - n.from; return Object.assign(Object.assign({}, e.changeByRange(t => t != n && r != s && e.sliceDoc(t.from + o, t.from + a) != e.sliceDoc(r, s) ? { range: t } : { changes: { from: t.from + o, to: s == n.from ? t.to : t.from + a, insert: i }, range: v.cursor(t.from + o + i.length) })), { scrollIntoView: !0, userEvent: "input.complete" }) })(t.state, i, r.from, r.to)), { annotations: Pc.of(e.completion) })) : i(t, e.completion, r.from, r.to), !0) } var td = zc(Jc, Zc); function ed(o, a = "option") { return t => { var e = t.state.field(Jc, !1); if (!e || !e.open || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(B).interactionDelay) return !1; let i = 1, r; "page" == a && (r = Hn(t, e.open.tooltip)) && (i = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1)); var s = e.open.options.length; let n = -1 < e.open.selected ? e.open.selected + i * (o ? 1 : -1) : o ? 0 : s - 1; return n < 0 ? n = "page" == a ? 0 : s - 1 : n >= s && (n = "page" == a ? s - 1 : 0), t.dispatch({ effects: Yc.of(n) }), !0 } } var id = class { constructor(t, e) { this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0 } }, rd = a.fromClass(class { constructor(t) { this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0; for (var e of t.state.field(Jc).active) 1 == e.state && this.startQuery(e) } update(e) { var t = e.state.field(Jc); if (e.selectionSet || e.docChanged || e.startState.field(Jc) != t) { var i = e.transactions.some(t => (t.selection || t.docChanged) && !$c(t)); for (let t = 0; t < this.running.length; t++) { var r = this.running[t]; if (i || 50 < r.updates.length + e.transactions.length && 1e3 < Date.now() - r.time) { for (var s of r.context.abortListeners) try { s() } catch (t) { qi(this.view.state, t) } r.context.abortListeners = null, this.running.splice(t--, 1) } else r.updates.push(...e.transactions) } if (-1 < this.debounceUpdate && clearTimeout(this.debounceUpdate), this.debounceUpdate = t.active.some(e => 1 == e.state && !this.running.some(t => t.active.source == e.source)) ? setTimeout(() => this.startUpdate(), 50) : -1, 0 != this.composing) for (var n of e.transactions) "input" == $c(n) ? this.composing = 2 : 2 == this.composing && n.selection && (this.composing = 3) } } startUpdate() { this.debounceUpdate = -1; var t = this.view.state; for (let e of t.field(Jc).active) 1 != e.state || this.running.some(t => t.active.source == e.source) || this.startQuery(e) } startQuery(t) { var e = this.view.state, i = Tc(e), e = new Cc(e, i, t.explicitPos == i); let r = new id(t, e); this.running.push(r), Promise.resolve(t.source(e)).then(t => { r.context.aborted || (r.done = t || null, this.scheduleAccept()) }, t => { this.view.dispatch({ effects: Lc.of(null) }), qi(this.view.state, t) }) } scheduleAccept() { this.running.every(t => void 0 !== t.done) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(B).updateSyncTime)) } accept() { -1 < this.debounceAccept && clearTimeout(this.debounceAccept), this.debounceAccept = -1; var i = [], r = this.view.state.facet(B); for (let t = 0; t < this.running.length; t++) { let e = this.running[t]; if (void 0 !== e.done) { if (this.running.splice(t--, 1), e.done) { let t = new Xc(e.active.source, e.active.explicitPos, e.done, e.done.from, null != (n = e.done.to) ? n : Tc(e.updates.length ? e.updates[0].startState : this.view.state)); for (var s of e.updates) t = t.update(s, r); if (t.hasResult()) { i.push(t); continue } } var n = this.view.state.field(Jc).active.find(t => t.source == e.active.source); if (n && 1 == n.state) if (null == e.done) { let t = new Kc(e.active.source, 0); for (var o of e.updates) t = t.update(o, r); 1 != t.state && i.push(t) } else this.startQuery(n) } } i.length && this.view.dispatch({ effects: Gc.of(i) }) } }, { eventHandlers: { blur(t) { var e = this.view.state.field(Jc, !1); e && e.tooltip && this.view.state.facet(B).closeOnBlur && ((e = e.open && Hn(this.view, e.open.tooltip)) && e.dom.contains(t.relatedTarget) || this.view.dispatch({ effects: Lc.of(null) })) }, compositionstart() { this.composing = 1 }, compositionend() { 3 == this.composing && setTimeout(() => this.view.dispatch({ effects: Ec.of(!1) }), 20), this.composing = 0 } } }), sd = T.baseTheme({ ".cm-tooltip.cm-tooltip-autocomplete": { "& > ul": { fontFamily: "monospace", whiteSpace: "nowrap", overflow: "hidden auto", maxWidth_fallback: "700px", maxWidth: "min(700px, 95vw)", minWidth: "250px", maxHeight: "10em", height: "100%", listStyle: "none", margin: 0, padding: 0, "& > li, & > completion-section": { padding: "1px 3px", lineHeight: 1.2 }, "& > li": { overflowX: "hidden", textOverflow: "ellipsis", cursor: "pointer" }, "& > completion-section": { display: "list-item", borderBottom: "1px solid silver", paddingLeft: "0.5em", opacity: .7 } } }, "&light .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#17c", color: "white" }, "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" }, "&dark .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#347", color: "white" }, "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" }, ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": { content: '"Â·Â·Â·"', opacity: .5, display: "block", textAlign: "center" }, ".cm-tooltip.cm-completionInfo": { position: "absolute", padding: "3px 9px", width: "max-content", maxWidth: "400px", boxSizing: "border-box" }, ".cm-completionInfo.cm-completionInfo-left": { right: "100%" }, ".cm-completionInfo.cm-completionInfo-right": { left: "100%" }, ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" }, ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" }, "&light .cm-snippetField": { backgroundColor: "#00000022" }, "&dark .cm-snippetField": { backgroundColor: "#ffffff22" }, ".cm-snippetFieldPosition": { verticalAlign: "text-top", width: 0, height: "1.15em", display: "inline-block", margin: "0 -0.7px -.7em", borderLeft: "1.4px dotted #888" }, ".cm-completionMatchedText": { textDecoration: "underline" }, ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" }, ".cm-completionIcon": { fontSize: "90%", width: ".8em", display: "inline-block", textAlign: "center", paddingRight: ".6em", opacity: "0.6", boxSizing: "content-box" }, ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "'Æ’'" } }, ".cm-completionIcon-class": { "&:after": { content: "'â—‹'" } }, ".cm-completionIcon-interface": { "&:after": { content: "'â—Œ'" } }, ".cm-completionIcon-variable": { "&:after": { content: "'ð‘¥'" } }, ".cm-completionIcon-constant": { "&:after": { content: "'ð¶'" } }, ".cm-completionIcon-type": { "&:after": { content: "'ð‘¡'" } }, ".cm-completionIcon-enum": { "&:after": { content: "'âˆª'" } }, ".cm-completionIcon-property": { "&:after": { content: "'â–¡'" } }, ".cm-completionIcon-keyword": { "&:after": { content: "'ðŸ”‘ï¸Ž'" } }, ".cm-completionIcon-namespace": { "&:after": { content: "'â–¢'" } }, ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } } }), nd = { brackets: ["(", "[", "{", "'", '"'], before: ")]}:;>", stringPrefixes: [] }, od = c.define({ map(t, e) { e = e.mapPos(t, -1, l.TrackAfter); return null == e ? void 0 : e } }), ad = new class extends Ut { }, hd = (ad.startSide = 1, ad.endSide = -1, p.define({ create() { return b.empty }, update(t, i) { if (t = t.map(i.changes), i.selection) { let e = i.state.doc.lineAt(i.selection.main.head); t = t.update({ filter: t => t >= e.from && t <= e.to }) } for (var e of i.effects) e.is(od) && (t = t.update({ add: [ad.range(e.value, e.value + 1)] })); return t } })); var ld = "()[]{}<>"; function cd(e) { for (let t = 0; t < ld.length; t += 2)if (ld.charCodeAt(t) == e) return ld.charAt(t + 1); return J(e < 128 ? e : e + 1) } function dd(t, e) { return t.languageDataAt("closeBrackets", e)[0] || nd } var ud = "object" == typeof navigator && /Android\b/.test(navigator.userAgent), fd = T.inputHandler.of((t, e, i, r) => { var s; return !((ud ? t.composing : t.compositionStarted) || t.state.readOnly || (s = t.state.selection.main, 2 < r.length) || 2 == r.length && 1 == Z(S(r, 0)) || e != s.from || i != s.to || !(e = ((t, e) => { var i, r = dd(t, t.selection.main.head), s = r.brackets || nd.brackets; for (i of s) { var n = cd(S(i, 0)); if (e == i) return n == i ? ((n, o, a, t) => { let h = t.stringPrefixes || nd.stringPrefixes, l = null, e = n.changeByRange(t => { if (!t.empty) return { changes: [{ insert: o, from: t.from }, { insert: o, from: t.to }], effects: od.of(t.to + o.length), range: v.range(t.anchor + o.length, t.head + o.length) }; let e = t.head, i = gd(n.doc, e), r; if (i == o) { if (vd(n, e)) return { changes: { insert: o + o, from: e }, effects: od.of(e + o.length), range: v.cursor(e + o.length) }; var s; if (md(n, e)) return { changes: { from: e, to: e + (s = a && n.sliceDoc(e, e + 3 * o.length) == o + o + o ? o + o + o : o).length, insert: s }, range: v.cursor(e + s.length) } } else { if (a && n.sliceDoc(e - 2 * o.length, e) == o + o && -1 < (r = wd(n, e - 2 * o.length, h)) && vd(n, r)) return { changes: { insert: o + o + o + o, from: e }, effects: od.of(e + o.length), range: v.cursor(e + o.length) }; if (n.charCategorizer(e)(i) != m.Word && -1 < wd(n, e, h) && !((e, i, r, s) => { let n = P(e).resolveInner(i, -1), o = s.reduce((t, e) => Math.max(t, e.length), 0); for (let t = 0; t < 5; t++) { var a = e.sliceDoc(n.from, Math.min(n.to, n.from + r.length + o)), h = a.indexOf(r); if (!h || -1 < h && -1 < s.indexOf(a.slice(0, h))) { let t = n.firstChild; for (; t && t.from == n.from && t.to - t.from > r.length + h;) { if (e.sliceDoc(t.to - r.length, t.to) == r) return; t = t.firstChild } return 1 } a = n.to == i && n.parent; if (!a) break; n = a } })(n, e, o, h)) return { changes: { insert: o + o, from: e }, effects: od.of(e + o.length), range: v.cursor(e + o.length) } } return { range: l = t } }); return l ? null : n.update(e, { scrollIntoView: !0, userEvent: "input.type" }) })(t, i, -1 < s.indexOf(i + i + i), r) : ((i, r, s, n) => { let o = null, t = i.changeByRange(t => { var e; return t.empty ? !(e = gd(i.doc, t.head)) || /\s/.test(e) || -1 < n.indexOf(e) ? { changes: { insert: r + s, from: t.head }, effects: od.of(t.head + r.length), range: v.cursor(t.head + r.length) } : { range: o = t } : { changes: [{ insert: r, from: t.from }, { insert: s, from: t.to }], effects: od.of(t.to + r.length), range: v.range(t.anchor + r.length, t.head + r.length) } }); return o ? null : i.update(t, { scrollIntoView: !0, userEvent: "input.type" }) })(t, i, n, r.before || nd.before); if (e == n && md(t, t.selection.main.from)) return ((e, i) => { let r = null, t = e.changeByRange(t => t.empty && gd(e.doc, t.head) == i ? { changes: { from: t.head, to: t.head + i.length, insert: i }, range: v.cursor(t.head + i.length) } : r = { range: t }); return r ? null : e.update(t, { scrollIntoView: !0, userEvent: "input.type" }) })(t, (i, n)) } return null })(t.state, r)) || (t.dispatch(e), 0)) }), pd = [{ key: "Backspace", run: ({ state: r, dispatch: t }) => { if (r.readOnly) return !1; let s = dd(r, r.selection.main.head).brackets || nd.brackets, n = null, e = r.changeByRange(t => { if (t.empty) { var e, i = ((t, e) => Z(S(t = t.sliceString(e - 2, e), 0)) == t.length ? t : t.slice(1))(r.doc, t.head); for (e of s) if (e == i && gd(r.doc, t.head) == cd(S(e, 0))) return { changes: { from: t.head - e.length, to: t.head + e.length }, range: v.cursor(t.head - e.length) } } return { range: n = t } }); return n || t(r.update(e, { scrollIntoView: !0, userEvent: "delete.backward" })), !n } }]; function md(t, e) { let i = !1; return t.field(hd).between(0, t.doc.length, t => { t == e && (i = !0) }), i } function gd(t, e) { t = t.sliceString(e, e + 2); return t.slice(0, Z(S(t, 0))) } function vd(t, e) { t = P(t).resolveInner(e + 1); return t.parent && t.from == e } function wd(t, e, i) { var r, s = t.charCategorizer(e); if (s(t.sliceDoc(e - 1, e)) != m.Word) return e; for (r of i) { var n = e - r.length; if (t.sliceDoc(n, e) == r && s(t.sliceDoc(n - 1, n)) != m.Word) return n } return -1 } var bd = [{ key: "Ctrl-Space", run: t => !!t.state.field(Jc, !1) && (t.dispatch({ effects: Ec.of(!0) }), !0) }, { key: "Escape", run: t => { var e = t.state.field(Jc, !1); return !(!e || !e.active.some(t => 0 != t.state) || (t.dispatch({ effects: Lc.of(null) }), 0)) } }, { key: "ArrowDown", run: ed(!0) }, { key: "ArrowUp", run: ed(!1) }, { key: "PageDown", run: ed(!0, "page") }, { key: "PageUp", run: ed(!1, "page") }, { key: "Enter", run: t => { var e = t.state.field(Jc, !1); return !(t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(B).interactionDelay) && Zc(t, e.open.options[e.open.selected]) } }], yd = wt.highest(Vs.computeN([B], t => t.facet(B).defaultKeymap ? [bd] : [])), xd = class { constructor(t, e, i) { this.from = t, this.to = e, this.diagnostic = i } }, kd = class tp { constructor(t, e, i) { this.diagnostics = t, this.panel = e, this.selected = i } static init(t, e, i) { let r = t; t = i.facet(Bd).markerFilter, t && (r = t(r)), t = C.set(r.map(t => t.from == t.to || t.from == t.to - 1 && i.doc.lineAt(t.from).to == t.from ? C.widget({ widget: new Nd(t), diagnostic: t }).range(t.from) : C.mark({ attributes: { class: "cm-lintRange cm-lintRange-" + t.severity + (t.markClass ? " " + t.markClass : "") }, diagnostic: t }).range(t.from, t.to)), !0); return new tp(t, e, Sd(t)) } }; function Sd(t, r = null, e = 0) { let s = null; return t.between(e, 1e9, (t, e, { spec: i }) => { if (!r || i.diagnostic == r) return s = new xd(t, e, i.diagnostic), !1 }), s } var Cd = c.define(), Ad = c.define(), Od = c.define(), Md = p.define({ create() { return new kd(C.none, null, null) }, update(i, r) { if (r.docChanged) { let t = i.diagnostics.map(r.changes), e = null; var s; i.selected && (s = r.changes.mapPos(i.selected.from, 1), e = Sd(t, i.selected.diagnostic, s) || Sd(t, null, s)), i = new kd(t, i.panel, e) } for (var t of r.effects) t.is(Cd) ? i = kd.init(t.value, i.panel, r.state) : t.is(Ad) ? i = new kd(i.diagnostics, t.value ? Vd.open : null, i.selected) : t.is(Od) && (i = new kd(i.diagnostics, i.panel, t.value)); return i }, provide: t => [Un.from(t, t => t.panel), T.decorations.from(t, t => t.diagnostics)] }), Td = C.mark({ class: "cm-lintRange cm-lintRange-active" }); function Dd(t, r, s) { var e = t.state.field(Md).diagnostics; let n = [], o = 2e8, a = 0; e.between(r - (s < 0 ? 1 : 0), r + (0 < s ? 1 : 0), (t, e, { spec: i }) => { t <= r && r <= e && (t == e || (t < r || 0 < s) && (r < e || s < 0)) && (n.push(i.diagnostic), o = Math.min(t, o), a = Math.max(e, a)) }); e = t.state.facet(Bd).tooltipFilter; return (n = e ? e(n) : n).length ? { pos: o, end: a, above: t.state.doc.lineAt(o).to < a, create() { return { dom: (e = t, R("ul", { class: "cm-tooltip-lint" }, n.map(t => Ld(e, t, !1)))) }; var e } } : null } var Pd = t => { var e = t.state.field(Md, !1); return !(!e || !e.panel || (t.dispatch({ effects: Ad.of(!1) }), 0)) }, Rd = [{ key: "Mod-Shift-m", run: t => { var e, i = t.state.field(Md, !1), i = (i && i.panel || t.dispatch({ effects: (i = t.state, e = [Ad.of(!0)], i.field(Md, !1) ? e : e.concat(c.appendConfig.of(Wd))) }), Fn(t, Vd.open)); return i && i.dom.querySelector(".cm-panel-lint ul").focus(), !0 }, preventDefault: !0 }, { key: "F8", run: t => { var e = t.state.field(Md, !1); if (!e) return !1; let i = t.state.selection.main, r = e.diagnostics.iter(i.to + 1); return !(!r.value && (!(r = e.diagnostics.iter(0)).value || r.from == i.from && r.to == i.to) || (t.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), 0)) } }], Bd = d.define({ combine(t) { return Object.assign({ sources: t.map(t => t.source) }, jt(t.map(t => t.config), { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null }, { needsRefresh: (e, i) => e ? i ? t => e(t) || i(t) : e : i })) } }); function Ed(t) { var i = []; if (t) t: for (var { name: r } of t) { for (let t = 0; t < r.length; t++) { let e = r[t]; if (/[a-zA-Z]/.test(e) && !i.some(t => t.toLowerCase() == e.toLowerCase())) { i.push(e); continue t } } i.push("") } return i } function Ld(a, h, t) { let e, l = t ? Ed(h.actions) : []; return R("li", { class: "cm-diagnostic cm-diagnostic-" + h.severity }, R("span", { class: "cm-diagnosticText" }, h.renderMessage ? h.renderMessage() : h.message), null == (e = h.actions) ? void 0 : e.map((e, t) => { let i = !1, r = t => { t.preventDefault(), !i && (i = !0, t = Sd(a.state.field(Md).diagnostics, h)) && e.apply(a, t.from, t.to) }; var s = e.name, n = l[t] ? s.indexOf(l[t]) : -1, o = n < 0 ? s : [s.slice(0, n), R("u", s.slice(n, n + 1)), s.slice(n + 1)]; return R("button", { type: "button", class: "cm-diagnosticAction", onclick: r, onmousedown: r, "aria-label": ` Action: ${s}${n < 0 ? "" : ` (access key "${l[t]})"`}.` }, o) }), h.source && R("div", { class: "cm-diagnosticSource" }, h.source)) } var Nd = class extends Qe { constructor(t) { super(), this.diagnostic = t } eq(t) { return t.diagnostic == this.diagnostic } toDOM() { return R("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity }) } }, Id = class { constructor(t, e) { this.diagnostic = e, this.id = "item_" + Math.floor(4294967295 * Math.random()).toString(16), this.dom = Ld(t, e, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option") } }, Vd = class ep { constructor(n) { this.view = n, this.items = []; this.list = R("ul", { tabIndex: 0, role: "listbox", "aria-label": this.view.state.phrase("Diagnostics"), onkeydown: e => { if (27 == e.keyCode) Pd(this.view), this.view.focus(); else if (38 == e.keyCode || 33 == e.keyCode) this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length); else if (40 == e.keyCode || 34 == e.keyCode) this.moveSelection((this.selectedIndex + 1) % this.items.length); else if (36 == e.keyCode) this.moveSelection(0); else if (35 == e.keyCode) this.moveSelection(this.items.length - 1); else if (13 == e.keyCode) this.view.focus(); else { if (!(65 <= e.keyCode && e.keyCode <= 90 && 0 <= this.selectedIndex)) return; var i, r = this.items[this.selectedIndex].diagnostic, s = Ed(r.actions); for (let t = 0; t < s.length; t++)s[t].toUpperCase().charCodeAt(0) == e.keyCode && (i = Sd(this.view.state.field(Md).diagnostics, r)) && r.actions[t].apply(n, i.from, i.to) } e.preventDefault() }, onclick: e => { for (let t = 0; t < this.items.length; t++)this.items[t].dom.contains(e.target) && this.moveSelection(t) } }), this.dom = R("div", { class: "cm-panel-lint" }, this.list, R("button", { type: "button", name: "close", "aria-label": this.view.state.phrase("close"), onclick: () => Pd(this.view) }, "Ã—")), this.update() } get selectedIndex() { var e = this.view.state.field(Md).selected; if (e) for (let t = 0; t < this.items.length; t++)if (this.items[t].diagnostic == e.diagnostic) return t; return -1 } update() { let { diagnostics: t, selected: n } = this.view.state.field(Md), o = 0, a = !1, h = null; for (t.between(0, this.view.state.doc.length, (t, e, { spec: i }) => { let r = -1, s; for (let t = o; t < this.items.length; t++)if (this.items[t].diagnostic == i.diagnostic) { r = t; break } r < 0 ? (s = new Id(this.view, i.diagnostic), this.items.splice(o, 0, s), a = !0) : (s = this.items[r], r > o && (this.items.splice(o, r - o), a = !0)), n && s.diagnostic == n.diagnostic ? s.dom.hasAttribute("aria-selected") || (s.dom.setAttribute("aria-selected", "true"), h = s) : s.dom.hasAttribute("aria-selected") && s.dom.removeAttribute("aria-selected"), o++ }); o < this.items.length && !(1 == this.items.length && this.items[0].diagnostic.from < 0);)a = !0, this.items.pop(); 0 == this.items.length && (this.items.push(new Id(this.view, { from: -1, to: -1, severity: "info", message: this.view.state.phrase("No diagnostics") })), a = !0), h ? (this.list.setAttribute("aria-activedescendant", h.id), this.view.requestMeasure({ key: this, read: () => ({ sel: h.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }), write: ({ sel: t, panel: e }) => { var i = e.height / this.list.offsetHeight; t.top < e.top ? this.list.scrollTop -= (e.top - t.top) / i : t.bottom > e.bottom && (this.list.scrollTop += (t.bottom - e.bottom) / i) } })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), a && this.sync() } sync() { let e = this.list.firstChild; function t() { var t = e; e = t.nextSibling, t.remove() } for (var i of this.items) if (i.dom.parentNode == this.list) { for (; e != i.dom;)t(); e = i.dom.nextSibling } else this.list.insertBefore(i.dom, e); for (; e;)t() } moveSelection(t) { this.selectedIndex < 0 || (t = Sd(this.view.state.field(Md).diagnostics, this.items[t].diagnostic)) && this.view.dispatch({ selection: { anchor: t.from, head: t.to }, scrollIntoView: !0, effects: Od.of(t) }) } static open(t) { return new ep(t) } }; function Hd(t) { return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${'width="6" height="3"'}>${encodeURIComponent(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`)}</svg>')` } var $e = T.baseTheme({ ".cm-diagnostic": { padding: "3px 6px 3px 8px", marginLeft: "-1px", display: "block", whiteSpace: "pre-wrap" }, ".cm-diagnostic-error": { borderLeft: "5px solid #d11" }, ".cm-diagnostic-warning": { borderLeft: "5px solid orange" }, ".cm-diagnostic-info": { borderLeft: "5px solid #999" }, ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" }, ".cm-diagnosticAction": { font: "inherit", border: "none", padding: "2px 4px", backgroundColor: "#444", color: "white", borderRadius: "3px", marginLeft: "8px", cursor: "pointer" }, ".cm-diagnosticSource": { fontSize: "70%", opacity: .7 }, ".cm-lintRange": { backgroundPosition: "left bottom", backgroundRepeat: "repeat-x", paddingBottom: "0.7px" }, ".cm-lintRange-error": { backgroundImage: Hd("#d11") }, ".cm-lintRange-warning": { backgroundImage: Hd("orange") }, ".cm-lintRange-info": { backgroundImage: Hd("#999") }, ".cm-lintRange-hint": { backgroundImage: Hd("#66d") }, ".cm-lintRange-active": { backgroundColor: "#ffdd9980" }, ".cm-tooltip-lint": { padding: 0, margin: 0 }, ".cm-lintPoint": { position: "relative", "&:after": { content: '""', position: "absolute", bottom: 0, left: "-2px", borderLeft: "3px solid transparent", borderRight: "3px solid transparent", borderBottom: "4px solid #d11" } }, ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } }, ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } }, ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } }, ".cm-panel.cm-panel-lint": { position: "relative", "& ul": { maxHeight: "100px", overflowY: "auto", "& [aria-selected]": { backgroundColor: "#ddd", "& u": { textDecoration: "underline" } }, "&:focus [aria-selected]": { background_fallback: "#bdf", backgroundColor: "Highlight", color_fallback: "white", color: "HighlightText" }, "& u": { textDecoration: "none" }, padding: 0, margin: 0 }, "& [name=close]": { position: "absolute", top: "0", right: "2px", background: "inherit", border: "none", font: "inherit", padding: 0, margin: 0 } } }), Wd = [Md, T.decorations.compute([Md], t => { var { selected: t, panel: e } = t.field(Md); return t && e && t.from != t.to ? C.set([Td.range(t.from, t.to)]) : C.none }), Vn(Dd, { hideOn: function(t, e) { return e = t.startState.doc.lineAt(e.pos), !(!t.effects.some(t => t.is(Cd)) && !t.changes.touchesRange(e.from, e.to)) } }), $e], zd = (() => { return [(e = {}, [so.of(e), Gn(), ao]), co, fn(), (e = {}, [Bh, Rh.of(e), T.domEventHandlers({ beforeinput(t, e) { var i = "historyUndo" == t.inputType ? Lh : "historyRedo" == t.inputType ? Nh : null; return !!i && (t.preventDefault(), i(e)) } })]), Qa(), (e = {}, [Gs.of(e), Js, tn, en, Wi.of(!0)]), [sn, nn], w.allowMultipleSelections.of(!0), w.transactionFilter.of(t => { if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete")) return t; var e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head); if (!e.length) return t; var i, r = t.newDoc, s = t.newSelection.main.head, n = r.lineAt(s); if (s > n.from + 200) return t; let o = r.sliceString(n.from, s); if (!e.some(t => t.test(o))) return t; let a = t.state, h = -1, l = []; for ({ head: i } of a.selection.ranges) { var c, d, u, f = a.doc.lineAt(i); f.from != h && (h = f.from, null != (c = ba(a, f.from)) && (d = /^\s*/.exec(f.text)[0]) != (u = wa(a, c))) && l.push({ from: f.from, to: f.from + d.length, insert: u }) } return l.length ? [t, { changes: l, sequential: !0 }] : t }), Ja(th, { fallback: !0 }), (e = {}, [rh.of(e), ah]), [fd, hd], (e = {}, [Jc, B.of(e), rd, yd, sd]), (t => { let i = (null == t ? void 0 : t.eventFilter) || (t => t.altKey && 0 == t.button); return T.mouseSelectionStyle.of((t, e) => i(e) ? xn(t, e) : null) })(), ((t = {}) => { let [e, i] = kn[t.key || "Alt"], r = a.fromClass(class { constructor(t) { this.view = t, this.isDown = !1 } set(t) { this.isDown != t && (this.isDown = t, this.view.update([])) } }, { eventObservers: { keydown(t) { this.set(t.keyCode == e || i(t)) }, keyup(t) { t.keyCode != e && i(t) || this.set(!1) }, mousemove(t) { this.set(i(t)) } } }); return [r, T.contentAttributes.of(t => null != (t = t.plugin(r)) && t.isDown ? Sn : null)] })(), wn, (e = [jl, _l], t && e.push(Wl.of(t)), e), Vs.of([...pd, ...Sl, ...vc, ...Uh, ...Va, ...bd, ...Rd])]; var t, e })(), Fd = class ip { constructor(t, e, i, r, s, n, o, a, h, l = 0, c) { this.p = t, this.stack = e, this.state = i, this.reducePos = r, this.pos = s, this.score = n, this.buffer = o, this.bufferBase = a, this.curContext = h, this.lookAhead = l, this.parent = c } toString() { return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@` + this.pos + (this.score ? "!" + this.score : "") } static start(t, e, i = 0) { var r = t.parser.context; return new ip(t, [], e, i, i, 0, [], 0, r ? new qd(r, r.start) : null, 0, null) } get context() { return this.curContext ? this.curContext.context : null } pushState(t, e) { this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t } reduce(t) { var e = t >> 19, i = 65535 & t, r = this.p.parser, s = r.dynamicPrecedence(i); if (s && (this.score += s), 0 == e) this.pushState(r.getGoto(this.state, i, !0), this.reducePos), i < r.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos); else { var n = this.stack.length - 3 * (e - 1) - (262144 & t ? 6 : 0), s = n ? this.stack[n - 2] : this.p.ranges[0].from, e = this.reducePos - s, o = (2e3 <= e && (null == (o = this.p.parser.nodeSet.types[i]) || !o.isAnonymous) && (s == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = e) : this.p.lastBigReductionSize < e && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = s, this.p.lastBigReductionSize = e)), n ? this.stack[n - 1] : 0), e = this.bufferBase + this.buffer.length - o; for ((i < r.minRepeatTerm || 131072 & t) && (o = r.stateFlag(this.state, 1) ? this.pos : this.reducePos, this.storeNode(i, s, o, 4 + e, !0)), 262144 & t ? this.state = this.stack[n] : (o = this.stack[n - 3], this.state = r.getGoto(o, i, !0)); this.stack.length > n;)this.stack.pop(); this.reduceContext(i, s) } } storeNode(e, i, r, s = 4, t = !1) { if (0 == e && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) { let t = this, e = this.buffer.length; if (0 == e && t.parent && (e = t.bufferBase - t.parent.bufferBase, t = t.parent), 0 < e && 0 == t.buffer[e - 4] && -1 < t.buffer[e - 1]) { if (i == r) return; if (t.buffer[e - 2] >= i) return void (t.buffer[e - 2] = r) } } if (t && this.pos != r) { let t = this.buffer.length; if (0 < t && 0 != this.buffer[t - 4]) for (; 0 < t && this.buffer[t - 2] > r;)this.buffer[t] = this.buffer[t - 4], this.buffer[t + 1] = this.buffer[t - 3], this.buffer[t + 2] = this.buffer[t - 2], this.buffer[t + 3] = this.buffer[t - 1], t -= 4, 4 < s && (s -= 4); this.buffer[t] = e, this.buffer[t + 1] = i, this.buffer[t + 2] = r, this.buffer[t + 3] = s } else this.buffer.push(e, i, r, s) } shift(t, e, i, r) { var s; 131072 & t ? this.pushState(65535 & t, this.pos) : 0 == (262144 & t) ? (t = t, s = this.p.parser, (r > this.pos || e <= s.maxNode) && (this.pos = r, s.stateFlag(t, 1) || (this.reducePos = r)), this.pushState(t, i), this.shiftContext(e, i), e <= s.maxNode && this.buffer.push(e, i, r, 4)) : (this.pos = r, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, r, 4)) } apply(t, e, i, r) { 65536 & t ? this.reduce(t) : this.shift(t, e, i, r) } useNode(t, e) { let i = this.p.reused.length - 1; (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++); var r = this.pos; this.reducePos = this.pos = r + t.length, this.pushState(e, r), this.buffer.push(i, r, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length))) } split() { let t = this, e = t.buffer.length; for (; 0 < e && t.buffer[e - 2] > t.reducePos;)e -= 4; for (var i = t.buffer.slice(e), r = t.bufferBase + e; t && r == t.bufferBase;)t = t.parent; return new ip(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, t) } recoverByDelete(t, e) { var i = t <= this.p.parser.maxNode; i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190 } canShift(t) { for (var e = new _d(this); ;) { var i = this.p.parser.stateSlot(e.state, 4) || this.p.parser.hasAction(e.state, t); if (0 == i) return !1; if (0 == (65536 & i)) return !0; e.reduce(i) } } recoverByInsert(i) { if (300 <= this.stack.length) return []; let r = this.p.parser.nextStates(this.state); if (8 < r.length || 120 <= this.stack.length) { var s = []; for (let t = 0, e; t < r.length; t += 2)(e = r[t + 1]) != this.state && this.p.parser.hasAction(e, i) && s.push(r[t], e); if (this.stack.length < 120) for (let t = 0; s.length < 8 && t < r.length; t += 2) { let i = r[t + 1]; s.some((t, e) => 1 & e && t == i) || s.push(r[t], i) } r = s } var e = []; for (let t = 0; t < r.length && e.length < 4; t += 2) { var n, o = r[t + 1]; o != this.state && ((n = this.split()).pushState(o, this.pos), n.storeNode(0, n.pos, n.pos, 4, !0), n.shiftContext(r[t], this.pos), n.reducePos = this.pos, n.score -= 200, e.push(n)) } return e } forceReduce() { var t = this.p.parser; let e = t.stateSlot(this.state, 5); if (0 == (65536 & e)) return !1; if (!t.validAction(this.state, e)) { var i = e >> 19, r = 65535 & e, i = this.stack.length - 3 * i; if (i < 0 || t.getGoto(this.stack[i], r, !1) < 0) { t = this.findForcedReduction(); if (null == t) return !1; e = t } this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100 } return this.reducePos = this.pos, this.reduce(e), !0 } findForcedReduction() { let n = this.p.parser, e = [], o = (t, s) => { if (!e.includes(t)) return e.push(t), n.allActions(t, t => { if (!(393216 & t)) if (65536 & t) { var e = (t >> 19) - s; if (1 < e) { var i = 65535 & t, r = this.stack.length - 3 * e; if (0 <= r && 0 <= n.getGoto(this.stack[r], i, !1)) return e << 19 | 65536 | i } } else { r = o(t, s + 1); if (null != r) return r } }) }; return o(this.state, 0) } forceAll() { for (; !this.p.parser.stateFlag(this.state, 2);)if (!this.forceReduce()) { this.storeNode(0, this.pos, this.pos, 4, !0); break } return this } get deadEnd() { var t; return 3 == this.stack.length && (t = this.p.parser, 65535 == t.data[t.stateSlot(this.state, 1)]) && !t.stateSlot(this.state, 4) } restart() { this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0 } sameState(e) { if (this.state != e.state || this.stack.length != e.stack.length) return !1; for (let t = 0; t < this.stack.length; t += 3)if (this.stack[t] != e.stack[t]) return !1; return !0 } get parser() { return this.p.parser } dialectEnabled(t) { return this.p.parser.dialect.flags[t] } shiftContext(t, e) { this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e))) } reduceContext(t, e) { this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e))) } emitContext() { var t = this.buffer.length - 1; (t < 0 || -3 != this.buffer[t]) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3) } emitLookAhead() { var t = this.buffer.length - 1; (t < 0 || -4 != this.buffer[t]) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4) } updateContext(t) { t != this.curContext.context && ((t = new qd(this.curContext.tracker, t)).hash != this.curContext.hash && this.emitContext(), this.curContext = t) } setLookAhead(t) { t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t) } close() { this.curContext && this.curContext.tracker.strict && this.emitContext(), 0 < this.lookAhead && this.emitLookAhead() } }, qd = class { constructor(t, e) { this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0 } }, _d = class { constructor(t) { this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length } reduce(t) { var e = 65535 & t, t = t >> 19, t = (0 == t ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= 3 * (t - 1), this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0)); this.state = t } }, jd = class rp { constructor(t, e, i) { this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, 0 == this.index && this.maybeNext() } static create(t, e = t.bufferBase + t.buffer.length) { return new rp(t, e, e - t.bufferBase) } maybeNext() { var t = this.stack.parent; null != t && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer) } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } next() { this.index -= 4, this.pos -= 4, 0 == this.index && this.maybeNext() } fork() { return new rp(this.stack, this.pos, this.index) } }; function Ud(n, e = Uint16Array) { if ("string" != typeof n) return n; let i = null; for (let s = 0, t = 0; s < n.length;) { let r = 0; for (; ;) { let t = n.charCodeAt(s++), e = !1; if (126 == t) { r = 65535; break } 92 <= t && t--, 34 <= t && t--; let i = t - 32; if (46 <= i && (i -= 46, e = !0), r += i, e) break; r *= 46 } i ? i[t++] = r : i = new e(r) } return i } var Qd = class { constructor() { this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0 } }, $d = new Qd, Kd = class { constructor(t, e) { this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = $d, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext() } resolveOffset(t, e) { let i = this.range, r = this.rangeIndex, s = this.pos + t; for (; s < i.from;) { if (!r) return null; var n = this.ranges[--r]; s -= i.from - n.to, i = n } for (; e < 0 ? s > i.to : s >= i.to;) { if (r == this.ranges.length - 1) return null; var o = this.ranges[++r]; s += o.from - i.to, i = o } return s } clipPos(t) { if (t >= this.range.from && t < this.range.to) return t; for (var e of this.ranges) if (e.to > t) return Math.max(t, e.from); return this.end } peek(t) { let e = this.chunkOff + t, i, r; if (0 <= e && e < this.chunk.length) i = this.pos + t, r = this.chunk.charCodeAt(e); else { t = this.resolveOffset(t, 1); if (null == t) return -1; if ((i = t) >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length) r = this.chunk2.charCodeAt(i - this.chunk2Pos); else { let t = this.rangeIndex, e = this.range; for (; e.to <= i;)e = this.ranges[++t]; this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > e.to && (this.chunk2 = this.chunk2.slice(0, e.to - i)), r = this.chunk2.charCodeAt(0) } } return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r } acceptToken(t, e = 0) { e = e ? this.resolveOffset(e, -1) : this.pos; if (null == e || e < this.token.start) throw new RangeError("Token end out of bounds"); this.token.value = t, this.token.end = e } getChunk() { var t, e; this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length ? ({ chunk: t, chunkPos: e } = this, this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos) : (this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos, t = this.input.chunk(this.pos), e = this.pos + t.length, this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0) } readNext() { return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff) } advance(t = 1) { for (this.chunkOff += t; this.pos + t >= this.range.to;) { if (this.rangeIndex == this.ranges.length - 1) return this.setDone(); t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from } return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext() } setDone() { return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1 } reset(t, e) { if (e ? ((this.token = e).start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = $d, this.pos != t) { if ((this.pos = t) == this.end) return this.setDone(), this; for (; t < this.range.from;)this.range = this.ranges[--this.rangeIndex]; for (; t >= this.range.to;)this.range = this.ranges[++this.rangeIndex]; t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext() } return this } read(t, e) { if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length) return this.chunk.slice(t - this.chunkPos, e - this.chunkPos); if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos); if (t >= this.range.from && e <= this.range.to) return this.input.read(t, e); let i = ""; for (var r of this.ranges) { if (r.from >= e) break; r.to > t && (i += this.input.read(Math.max(r.from, t), Math.min(r.to, e))) } return i } }, Xd = class { constructor(t, e) { this.data = t, this.id = e } token(t, e) { var i = e.p.parser; Yd(this.data, t, e, this.id, i.data, i.tokenPrecTable) } }, Gd = (Xd.prototype.contextual = Xd.prototype.fallback = Xd.prototype.extend = !1, Xd.prototype.fallback = Xd.prototype.extend = !1, class { constructor(t, e = {}) { this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend } }); function Yd(r, s, t, e, n, o) { let a = 0, h = 1 << e, l = t.p.parser.dialect; t: for (; 0 != (h & r[a]);) { var c = r[a + 1]; for (let t = a + 3; t < c; t += 2)if (0 < (r[t + 1] & h)) { var d = r[t]; if (l.allows(d) && (-1 == s.token.value || s.token.value == d || ((t, e, i, r) => (e = Jd(i, r, e)) < 0 || Jd(i, r, t) < e)(d, s.token.value, n, o))) { s.acceptToken(d); break } } let t = s.next, e = 0, i = r[a + 2]; if (!(s.next < 0 && i > e && 65535 == r[c + 3 * i - 3])) { for (; e < i;) { var u = e + i >> 1, f = c + u + (u << 1), p = r[f], m = r[f + 1] || 65536; if (t < p) i = u; else { if (!(m <= t)) { a = r[f + 2], s.advance(); continue t } e = 1 + u } } break } a = r[c + 3 * i - 1] } } function Jd(i, r, s) { for (let t = r, e; 65535 != (e = i[t]); t++)if (e == s) return t - r; return -1 } var Zd = "undefined" != typeof process && process.env && /\bparse\b/.test(process.env.LOG), tu = null; function eu(t, e, i) { var r = t.cursor(D.IncludeAnonymous); for (r.moveTo(e); ;)if (!(i < 0 ? r.childBefore(e) : r.childAfter(e))) for (; ;) { if ((i < 0 ? r.to < e : r.from > e) && !r.type.isError) return i < 0 ? Math.max(0, Math.min(r.to - 1, e - 25)) : Math.min(t.length, Math.max(r.from + 1, e + 25)); if (i < 0 ? r.prevSibling() : r.nextSibling()) break; if (!r.parent()) return i < 0 ? 0 : t.length } } var iu = class { constructor(t, e) { this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment() } nextFragment() { var t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]; if (t) { for (this.safeFrom = t.openStart ? eu(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? eu(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length;)this.trees.pop(), this.start.pop(), this.index.pop(); this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom } else this.nextStart = 1e9 } nodeAt(t) { if (t < this.nextStart) return null; for (; this.fragment && this.safeTo <= t;)this.nextFragment(); if (!this.fragment) return null; for (; ;) { var e = this.trees.length - 1; if (e < 0) return this.nextFragment(), null; var i = this.trees[e], r = this.index[e]; if (r == i.children.length) this.trees.pop(), this.start.pop(), this.index.pop(); else { var s = i.children[r], i = this.start[e] + i.positions[r]; if (t < i) return this.nextStart = i, null; if (s instanceof j) { if (i == t) { if (i < this.safeFrom) return null; r = i + s.length; if (r <= this.safeTo) { var n = s.prop(_.lookAhead); if (!n || r + n < this.fragment.to) return s } } this.index[e]++, i + s.length >= Math.max(this.safeFrom, t) && (this.trees.push(s), this.start.push(i), this.index.push(0)) } else this.index[e]++, this.nextStart = i + s.length } } } }, ru = class { constructor(t, e) { this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map(t => new Qd) } getActions(e) { let i = 0, r = null; var t = e.p.parser, s = t.tokenizers, n = t.stateSlot(e.state, 3), o = e.curContext ? e.curContext.hash : 0; let a = 0; for (let t = 0; t < s.length; t++)if (0 != (1 << t & n)) { var h = s[t], l = this.tokens[t]; if ((!r || h.fallback) && (!h.contextual && l.start == e.pos && l.mask == n && l.context == o || (this.updateCachedToken(l, h, e), l.mask = n, l.context = o), l.lookAhead > l.end + 25 && (a = Math.max(l.lookAhead, a)), 0 != l.value)) { var c = i; if (-1 < l.extended && (i = this.addActions(e, l.extended, l.end, i)), i = this.addActions(e, l.value, l.end, i), !h.extend && (r = l, i > c)) break } } for (; this.actions.length > i;)this.actions.pop(); return a && e.setLookAhead(a), r || e.pos != this.stream.end || ((r = new Qd).value = e.p.parser.eofTerm, r.start = r.end = e.pos, i = this.addActions(e, r.value, r.end, i)), this.mainToken = r, this.actions } getMainToken(t) { var e, i; return this.mainToken || ({ pos: t, p: i } = t, (e = new Qd).start = t, e.end = Math.min(t + 1, i.stream.end), e.value = t == i.stream.end ? i.parser.eofTerm : 0, e) } updateCachedToken(e, t, i) { var r = this.stream.clipPos(i.pos); if (t.token(this.stream.reset(r, e), i), -1 < e.value) { var s = i.p.parser; for (let t = 0; t < s.specialized.length; t++)if (s.specialized[t] == e.value) { var n = s.specializers[t](this.stream.read(e.start, e.end), i); if (0 <= n && i.p.parser.dialect.allows(n >> 1)) { 0 == (1 & n) ? e.value = n >> 1 : e.extended = n >> 1; break } } } else e.value = 0, e.end = this.stream.clipPos(r + 1) } putAction(e, t, i, r) { for (let t = 0; t < r; t += 3)if (this.actions[t] == e) return r; return this.actions[r++] = e, this.actions[r++] = t, this.actions[r++] = i, r } addActions(t, i, r, s) { var n = t.state, o = t.p.parser, a = o.data; for (let e = 0; e < 2; e++)for (let t = o.stateSlot(n, e ? 2 : 1); ; t += 3) { if (65535 == a[t]) { if (1 != a[t + 1]) { 0 == s && 2 == a[t + 1] && (s = this.putAction(au(a, t + 2), i, r, s)); break } t = au(a, t + 2) } a[t] == i && (s = this.putAction(au(a, t + 1), i, r, s)) } return s } }, su = class { constructor(t, e, i, r) { this.parser = t, this.input = e, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new Kd(e, r), this.tokens = new ru(t, this.stream), this.topTerm = t.top[1]; e = r[0].from; this.stacks = [Fd.start(this, t.top[0], e)], this.fragments = i.length && this.stream.end - e > 4 * t.bufferLength ? new iu(i, t.nodeSet) : null } get parsedPos() { return this.minStackPos } advance() { let e = this.stacks, i = this.minStackPos; var r = this.stacks = []; let s, n; if (300 < this.bigReductionCount && 1 == e.length) { for (var [t] = e; t.forceReduce() && t.stack.length && t.stack[t.stack.length - 2] >= this.lastBigReductionStart;); this.bigReductionCount = this.lastBigReductionSize = 0 } for (let t = 0; t < e.length; t++)for (var o = e[t]; ;) { if (this.tokens.mainToken = null, o.pos > i) r.push(o); else { if (this.advanceStack(o, r, e)) continue; s || (s = [], n = []), s.push(o); var a = this.tokens.getMainToken(o); n.push(a.value, a.end) } break } if (!r.length) { var h = s && (t => { let e = null; for (var i of t) { var r = i.p.stoppedAt; (i.pos == i.p.stream.end || null != r && i.pos > r) && i.p.parser.stateFlag(i.state, 2) && (!e || e.score < i.score) && (e = i) } return e })(s); if (h) return Zd && console.log("Finish with " + this.stackID(h)), this.stackToTree(h); if (this.parser.strict) throw Zd && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + i); this.recovering || (this.recovering = 5) } if (this.recovering && s) { h = null != this.stoppedAt && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, n, r); if (h) return Zd && console.log("Force-finish " + this.stackID(h)), this.stackToTree(h.forceAll()) } if (this.recovering) { var l = 1 == this.recovering ? 1 : 3 * this.recovering; if (r.length > l) for (r.sort((t, e) => e.score - t.score); r.length > l;)r.pop(); r.some(t => t.reducePos > i) && this.recovering-- } else if (1 < r.length) { t: for (let e = 0; e < r.length - 1; e++) { var c = r[e]; for (let t = e + 1; t < r.length; t++) { var d = r[t]; if (c.sameState(d) || 500 < c.buffer.length && 500 < d.buffer.length) { if (!(0 < (c.score - d.score || c.buffer.length - d.buffer.length))) { r.splice(e--, 1); continue t } r.splice(t--, 1) } } } 12 < r.length && r.splice(12, r.length - 12) } this.minStackPos = r[0].pos; for (let t = 1; t < r.length; t++)r[t].pos < this.minStackPos && (this.minStackPos = r[t].pos); return null } stopAt(t) { if (null != this.stoppedAt && this.stoppedAt < t) throw new RangeError("Can't move stoppedAt forward"); this.stoppedAt = t } advanceStack(e, i, r) { var s = e.pos, n = this.parser, o = Zd ? this.stackID(e) + " -> " : ""; if (null != this.stoppedAt && s > this.stoppedAt) return e.forceReduce() ? e : null; if (this.fragments) { var a = e.curContext && e.curContext.tracker.strict, h = a ? e.curContext.hash : 0; for (let t = this.fragments.nodeAt(s); t;) { var l = this.parser.nodeSet.types[t.type.id] == t.type ? n.getGoto(e.state, t.type.id) : -1; if (-1 < l && t.length && (!a || (t.prop(_.contextHash) || 0) == h)) return e.useNode(t, l), Zd && console.log(o + this.stackID(e) + ` (via reuse of ${n.getName(t.type.id)})`), !0; if (!(t instanceof j) || 0 == t.children.length || 0 < t.positions[0]) break; l = t.children[0]; if (!(l instanceof j && 0 == t.positions[0])) break; t = l } } var t = n.stateSlot(e.state, 4); if (0 < t) return e.reduce(t), Zd && console.log(o + this.stackID(e) + ` (via always-reduce ${n.getName(65535 & t)})`), !0; if (8400 <= e.stack.length) for (; 6e3 < e.stack.length && e.forceReduce();); var c = this.tokens.getActions(e); for (let t = 0; t < c.length;) { var d = c[t++], u = c[t++], f = c[t++], p = t == c.length || !r, m = p ? e : e.split(), g = this.tokens.mainToken; if (m.apply(d, u, g ? g.start : m.pos, f), Zd && console.log(o + this.stackID(m) + ` (via ${0 == (65536 & d) ? "shift" : "reduce of " + n.getName(65535 & d)} for ${n.getName(u)} @ ${s}${m == e ? "" : ", split"})`), p) return !0; (m.pos > s ? i : r).push(m) } return !1 } advanceFully(t, e) { for (var i = t.pos; ;) { if (!this.advanceStack(t, null, null)) return !1; if (t.pos > i) return nu(t, e), !0 } } runRecovery(o, a, h) { let l = null, c = !1; for (let n = 0; n < o.length; n++) { let t = o[n], e = a[n << 1], i = a[1 + (n << 1)]; var d, u = Zd ? this.stackID(t) + " -> " : ""; if (t.deadEnd) { if (c) continue; if (c = !0, t.restart(), Zd && console.log(u + this.stackID(t) + " (restarted)"), this.advanceFully(t, h)) continue } let r = t.split(), s = u; for (let t = 0; r.forceReduce() && t < 10; t++) { if (Zd && console.log(s + this.stackID(r) + " (via force-reduce)"), this.advanceFully(r, h)) break; Zd && (s = this.stackID(r) + " -> ") } for (d of t.recoverByInsert(e)) Zd && console.log(u + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, h); this.stream.end > t.pos ? (i == t.pos && (i++, e = 0), t.recoverByDelete(e, i), Zd && console.log(u + this.stackID(t) + ` (via recover-delete ${this.parser.getName(e)})`), nu(t, h)) : (!l || l.score < t.score) && (l = t) } return l } stackToTree(t) { return t.close(), j.build({ buffer: jd.create(t), nodeSet: this.parser.nodeSet, topID: this.topTerm, maxBufferLength: this.parser.bufferLength, reused: this.reused, start: this.ranges[0].from, length: t.pos - this.ranges[0].from, minRepeatType: this.parser.minRepeatTerm }) } stackID(t) { let e = (tu = tu || new WeakMap).get(t); return e || tu.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t } }; function nu(e, i) { for (let t = 0; t < i.length; t++) { var r = i[t]; if (r.pos == e.pos && r.sameState(e)) return void (i[t].score < e.score && (i[t] = e)) } i.push(e) } var ou = class { constructor(t, e, i) { this.source = t, this.flags = e, this.disabled = i } allows(t) { return !this.disabled || 0 == this.disabled[t] } }, _e = class sp extends Vo { constructor(i) { if (super(), this.wrappers = [], 14 != i.version) throw new RangeError(`Parser version (${i.version}) doesn't match runtime version (14)`); var e = i.nodeNames.split(" "); this.minRepeatTerm = e.length; for (let t = 0; t < i.repeatNodeCount; t++)e.push(""); let r = Object.keys(i.topRules).map(t => i.topRules[t][1]), s = []; for (let t = 0; t < e.length; t++)s.push([]); function n(t, e, i) { s[t].push([e, e.deserialize(String(i))]) } if (i.nodeProps) for (var o of i.nodeProps) { let i = o[0]; "string" == typeof i && (i = _[i]); for (let e = 1; e < o.length;) { var a = o[e++]; if (0 <= a) n(a, i, o[e++]); else { var h = o[e + -a]; for (let t = -a; 0 < t; t--)n(o[e++], i, h); e++ } } } this.nodeSet = new vo(e.map((t, e) => go.define({ name: e >= this.minRepeatTerm ? void 0 : t, id: e, props: s[e], top: -1 < r.indexOf(e), error: 0 == e, skipped: i.skippedNodes && -1 < i.skippedNodes.indexOf(e) }))), i.propSources && (this.nodeSet = this.nodeSet.extend(...i.propSources)), this.strict = !1, this.bufferLength = 1024; let l = Ud(i.tokenData); this.context = i.context, this.specializerSpecs = i.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length); for (let t = 0; t < this.specializerSpecs.length; t++)this.specialized[t] = this.specializerSpecs[t].term; this.specializers = this.specializerSpecs.map(hu), this.states = Ud(i.states, Uint32Array), this.data = Ud(i.stateData), this.goto = Ud(i.goto), this.maxTerm = i.maxTerm, this.tokenizers = i.tokenizers.map(t => "number" == typeof t ? new Xd(l, t) : t), this.topRules = i.topRules, this.dialects = i.dialects || {}, this.dynamicPrecedences = i.dynamicPrecedences || null, this.tokenPrecTable = i.tokenPrec, this.termNames = i.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]] } createParse(t, e, i) { let r = new su(this, t, e, i); for (var s of this.wrappers) r = s(r, t, e, i); return r } getGoto(e, i, r = !1) { var s = this.goto; if (i >= s[0]) return -1; for (let t = s[i + 1]; ;) { var n = s[t++], o = 1 & n, a = s[t++]; if (o && r) return a; for (var h = t + (n >> 1); t < h; t++)if (s[t] == e) return a; if (o) return -1 } } hasAction(r, s) { var n = this.data; for (let i = 0; i < 2; i++)for (let t = this.stateSlot(r, i ? 2 : 1), e; ; t += 3) { if (65535 == (e = n[t])) { if (1 != n[t + 1]) { if (2 == n[t + 1]) return au(n, t + 2); break } e = n[t = au(n, t + 2)] } if (e == s || 0 == e) return au(n, t + 1) } return 0 } stateSlot(t, e) { return this.states[6 * t + e] } stateFlag(t, e) { return 0 < (this.stateSlot(t, 0) & e) } validAction(t, e) { return !!this.allActions(t, t => t == e || null) } allActions(e, i) { var t = this.stateSlot(e, 4); let r = t ? i(t) : void 0; for (let t = this.stateSlot(e, 1); null == r; t += 3) { if (65535 == this.data[t]) { if (1 != this.data[t + 1]) break; t = au(this.data, t + 2) } r = i(au(this.data, t + 1)) } return r } nextStates(e) { var r = []; for (let t = this.stateSlot(e, 1); ; t += 3) { if (65535 == this.data[t]) { if (1 != this.data[t + 1]) break; t = au(this.data, t + 2) } if (0 == (1 & this.data[t + 2])) { let i = this.data[t + 1]; r.some((t, e) => 1 & e && t == i) || r.push(this.data[t], i) } } return r } configure(r) { let s = Object.assign(Object.create(sp.prototype), this); if (r.props && (s.nodeSet = this.nodeSet.extend(...r.props)), r.top) { var t = this.topRules[r.top]; if (!t) throw new RangeError("Invalid top rule name " + r.top); s.top = t } return r.tokenizers && (s.tokenizers = this.tokenizers.map(e => { var t = r.tokenizers.find(t => t.from == e); return t ? t.to : e })), r.specializers && (s.specializers = this.specializers.slice(), s.specializerSpecs = this.specializerSpecs.map((e, t) => { var i = r.specializers.find(t => t.from == e.external); return i ? (i = Object.assign(Object.assign({}, e), { external: i.to }), s.specializers[t] = hu(i), i) : e })), r.contextTracker && (s.context = r.contextTracker), r.dialect && (s.dialect = this.parseDialect(r.dialect)), null != r.strict && (s.strict = r.strict), r.wrap && (s.wrappers = s.wrappers.concat(r.wrap)), null != r.bufferLength && (s.bufferLength = r.bufferLength), s } hasWrappers() { return 0 < this.wrappers.length } getName(t) { return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t) } get eofTerm() { return this.maxNode + 1 } get topNode() { return this.nodeSet.types[this.top[1]] } dynamicPrecedence(t) { var e = this.dynamicPrecedences; return null != e && e[t] || 0 } parseDialect(t) { var r = Object.keys(this.dialects), e = r.map(() => !1); if (t) for (var i of t.split(" ")) { i = r.indexOf(i); 0 <= i && (e[i] = !0) } let s = null; for (let i = 0; i < r.length; i++)if (!e[i]) for (let t = this.dialects[r[i]], e; 65535 != (e = this.data[t++]);)(s = s || new Uint8Array(this.maxTerm + 1))[e] = 1; return new ou(t, e, s) } static deserialize(t) { return new sp(t) } }; function au(t, e) { return t[e] | t[e + 1] << 16 } function hu(r) { if (r.external) { let i = r.extend ? 1 : 0; return (t, e) => r.external(t, e) << 1 | i } return r.get } var lu = 20, cu = 21; function du(t) { return 65 <= t && t <= 90 || 97 <= t && t <= 122 || 48 <= t && t <= 57 } function uu(e, i, r) { for (let t = !1; ;) { if (e.next < 0) return; if (e.next == i && !t) return void e.advance(); t = r && !t && 92 == e.next, e.advance() } } function fu(t, e) { for (; 95 == t.next || du(t.next);)null != e && (e += String.fromCharCode(t.next)), t.advance(); return e } function pu(t, e) { for (; 48 == t.next || 49 == t.next;)t.advance(); e && t.next == e && t.advance() } function mu(t, e) { for (; ;) { if (46 == t.next) { if (e) break; e = !0 } else if (t.next < 48 || 57 < t.next) break; t.advance() } if (69 == t.next || 101 == t.next) for (t.advance(), 43 != t.next && 45 != t.next || t.advance(); 48 <= t.next && t.next <= 57;)t.advance() } function gu(t) { for (; !(t.next < 0 || 10 == t.next);)t.advance() } function vu(e, i) { for (let t = 0; t < i.length; t++)if (i.charCodeAt(t) == e) return 1 } var wu = " \t\r\n"; function bu(t, e, i) { var r, s, n, o = Object.create(null); o.true = o.false = 5, o.null = o.unknown = 6; for (r of t.split(" ")) r && (o[r] = lu); for (s of e.split(" ")) s && (o[s] = cu); for (n of (i || "").split(" ")) n && (o[n] = 24); return o } var je = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", Ke = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", yu = { backslashEscapes: !1, hashComments: !1, spaceAfterDashes: !1, slashComments: !1, doubleQuotedStrings: !1, doubleDollarQuotedStrings: !1, unquotedBitLiterals: !1, treatBitsAsBytes: !1, charSetCasts: !1, plsqlQuotingMechanism: !1, operatorChars: "*+-%<>!=&|~^/", specialVar: "?", identifierQuotes: '"', words: bu(Ke, je) }; function xu(o) { return new Gd(e => { var t, i, r = e.next; if (e.advance(), vu(r, wu)) { for (; vu(e.next, wu);)e.advance(); e.acceptToken(36) } else if (36 == r && 36 == e.next && o.doubleDollarQuotedStrings) (t => { for (; ;) { if (t.next < 0 || t.peek(1) < 0) return; if (36 == t.next && 36 == t.peek(1)) return t.advance(2); t.advance() } })(e), e.acceptToken(3); else if (39 == r || 34 == r && o.doubleQuotedStrings) uu(e, r, o.backslashEscapes), e.acceptToken(3); else if (35 == r && o.hashComments || 47 == r && 47 == e.next && o.slashComments) gu(e), e.acceptToken(1); else if (45 != r || 45 != e.next || o.spaceAfterDashes && 32 != e.peek(1)) if (47 == r && 42 == e.next) { e.advance(); for (let t = 1; ;) { var s = e.next; if (e.next < 0) break; if (e.advance(), 42 == s && 47 == e.next) { if (t--, e.advance(), !t) break } else 47 == s && 42 == e.next && (t++, e.advance()) } e.acceptToken(2) } else if (101 != r && 69 != r || 39 != e.next) if (110 != r && 78 != r || 39 != e.next || !o.charSetCasts) if (95 == r && o.charSetCasts) for (let t = 0; ; t++) { if (39 == e.next && 1 < t) { e.advance(), uu(e, 39, o.backslashEscapes), e.acceptToken(3); break } if (!du(e.next)) break; e.advance() } else if (o.plsqlQuotingMechanism && (113 == r || 81 == r) && 39 == e.next && 0 < e.peek(1) && !vu(e.peek(1), wu)) { var n = e.peek(1); e.advance(2), ((t, e) => { for (var i = "[{<(".indexOf(String.fromCharCode(e)), r = i < 0 ? e : "]}>)".charCodeAt(i); ;) { if (t.next < 0) return; if (t.next == r && 39 == t.peek(1)) return t.advance(2); t.advance() } })(e, n), e.acceptToken(3) } else if (40 == r) e.acceptToken(7); else if (41 == r) e.acceptToken(8); else if (123 == r) e.acceptToken(9); else if (125 == r) e.acceptToken(10); else if (91 == r) e.acceptToken(11); else if (93 == r) e.acceptToken(12); else if (59 == r) e.acceptToken(13); else if (o.unquotedBitLiterals && 48 == r && 98 == e.next) e.advance(), pu(e), e.acceptToken(22); else if (98 != r && 66 != r || 39 != e.next && 34 != e.next) if (48 == r && (120 == e.next || 88 == e.next) || (120 == r || 88 == r) && 39 == e.next) { var n = 39 == e.next; for (e.advance(); 48 <= (i = e.next) && i <= 57 || 97 <= i && i <= 102 || 65 <= i && i <= 70;)e.advance(); n && 39 == e.next && e.advance(), e.acceptToken(4) } else if (46 == r && 48 <= e.next && e.next <= 57) mu(e, !0), e.acceptToken(4); else if (46 == r) e.acceptToken(14); else if (48 <= r && r <= 57) mu(e, !1), e.acceptToken(4); else if (vu(r, o.operatorChars)) { for (; vu(e.next, o.operatorChars);)e.advance(); e.acceptToken(15) } else vu(r, o.specialVar) ? (e.next == r && e.advance(), 39 == (n = e).next || 34 == n.next || 96 == n.next ? (t = n.next, n.advance(), uu(n, t, !1)) : fu(n), e.acceptToken(17)) : vu(r, o.identifierQuotes) ? (uu(e, r, !1), e.acceptToken(19)) : 58 == r || 44 == r ? e.acceptToken(16) : du(r) && (t = fu(e, String.fromCharCode(r)), e.acceptToken(46 != e.next && null != (r = o.words[t.toLowerCase()]) ? r : 18)); else { r = e.next; e.advance(), o.treatBitsAsBytes ? (uu(e, r, o.backslashEscapes), e.acceptToken(23)) : (pu(e, r), e.acceptToken(22)) } else e.advance(), uu(e, 39, o.backslashEscapes), e.acceptToken(3); else e.advance(), uu(e, 39, !0); else gu(e), e.acceptToken(1) }) } var ku = xu(yu); function Su(t) { for (var e = t.cursor().moveTo(t.from, -1); /Comment/.test(e.name);)e.moveTo(e.from, -1); return e.node } function Cu(t, e) { t = t.sliceString(e.from, e.to), e = /^([`'"])(.*)\1$/.exec(t); return e ? e[2] : t } function Au(t) { return t && ("Identifier" == t.name || "QuotedIdentifier" == t.name) } function Ou(t, e) { for (var i = []; ;) { if (!e || "." != e.name) return i; var r = Su(e); if (!Au(r)) return i; i.unshift(Cu(t, r)), e = Su(r) } } function Mu(t, e) { var i = P(t).resolveInner(e, -1), r = ((s, e) => { let n; for (let t = e; !n; t = t.parent) { if (!t) return null; "Statement" == t.name && (n = t) } let o = null; for (let e = n.firstChild, i = !1, r = null; e; e = e.nextSibling) { var a = "Keyword" == e.name ? s.sliceString(e.from, e.to).toLowerCase() : null; let t = null; if (i) if ("as" == a && r && Au(e.nextSibling)) t = Cu(s, e.nextSibling); else { if (a && Tu.has(a)) break; r && Au(e) && (t = Cu(s, e)) } else i = "from" == a; t && ((o = o || Object.create(null))[t] = ((e, i) => { if ("CompositeIdentifier" != i.name) return [Cu(e, i)]; var r = []; for (let t = i.firstChild; t; t = t.nextSibling)Au(t) && r.push(Cu(e, t)); return r })(s, r)), r = /Identifier$/.test(e.name) ? e : null } return o })(t.doc, i); return "Identifier" == i.name || "QuotedIdentifier" == i.name || "Keyword" == i.name ? { from: i.from, quoted: "QuotedIdentifier" == i.name ? t.doc.sliceString(i.from, i.from + 1) : null, parents: Ou(t.doc, Su(i)), aliases: r } : "." == i.name ? { from: e, quoted: null, parents: Ou(t.doc, i), aliases: r } : { from: e, quoted: null, parents: [], empty: !0, aliases: r } } var Tu = new Set("where group having order union intersect except all distinct limit offset fetch for".split(" ")); var Du = /^\w*$/, Pu = /^[`'"]?\w*[`'"]?$/, Ru = class np { constructor() { this.list = [], this.children = void 0 } child(t, e) { var i = this.children || (this.children = Object.create(null)), r = i[t]; return r || (t && this.list.push(Bu(t, "type", e)), i[t] = new np) } addCompletions(t) { for (let e of t) { var i = this.list.findIndex(t => t.label == e.label); -1 < i ? this.list[i] = e : this.list.push(e) } } }; function Bu(t, e, i) { return /^[a-z_][a-z_\d]*$/.test(t) ? { label: t, type: e } : { label: t, type: e, apply: i + t + i } } function Eu(e, t, i, d, r, s) { let n, u = new Ru, f = (null == (n = null == s ? void 0 : s.spec.identifierQuotes) ? void 0 : n[0]) || '"', p = u.child(r || "", f); for (var o in e) { var a, h, l = o.replace(/\\?\./g, t => "." == t ? "\0" : t).split("\0"); let t = 1 == l.length ? p : u; for (a of l) t = t.child(a.replace(/\\\./g, "."), f); for (h of e[o]) h && t.list.push("string" == typeof h ? Bu(h, "property", f) : h) } return t && p.addCompletions(t), i && u.addCompletions(i), u.addCompletions(p.list), d && u.addCompletions(p.child(d, f).list), t => { let { parents: e, from: i, quoted: r, empty: s, aliases: n } = Mu(t.state, t.pos); if (s && !t.explicit) return null; n && 1 == e.length && (e = n[e[0]] || e); let o = u; for (var a of e) { for (; !o.children || !o.children[a];)if (o == u) o = p; else { if (o != p || !d) return null; o = o.child(d, f) } o = o.child(a, f) } var h, l = r && t.state.sliceDoc(t.pos, t.pos + 1) == r; let c = o.list; return o == u && n && (c = c.concat(Object.keys(n).map(t => ({ label: t, type: "constant" })))), { from: i, to: l ? t.pos + 1 : void 0, options: (h = r, l = c, h ? l.map(t => Object.assign(Object.assign({}, t), { label: t.label[0] == h ? t.label : h + t.label + h, apply: void 0 })) : l), validFor: r ? Pu : Du } } } function Lu(e, i) { var r, t, s = Object.keys(e).map(t => ({ label: i ? t.toUpperCase() : t, type: e[t] == cu ? "type" : e[t] == lu ? "keyword" : "variable", boost: -1 })); return r = ["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], t = Oc(s), e => { for (let t = P(e.state).resolveInner(e.pos, -1); t; t = t.parent) { if (-1 < r.indexOf(t.name)) return null; if (t.type.isTop) break } return t(e) } } var Nu = _e.deserialize({ version: 14, states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw", stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O", goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq", nodeNames: "âš  LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement", maxTerm: 38, nodeProps: [["isolate", -4, 1, 2, 3, 19, ""]], skippedNodes: [0, 1, 2], repeatNodeCount: 3, tokenData: "RORO", tokenizers: [0, ku], topRules: { Script: [0, 25] }, tokenPrec: 0 }).configure({ props: [xa.add({ Statement: Aa() }), Ma.add({ Statement(t) { return { from: t.firstChild.to, to: t.to } }, BlockComment(t) { return { from: t.from + 2, to: t.to - 2 } } }), _o({ Keyword: h.keyword, Type: h.typeName, Builtin: h.standard(h.name), Bits: h.number, Bytes: h.string, Bool: h.bool, Null: h.null, Number: h.number, String: h.string, Identifier: h.name, QuotedIdentifier: h.special(h.string), SpecialVar: h.special(h.name), LineComment: h.lineComment, BlockComment: h.blockComment, Operator: h.operator, "Semi Punctuation": h.punctuation, "( )": h.paren, "{ }": h.brace, "[ ]": h.squareBracket })] }), hl = class op { constructor(t, e, i) { this.dialect = t, this.language = e, this.spec = i } get extension() { return this.language.extension } static define(t) { var e = ((t, e, i, r) => { var s, n = {}; for (s in yu) n[s] = (t.hasOwnProperty(s) ? t : yu)[s]; return e && (n.words = bu(e, i || "", r)), n })(t, t.keywords, t.types, t.builtin), i = sa.define({ name: "sql", parser: Nu.configure({ tokenizers: [{ from: ku, to: xu(e) }] }), languageData: { commentTokens: { line: "--", block: { open: "/*", close: "*/" } }, closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] } } }); return new op(e, i, t) } }; function Iu(t, e = !1) { return t.language.data.of({ autocomplete: ([t, e = !1] = [t, e], Lu(t.dialect.words, e)) }) } function Vu(t) { return t.schema ? (t.dialect || Hu).language.data.of({ autocomplete: (t = t).schema ? Eu(t.schema, t.tables, t.schemas, t.defaultTable, t.defaultSchema, t.dialect || Hu) : () => null }) : [] } var Hu = hl.define({}), r = "#e06c75", Xo = "#abb2bf", i = "#7d8799", s = "#d19a66", Go = "#2c313a", e = "#282c34", n = "#353a42", Zo = "#528bff", Wu = [T.theme({ "&": { color: Xo, backgroundColor: e }, ".cm-content": { caretColor: Zo }, ".cm-cursor, .cm-dropCursor": { borderLeftColor: Zo }, "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: "#3E4451" }, ".cm-panels": { backgroundColor: "#21252b", color: Xo }, ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" }, ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" }, ".cm-searchMatch": { backgroundColor: "#72a1ff59", outline: "1px solid #457dff" }, ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: "#6199ff2f" }, ".cm-activeLine": { backgroundColor: "#6699ff0b" }, ".cm-selectionMatch": { backgroundColor: "#aafe661a" }, "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bad0f847" }, ".cm-gutters": { backgroundColor: e, color: i, border: "none" }, ".cm-activeLineGutter": { backgroundColor: Go }, ".cm-foldPlaceholder": { backgroundColor: "transparent", border: "none", color: "#ddd" }, ".cm-tooltip": { border: "none", backgroundColor: n }, ".cm-tooltip .cm-tooltip-arrow:before": { borderTopColor: "transparent", borderBottomColor: "transparent" }, ".cm-tooltip .cm-tooltip-arrow:after": { borderTopColor: n, borderBottomColor: n }, ".cm-tooltip-autocomplete": { "& > ul > li[aria-selected]": { backgroundColor: Go, color: Xo } } }, { dark: !0 }), Ja(Ka.define([{ tag: h.keyword, color: "#c678dd" }, { tag: [h.name, h.deleted, h.character, h.propertyName, h.macroName], color: r }, { tag: [h.function(h.variableName), h.labelName], color: "#61afef" }, { tag: [h.color, h.constant(h.name), h.standard(h.name)], color: s }, { tag: [h.definition(h.name), h.separator], color: Xo }, { tag: [h.typeName, h.className, h.number, h.changed, h.annotation, h.modifier, h.self, h.namespace], color: "#e5c07b" }, { tag: [h.operator, h.operatorKeyword, h.url, h.escape, h.regexp, h.link, h.special(h.string)], color: "#56b6c2" }, { tag: [h.meta, h.comment], color: i }, { tag: h.strong, fontWeight: "bold" }, { tag: h.emphasis, fontStyle: "italic" }, { tag: h.strikethrough, textDecoration: "line-through" }, { tag: h.link, color: i, textDecoration: "underline" }, { tag: h.heading, fontWeight: "bold", color: r }, { tag: [h.atom, h.bool, h.special(h.variableName)], color: s }, { tag: [h.processingInstruction, h.string, h.inserted], color: "#98c379" }, { tag: h.invalid, color: "#ffffff" }]))], zu = new yt; window.SqlEditor = function(t, i) { this.element = t, this.editor = void 0, this.readOnly = !1, this.set = function(t) { var e; null == this.editor && (this.editor = new T({ doc: t = null == t ? "" : t, parent: document.getElementById(this.element), extensions: [zd, (e = (t = {}).dialect || Hu, new pa(e.language, [Vu(t), Iu(e, !!t.upperCaseKeywords)])), zu.of([Wu]), Vs.of([Cl]), ga.of("\t"), w.readOnly.of(this.readOnly)] }), "dark" == i ? this.setDarkTheme() : this.setLightTheme()) }, this.setLightTheme = function() { this.editor.dispatch({ effects: zu.reconfigure([]) }), document.querySelector("#" + this.element + " .cm-content").classList.add("cm-light-theme") }, this.setDarkTheme = function() { this.editor.dispatch({ effects: zu.reconfigure([Wu]) }), document.querySelector("#" + this.element + " .cm-content").classList.add("cm-dark-theme") }, this.setReadOnly = function(t) { (t = null == t ? !this.readOnly : t) != this.readOnly && (this.readOnly = t, this.readOnly ? (document.querySelector("#" + this.element + " .cm-content").classList.add("cm-editor-readonly"), document.querySelector("#" + this.element + " .cm-content").setAttribute("contenteditable", "false")) : (document.querySelector("#" + this.element + " .cm-content").classList.remove("cm-editor-readonly"), document.querySelector("#" + this.element + " .cm-content").setAttribute("contenteditable", "true"))) }, this.clean = function() { null != this.editor && (this.editor.destroy(), this.editor = void 0) }, this.setCode = function(t, e, i) { null == i && (i = this.editor.state.doc.length), this.editor.dispatch({ changes: { from: e = null == e ? 0 : e, to: i, insert: t } }) }, this.getCode = function(t, e) { return null == e && (e = this.editor.state.doc.length), this.editor.state.doc.sliceString(t = null == t ? 0 : t, e) }, this.getSelection = function() { return this.editor.state.sliceDoc(this.editor.state.selection.main.from, this.editor.state.selection.main.to) }, this.replaceSelection = function(t) { var e = this.editor.state.selection.main.from, i = this.editor.state.selection.main.to; this.setCode("", e, i), this.setCode(t, e, e) }, this.openSearch = function() { mc(this.editor) }, null != this.element && this.set() } })();